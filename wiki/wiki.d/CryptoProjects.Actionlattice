version=pmwiki-2.2.133 ordered=1 urlencoded=1
author=
charset=UTF-8
csum=Factorn whitepaper [[https://fact0rn.io/FACT0RN_whitepaper.pdf|#]] takes them 200 semiprimes to find a valid semiprime (has a factor of exactly half the bitlength) about 1 in 20 for reasonably strong semiprimes.  This means my finding that 1 in 300 numbers is semiprime, 1 in 6,000 numbers is a strong (base-2 brilliant) semiprime. 
ctime=1664341422
name=CryptoProjects.Actionlattice
rev=100
targets=CryptoProjects.Blocklattice,CryptoProjects.CollectBit,NatureVault.DigitalCollectibleNetwork,CryptoProjects.BlockDAG,NatureVault.Solvum,NatureVault.Quantum,CryptoProjects.Dustyplasma,CryptoProjects.Posi,CryptoProjects.ProofOfSemiprime,CryptoProjects.OPoW,Category.Cryptics
text=(:Summary:A lattice of individual cross-confirming transactions that can be mined offline as a replacement to a blockchain or blockDAG.  It scales to infinite transactions per second, is immune to traditional 51%25 [[#attacks|attacks]], can get initial confirmation within a few seconds, reward is proportional, CPU dominated, ASICs will never dominate, and also resists GPU and Quantum computer takeover while allowing them to mine.:)%0a(:Published:9/28/2022:)%0a(:Author:[[~GiverofMemory]]:)%0a(:License:[[https://en.m.wikipedia.org/wiki/Res_communis|Site License]]:)%0a(:Update::)%0a(:Maintainer:[[~GiverofMemory]]:)%0a(:Creator:[[]]:)%0a(:Categories:[[!Cryptics]]:)%0a(:Also:none:)%0a(:Archive:[[|Archive.is]], [[https://web.archive.org/web/20220929004452/https://www.naturevault.org/wiki/pmwiki.php/CryptoProjects/Actionlattice|Archive.org]],  [[https://web.archive.org/web/20220928204808/https://www.naturevault.org/wiki/pmwiki.php/CryptoProjects/Actionlattice|OLDArchive.org]]:)%0a(:Download:[[{$FullName}?action=print|URL]],[[https://www.web2pdfconvert.com/|PDF from URL]]:)%0a%0aSee also [[Blocklattice]], [[CollectBit]], [[NatureVault/Digital Collectible Network]], [[BlockDAG]], [[NatureVault/Solvum]], [[NatureVault/Quantum]], [[Dustyplasma]]%0a%0aAn actionlattice is a new method to create, order, and store transactions, prove work, confirm transaction validity, prevent double spending, maintain privacy, and issue rewards (cips).  It replaces the blockchain.%0a%0aThe smallest (and only) unit of account is the cip (dust). The name is a convolution of "bit", "semiprime" maybe "cipher" or "sip".%0a%0aEvery transaction is free to propose, and then a miner (or you - if you mine your own tx) gets paid with a reward cip if they "activate" the proposed transaction using proof of semiprime ([[Posi]]) and point (connect) it to two other transactions that they validate and vouch for, preferably these two other transactions are near the "surface" but whose cip genesis is deep below the surface.  Next, other new activated transactions will point (connect) to yours which "confirms" yours.  Some factors that will help decide whether they confirm yours or not is if it fits in the majority of nodes "max transaction size", and if it is near the surface but the cip genesis is deep from the surface.  The surface is just the layer of unconfirmed transactions on the edge of the lattice.%0a%0aThe mining reward for activating a transaction would mature by whether your transaction is confirmed by others linking their transactions to yours.  Some consensus on how "well connected" your transaction needs to be (how deep from the surface) in order for your mining reward to be valid.  I suppose you can try to spend them immediately and it is up to each miner whether they build on a transaction whose genesis isn't deep from the surface.  I suppose it would take a while for your spending transaction to be confirmed before miners feel it is valid.%0a%0aAttach:actionlattice.png%0a%0aIn addition to setting the max transaction size they record, nodes also decide how much proof (bitlength) is needed to activate a transaction.  Some nodes might accept 120 digit numbers (397 bit - cip397's) , some 140 (463 bit - cip463's).  More proof can be added to the transaction later (basically any transaction can be re-mined just as long as it has a higher bitlevel proof than the original.  The original is kept and not deleted unless its proof level falls below the nodes requirement) which works because cips cannot be double spent by definition, addresses are throwaway and cannot hold more than 1 cip and once they send it they cannot recieve another cip ever again.  So "fast" nodes will accept small proofs and thus transactions can be initially confirmed quickly and then as more proof gets added slower nodes will recognize the transactions.  The more proof you the miner provides, the more valuable the "cip" the miner receives as a reward is.  Some merchants may accept only cip463's, and others may accept cip397's as well, but assign a lesser value to them.%0a%0aAll a cryptocurrency would need is an actionlattice.  Also a UTXO may be used, and will be helpful because of pruning.  The UTXO would simply carry a list of addresses with balance of 1 cip, and used addresses (that contain 0 cips) and these cannot be reused (this is done to maintain privacy).  That said UTXO omission could be a feature as it would mean transactions keep needing to be re-mined at current difficulty to not be purged (and effectively reversed).%0a%0aEach transaction is it's very own "block" and stands alone.  It can be broadcast with or without [[proof of semiprime]] [[Posi]].  If it is broadcast to the network with no proof, then a miner would need to activate and connect it wherever they want in the lattice (they will probably selfishly connect it to their own transactions to add confirmations).%0a%0aEach transaction can send cips from one public key to another.  Each public key can hold only 1 cip.  Think of each cip as a "bit".  Each bit is immutable and cannot be split or added to.  Each bit (cip) has one public and private key.%0a%0aMining any size transaction will require a certain amount of proof of semiprime, lets say a 20 minute target.  This is set by the nodes.  Perhaps a target of a few seconds can act as an initial confirmation and later a 20 min proof would be important to get all the nodes to accept it.%0a%0aEach transaction contains public addresses and signatures for each of the cips being sent and the public addresses for each cip to be received to, a cipbase address where a new cip is created and given to, and a message field that an be used for iterating nonces and including messages.%0a%0a!!Process%0a!!!Transactor side%0a%0a#"Sending Public Addresses" (SPA's) of each bit being sent%0a%0a#Signatures (proves private key ownership) for the addresses for each bit being sent%0a%0a#"Receiving Public Addresses" (RPA's) - One address for each bit being received.%0a%0a#Internal Message (IM) which can be anything%0a%0a#Completed transaction signature - Signs over the whole transaction done by the sender.  This prevents man in the middle (MITM) attack.%0a----%0a!!!Miner's side%0a%0a#Proof of Sieve (Posi) message - %0a%0a#Proof of Proven Sieve (Props) - number to factor, nonce, and 2 factors%0a%0a#Peer blocks - 2 peer blocks Msig within the last epoch that you confirm are correct (if you are wrong about their validity your transaction may become voided)%0a%0a#Bitbase address which is the Miners public address (MPA) where the bitbase is sent, 1 bit for 10 kb or whatever it is.%0a%0a#Miners signature (Msig) - one who found the Props signs the entire "block" (the transaction and everything they added to it)%0a%0aThis miner can provide a proof of semiprime can be done on any transaction of any size for the same cost.  Solve a 396 bit (or higher) challenge and you get to pick where the 2 bonds (prior art transactions) are directed.%0a%0aNow another miner can also do the same exact challenge and add the same transaction to the lattice however the challenge has to be harder, say a 400 bit mumber instead of 396.  This means multiple miners can mine the same transactions, they are all in the lattice but since each transaction is a non-reversible change (since by definition each address can only hold 1 bit, no more no less, once it sends its bit it can never recieve another, its worn out.  this solves the double spending problem.  Each address is one and done.  It either doesn't exist, holds a bit, or is spent.  So a transaction from one specific address to another can only ever happen once and never be reversed.  We solve double spending to not allow any address to make more than one transaction ever.  And we achieve this by allowing infinite addresses.  That also gives privacy.%0a----%0a!!!Node settings%0a%0a#Max transaction size of transactions you save (not everyone has to save every transaction). Set to 0 for no pruning.%0a%0a#Minimum factored number bitlength you will accept (I would suggest 120 (396 bits) digits as of now) this should be increased over time, but not too fast as to create orphans of old transactions.%0a%0a!!!Node considerations%0a%0aThe actionlattice can be thought of like a database where each transaction is a new line.  Just like a blockchain, an actionlattice is append-only.%0a%0aHowever nodes can prune their lattice to only include transactions under a certain size or that have a sufficient proof of semiprime.  Say the Posi starts at 120 digit number factorization, when the node moves to require 130 digit all the 120 digit proven transactions need to be remined at 130 digit proof.  Every re-mining to increase the proof level produces a new cip, and a higher value cip in fact.%0a%0aSince you don't want the transactions your transaction is connected to to dissapear due to node pruning, you are going to want your transaction to be connected to small transactions that have a high proof level.  Transactions closest to the surface will have the most up-to-date proof level so are good candidates to connect to.  One nice thing is that if the transaction size is acceptable to most of the nodes now, chances are it will continue to be in the future because as hard drives grow due to moores law, storage capacity increases and likely nodes will allow bigger transactions over time because they can and it supports the network.%0a!!Proof of Semiprime%0a%0aSee [[NatureVault/Digital Collectible Network#mine]]%0a%0aPrime factorization on optical (photonic) computers [[https://iopscience.iop.org/article/10.1143/JJAP.48.09LA02/meta|#]]%0a%0aQuantum computers would need to use shor's algorithm.%0a%0aCPU's are favored for challenges with over roughly 140 digits.%0a%0aGPU's can ECM up to around 140 digits.%0a%0aSNFS numbers should not be allowed [[https://www.mersenneforum.org/showthread.php?t=26852|#]]%0a!!Genesis [[#genesis]]%0a%0aThe genesis, called lattigenesis, requires 3 transactions (a trinity) to begin that cross reference (connect) to eachother.%0a%0aAttach:lattigenesis.png%0a%0a!!Attacks [[#attacks]]%0a%0a!!!Opsonization [[https://en.wikipedia.org/wiki/Antibody_opsonization|#]] AKA 99.9%25 attack hard fork%0a%0aA fully successful opsonization attack causes a destructive hardfork in the network.  But new [[#genesis|genesi]] can be created and rebuild the network if it happens.  These new genesi can later be reconnected together as the threat subsides.%0a%0aOpsonization in this context means cover the entire surface of the actionlattice with fraudulent transactions in order to force new transactions to confirm fraudulent ones.%0a%0aSurface area to volume is 3/R [[https://van.physics.illinois.edu/ask/listing/791|#]]  So surface area is directly proportional to volume.  This means that as the size of the actionlattice grows, so does the difficulty in performing the opsonization attack.%0a%0aThe reason this is nicknamed the "99.9%25" attack is because you would literally need to flood the lattice with enough transactions to literally cover the entire surface, except for 1 single transaction.  Since a new transaction needs 2 old transactions to connect, you would literally have to connect to all other transactions in the lattice except one in order to force new transactions to confirm the fradulent ones.  %0a%0aNow practically speaking you might get less rigorous miners to confirm some of your fradulent transactions if they aren't willing to check the validity of everything, but this should never happen, a miner should always check validity of the transactions it is connecting to, but some may decide not to, leading to the downfall of the network.  Miners not being rigorous would make them "bad" and a part of the attack.  "Good" miners will always check validity.  Only very few good miners are needed to nullify an attack and have the network recover.%0a%0aIf the 99.9%25 attack only achieves 99.8%25 for example (fudging numbers here for illustration) then new transactions can find the "hole" and connect only to the good transactions and this would create what amounts to a "genetic bottleneck" and basically would grow out through this opening and slowly move out of the prison created by the opsonization attack.%0a%0aEven in the case of a successful opsonization attack that totally nullifies the surface with fraudulent transactions, someone can create a new [[#genesis|genesis]] (hardfork) by creating 3 crosslinking transactions and all the old good transactions can be re-mined onto this new genesis.  Preferably many of these new genesi would be created so that the attacker would have to attack them all at once.%0a%0a!!!Tumor attack soft fork%0a%0aA tumor attack causes a benign softfork in the network.%0a%0aA tumor attack is similar to how a traditional 51%25 attack works, but it does not cause a hardfork like it does in a blockchain.  Basically a bad miner starts confirming their own transactions with more fraudulent transactions.  Basically nodes would need to figure this out and excise the tumor of fraudulent transactions (and any transactions connected to them above them) from their ledger.  This way the confirmations don't matter.  However if this attack is done quickly after a transaction, some nodes might be fooled into saying the transaction was confirmed if they were not checking validity.  Nodes must be checking validity before adding transactions to their ledger.%0a%0a!!!Node collusion%0a%0aAnyone can be a node.  The people who want to know if a transaction is confirmed would either rely on their own node, or a trusted node to see if their transaction was confirmed.  Eventually over time the nodes should reach consensus on the ledger, as everything can be verified and nodes that condone fraudulent transactions would be eliminated from the network of nodes.%0a%0a!!!Types of invalid transactions%0a%0a!!!!Sending cips that don't exist%0a%0aCips are all created in a cipbase transaction.  So when adding a new transaction to the ledger a node must validate that the cipbase transaction exists that gave a cip to the address that is now trying to send it.  Maintaining a UTXO may help make this process quicker.  It will take a long time to check if a huge transaction sending say 1000 cips all check out, and this is why nodes can rightfully limit the transaction size they are willing to save.%0a%0a!!!!Invalid signatures or proof of semiprime%0a%0aBasic stuff here, make sure the signatures match the addresses, make sure the proof of semiprime is valid, etc.%0a%0a!!!!Connected to an invalid transaction%0a%0aThere is a reason why each transaction can only be connected to two others and not more, because 2 gives good functionality while not overcomplicating how many transactions are checked.  Each node would want to check the validity of several layers down from the transaction to make sure the transactions it is confirming are valid.  If you go down 1 level you verify the two transactions it is confirming are valid. Two levels down you are verifying 4 transactions.  Three levels verifies 8 transactions and so on, each node needs to verify 2^n transactions for every new transaction, where n is the number of levels you go down.  Nodes might be set for n=7 default which is 128 transactions.  Lighter nodes can set this lower, but each node should be transparent of their setting so people connecting to them or merchants using their services can know how sure they are.  If any transaction is invalid, all transactions that are connected to them are also rendered invalid and all are removed from the ledger of the node and no longer exist.%0a!!Difficulty [[#diff]]%0a%0aMoore's law shows that every 5 more decimal digits you double the difficulty [[https://mersenneforum.org/showthread.php?t=19171&highlight=Moore|#]] [[https://mersenneforum.org/showthread.php?t=23078|#]] or 17-18 bits [[https://www.mersenneforum.org/showpost.php?p=606655&postcount=28|#]], which may happen every 3 years.  So the ease of factoring a 110 digit today will be what its like to mine a 115 digit number 3 years from now.%0a%0aThe nodes set the minimum difficulty they will accept.  This should be raised based on basically what is the minimum difficulty proof that is present in the network.  Since miners get rewarded to re-mine old transactions at higher difficulty, the network autocompensates for moore's law.  The result of this is old rewards would slowly loose value over time.  That could be quite fast, value might decline with moore's law for old cips. However you can keep mining fresh new cips with high value constantly.  [[NatureVault/Digital Collectible Network]] doesn't have the value loss problem though.  Neither does Fact0rn.%0a%0a%0a!!Notes [[#note]]%0a%0aStrong semiprimes called base-2 brilliant numbers [[https://www.mersenneforum.org/showpost.php?p=606643&postcount=25|#]]%0a%0aBitlattice tries to go 5D [[https://bitlattice.org/|#]] why??%0a%0aFactorn integer factorization proof of work [[https://github.com/FACT0RN/FACT0RN|#]] [[https://www.mersenneforum.org/showthread.php?t=27807|#]] [[https://www.coinbase.com/blog/fact0rn-blockchain-integer-factorization-as-proof-of-work-pow|#]]%0a%0aFactorn whitepaper [[https://fact0rn.io/FACT0RN_whitepaper.pdf|#]] takes them 200 semiprimes to find a valid semiprime (has a factor of exactly half the bitlength) about 1 in 20 for reasonably strong semiprimes.  This means my finding that 1 in 300 numbers is semiprime, 1 in 6,000 numbers is a strong (base-2 brilliant) semiprime.%0a%0aOriginal mersennes proposal [[https://www.mersenneforum.org/showthread.php?t=26659|#]]%0a%0aOriginal proposal to Monero [[https://www.reddit.com/r/Monero/comments/grms1c/a_holy_grail_pow_for_monero_outlined_gnfs/|#]]%0a%0aToppling the blockchain [[https://www.naturehacker.org/2021/01/toppling-blockchain-prime-factorization.html|#]]%0a%0aBitcoin vs DCC [[https://www.naturehacker.org/2021/01/bitcoin-vs-digital-collectible-currency.html|#]]%0a%0aMatrix vector multiplication on GPU [[https://www.mersenneforum.org/showthread.php?t=24862|#]] also [[oPoW]] uses this.%0a%0aECM depth on 150 digit number [[https://www.mersenneforum.org/showthread.php?t=26707|#]]%0a%0aResuming factoring [[https://www.mersenneforum.org/showthread.php?t=26664|#]]%0a%0aSimple explanation of GNFS [[https://www.mersenneforum.org/showthread.php?t=26984|#]] [[https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.219.2389&rep=rep1&type=pdf|#]]%0a%0aWhat length numbers do people ECM the most [[https://www.mersenneforum.org/showthread.php?t=25115|#]]%0a%0aLattice sieving on a GPU [[https://www.mersenneforum.org/showthread.php?t=27515|#]]
time=1664474586
author:1664474586=
diff:1664474586:1664474493:=154c154%0a%3c Factorn whitepaper [[https://fact0rn.io/FACT0RN_whitepaper.pdf|#]] takes them 200 semiprimes to find a valid semiprime (has a factor of exactly half the bitlength) about 1 in 20 for reasonably strong semiprimes.  This means my finding that 1 in 300 numbers is semiprime, 1 in 6,000 numbers is a strong (base-2 brilliant) semiprime.%0a---%0a> Factorn whitepaper [[https://fact0rn.io/FACT0RN_whitepaper.pdf|#]] takes them 200 semiprimes to find a valid semiprime (has a factor of exactly half the bitlength).  This means my finding that 1 in 300 numbers is semiprime, 1 in 60,000 numbers is a strong (base-2 brilliant) semiprime.%0a
author:1664474493=
diff:1664474493:1664474470:=
author:1664474470=
diff:1664474470:1664441127:=146c146%0a%3c !!Notes [[#note]]%0a---%0a> !!Notes%0a
author:1664441127=
diff:1664441127:1664440642:=154c154%0a%3c Factorn whitepaper [[https://fact0rn.io/FACT0RN_whitepaper.pdf|#]] takes them 200 semiprimes to find a valid semiprime (has a factor of exactly half the bitlength).  This means my finding that 1 in 300 numbers is semiprime, 1 in 60,000 numbers is a strong (base-2 brilliant) semiprime.%0a---%0a> Factorn whitepaper [[https://fact0rn.io/FACT0RN_whitepaper.pdf|#]]%0a
author:1664440642=
diff:1664440642:1664440517:=141c141%0a%3c Moore's law shows that every 5 more decimal digits you double the difficulty [[https://mersenneforum.org/showthread.php?t=19171&highlight=Moore|#]] [[https://mersenneforum.org/showthread.php?t=23078|#]] or 17-18 bits [[https://www.mersenneforum.org/showpost.php?p=606655&postcount=28|#]], which may happen every 3 years.  So the ease of factoring a 110 digit today will be what its like to mine a 115 digit number 3 years from now.%0a---%0a> Moore's law shows that every 5 more decimal digits you double the difficulty [[https://mersenneforum.org/showthread.php?t=19171&highlight=Moore|#]] [[https://mersenneforum.org/showthread.php?t=23078|#]], which may happen every 3 years.  So the ease of factoring a 110 digit today will be what its like to mine a 115 digit number 3 years from now.%0a
author:1664440517=
diff:1664440517:1664440103:=147,148d146%0a%3c %0a%3c Strong semiprimes called base-2 brilliant numbers [[https://www.mersenneforum.org/showpost.php?p=606643&postcount=25|#]]%0a
author:1664440103=
diff:1664440103:1664439987:=141c141%0a%3c Moore's law shows that every 5 more decimal digits you double the difficulty [[https://mersenneforum.org/showthread.php?t=19171&highlight=Moore|#]] [[https://mersenneforum.org/showthread.php?t=23078|#]], which may happen every 3 years.  So the ease of factoring a 110 digit today will be what its like to mine a 115 digit number 3 years from now.%0a---%0a> Moore's law shows that every 5 more decimal digits you double the difficulty, which may happen every 3 years.  So the ease of factoring a 110 digit today will be what its like to mine a 115 digit number 3 years from now.%0a
author:1664439987=
diff:1664439987:1664439826:=140,141d139%0a%3c %0a%3c Moore's law shows that every 5 more decimal digits you double the difficulty, which may happen every 3 years.  So the ease of factoring a 110 digit today will be what its like to mine a 115 digit number 3 years from now.%0a
author:1664439826=
diff:1664439826:1664433472:=139,143d138%0a%3c !!Difficulty [[#diff]]%0a%3c %0a%3c The nodes set the minimum difficulty they will accept.  This should be raised based on basically what is the minimum difficulty proof that is present in the network.  Since miners get rewarded to re-mine old transactions at higher difficulty, the network autocompensates for moore's law.  The result of this is old rewards would slowly loose value over time.  That could be quite fast, value might decline with moore's law for old cips. However you can keep mining fresh new cips with high value constantly.  [[NatureVault/Digital Collectible Network]] doesn't have the value loss problem though.  Neither does Fact0rn.%0a%3c %0a%3c %0a
author:1664433472=
diff:1664433472:1664426290:=150,153d149%0a%3c %0a%3c Toppling the blockchain [[https://www.naturehacker.org/2021/01/toppling-blockchain-prime-factorization.html|#]]%0a%3c %0a%3c Bitcoin vs DCC [[https://www.naturehacker.org/2021/01/bitcoin-vs-digital-collectible-currency.html|#]]%0a
author:1664426290=
diff:1664426290:1664420830:=140,141d139%0a%3c %0a%3c Bitlattice tries to go 5D [[https://bitlattice.org/|#]] why??%0a
author:1664420830=
diff:1664420830:1664420659:=121,124d120%0a%3c %0a%3c !!!Node collusion%0a%3c %0a%3c Anyone can be a node.  The people who want to know if a transaction is confirmed would either rely on their own node, or a trusted node to see if their transaction was confirmed.  Eventually over time the nodes should reach consensus on the ledger, as everything can be verified and nodes that condone fraudulent transactions would be eliminated from the network of nodes.%0a
author:1664420659=
diff:1664420659:1664420553:=134c134%0a%3c There is a reason why each transaction can only be connected to two others and not more, because 2 gives good functionality while not overcomplicating how many transactions are checked.  Each node would want to check the validity of several layers down from the transaction to make sure the transactions it is confirming are valid.  If you go down 1 level you verify the two transactions it is confirming are valid. Two levels down you are verifying 4 transactions.  Three levels verifies 8 transactions and so on, each node needs to verify 2^n transactions for every new transaction, where n is the number of levels you go down.  Nodes might be set for n=7 default which is 128 transactions.  Lighter nodes can set this lower, but each node should be transparent of their setting so people connecting to them or merchants using their services can know how sure they are.  If any transaction is invalid, all transactions that are connected to them are also rendered invalid and all are removed from the ledger of the node and no longer exist.%0a---%0a> There is a reason why each transaction can only be connected to two others and not more, because 2 gives good functionality while not overcomplicating how many transactions are checked.  Each node would want to check the validity of several layers down from the transaction to make sure the transactions it is confirming are valid.  If you go down 1 level you verify the two transactions it is confirming are valid. Two levels down you are verifying 4 transactions.  Three levels verifies 8 transactions and so on, each node needs to verify 2^n transactions for every new transaction, where n is the number of levels you go down.  Nodes might be set for n=7 default which is 128 transactions.  Lighter nodes can set this lower, but each node should be transparent of their setting so people connecting to them or merchants using their services can know how sure they are.%0a
author:1664420553=
diff:1664420553:1664420258:=1c1%0a%3c (:Summary:A lattice of individual cross-confirming transactions that can be mined offline as a replacement to a blockchain or blockDAG.  It scales to infinite transactions per second, is immune to traditional 51%25 [[#attacks|attacks]], can get initial confirmation within a few seconds, reward is proportional, CPU dominated, ASICs will never dominate, and also resists GPU and Quantum computer takeover while allowing them to mine.:)%0a---%0a> (:Summary:A lattice of individual cross-confirming transactions that can be mined offline as a replacement to a blockchain or blockDAG.  It scales to infinite transactions per second, is immune to traditional 51%25 attacks, can get initial confirmation within a few seconds, reward is proportional, CPU dominated, ASICs will never dominate, and also resists GPU and Quantum computer takeover while allowing them to mine.:)%0a
author:1664420258=
diff:1664420258:1664420171:=134c134%0a%3c There is a reason why each transaction can only be connected to two others and not more, because 2 gives good functionality while not overcomplicating how many transactions are checked.  Each node would want to check the validity of several layers down from the transaction to make sure the transactions it is confirming are valid.  If you go down 1 level you verify the two transactions it is confirming are valid. Two levels down you are verifying 4 transactions.  Three levels verifies 8 transactions and so on, each node needs to verify 2^n transactions for every new transaction, where n is the number of levels you go down.  Nodes might be set for n=7 default which is 128 transactions.  Lighter nodes can set this lower, but each node should be transparent of their setting so people connecting to them or merchants using their services can know how sure they are.%0a---%0a> There is a reason why each transaction can only be connected to two others and notmore, because 2 gives good functionality while not overcomplicating how many transactions are checked.  Each node would want to check the validity of several layers down from the transaction to make sure the transactions it is confirming are valid.  If you go down 1 level you verify the two transactions it is confirming are valid. Two levels down you are verifying 4 transactions.  Three levels verifies 8 transactions and so on, each node needs to verify 2^n transactions for every new transaction, where n is the number of levels you go down.  Nodes might be set for n=7 default which is 128 transactions.  Lighter nodes can set this lower, but each node should be transparent of their setting so people connecting to them or merchants using their services can know how sure they are.%0a
author:1664420171=
diff:1664420171:1664419414:=120,134c120%0a%3c A tumor attack is similar to how a traditional 51%25 attack works, but it does not cause a hardfork like it does in a blockchain.  Basically a bad miner starts confirming their own transactions with more fraudulent transactions.  Basically nodes would need to figure this out and excise the tumor of fraudulent transactions (and any transactions connected to them above them) from their ledger.  This way the confirmations don't matter.  However if this attack is done quickly after a transaction, some nodes might be fooled into saying the transaction was confirmed if they were not checking validity.  Nodes must be checking validity before adding transactions to their ledger.%0a%3c %0a%3c !!!Types of invalid transactions%0a%3c %0a%3c !!!!Sending cips that don't exist%0a%3c %0a%3c Cips are all created in a cipbase transaction.  So when adding a new transaction to the ledger a node must validate that the cipbase transaction exists that gave a cip to the address that is now trying to send it.  Maintaining a UTXO may help make this process quicker.  It will take a long time to check if a huge transaction sending say 1000 cips all check out, and this is why nodes can rightfully limit the transaction size they are willing to save.%0a%3c %0a%3c !!!!Invalid signatures or proof of semiprime%0a%3c %0a%3c Basic stuff here, make sure the signatures match the addresses, make sure the proof of semiprime is valid, etc.%0a%3c %0a%3c !!!!Connected to an invalid transaction%0a%3c %0a%3c There is a reason why each transaction can only be connected to two others and notmore, because 2 gives good functionality while not overcomplicating how many transactions are checked.  Each node would want to check the validity of several layers down from the transaction to make sure the transactions it is confirming are valid.  If you go down 1 level you verify the two transactions it is confirming are valid. Two levels down you are verifying 4 transactions.  Three levels verifies 8 transactions and so on, each node needs to verify 2^n transactions for every new transaction, where n is the number of levels you go down.  Nodes might be set for n=7 default which is 128 transactions.  Lighter nodes can set this lower, but each node should be transparent of their setting so people connecting to them or merchants using their services can know how sure they are.%0a---%0a> A tumor attack is similar to how a traditional 51%25 attack works, but it does not cause a hardfork like it does in a blockchain.  Basically a bad miner starts confirming their own transactions with more fraudulent transactions.  Basically nodes would need to figure this out and excise the tumor of fraudulent transactions (and any transactions connected to them above them) from their ledger.  This way the confirmations don't matter.  However if done quickly after a transaction, some nodes might be fooled into saying the transaction was confirmed if they were not checking validity.  Nodes must be checking validity before adding transactions to their ledger.%0a
author:1664419414=
diff:1664419414:1664419391:=100c100%0a%3c !!!Opsonization [[https://en.wikipedia.org/wiki/Antibody_opsonization|#]] AKA 99.9%25 attack hard fork%0a---%0a> !!!Opsonization [[https://en.wikipedia.org/wiki/Antibody_opsonization|#]] AKA 99.9%25 attack%0a
author:1664419391=
diff:1664419391:1664418664:=102,103d101%0a%3c A fully successful opsonization attack causes a destructive hardfork in the network.  But new [[#genesis|genesi]] can be created and rebuild the network if it happens.  These new genesi can later be reconnected together as the threat subsides.%0a%3c %0a114,120c112,115%0a%3c Even in the case of a successful opsonization attack that totally nullifies the surface with fraudulent transactions, someone can create a new [[#genesis|genesis]] (hardfork) by creating 3 crosslinking transactions and all the old good transactions can be re-mined onto this new genesis.  Preferably many of these new genesi would be created so that the attacker would have to attack them all at once.%0a%3c %0a%3c !!!Tumor attack soft fork%0a%3c %0a%3c A tumor attack causes a benign softfork in the network.%0a%3c %0a%3c A tumor attack is similar to how a traditional 51%25 attack works, but it does not cause a hardfork like it does in a blockchain.  Basically a bad miner starts confirming their own transactions with more fraudulent transactions.  Basically nodes would need to figure this out and excise the tumor of fraudulent transactions (and any transactions connected to them above them) from their ledger.  This way the confirmations don't matter.  However if done quickly after a transaction, some nodes might be fooled into saying the transaction was confirmed if they were not checking validity.  Nodes must be checking validity before adding transactions to their ledger.%0a---%0a> Even in the case of a successful opsonization attack that totally nullifies the surface with fraudulent transactions, someone can create a new [[#genesis|genesis]] by creating 3 crosslinking transactions and all the old good transactions can be re-mined onto this new genesis.  Preferably many of these new genesi would be created so that the attacker would have to attack them all at once.%0a> %0a> %0a> %0a
author:1664418664=
diff:1664418664:1664418426:=108c108%0a%3c Now practically speaking you might get less rigorous miners to confirm some of your fradulent transactions if they aren't willing to check the validity of everything, but this should never happen, a miner should always check validity of the transactions it is connecting to, but some may decide not to, leading to the downfall of the network.  Miners not being rigorous would make them "bad" and a part of the attack.  "Good" miners will always check validity.  Only very few good miners are needed to nullify an attack and have the network recover.%0a---%0a> Now practically speaking you might get less rigorous miners to confirm some of your fradulent transactions if they aren't willing to check the validity of everything, but this should never happen, a miner should always check validity of the transactions it is connecting to, but some may decide not to, leading to the downfall of the network.%0a
author:1664418426=
diff:1664418426:1664418393:=98c98%0a%3c !!Attacks [[#attacks]]%0a---%0a> !!Attacks%0a
author:1664418393=
diff:1664418393:1664418355:=92c92%0a%3c !!Genesis [[#genesis]]%0a---%0a> !!Genesis%0a
author:1664418355=
diff:1664418355:1664418049:=104,105d103%0a%3c Surface area to volume is 3/R [[https://van.physics.illinois.edu/ask/listing/791|#]]  So surface area is directly proportional to volume.  This means that as the size of the actionlattice grows, so does the difficulty in performing the opsonization attack.%0a%3c %0a112c110%0a%3c Even in the case of a successful opsonization attack that totally nullifies the surface with fraudulent transactions, someone can create a new [[#genesis|genesis]] by creating 3 crosslinking transactions and all the old good transactions can be re-mined onto this new genesis.  Preferably many of these new genesi would be created so that the attacker would have to attack them all at once.%0a---%0a> Surface area to volume is 3/R [[https://van.physics.illinois.edu/ask/listing/791|#]]  So surface area is directly proportional to volume.  This means that as the size of the actionlattice grows, so does the difficulty in performing the opsonization attack.%0a
author:1664418049=
diff:1664418049:1664415831:=97,112d96%0a%3c %0a%3c !!Attacks%0a%3c %0a%3c !!!Opsonization [[https://en.wikipedia.org/wiki/Antibody_opsonization|#]] AKA 99.9%25 attack%0a%3c %0a%3c Opsonization in this context means cover the entire surface of the actionlattice with fraudulent transactions in order to force new transactions to confirm fraudulent ones.%0a%3c %0a%3c The reason this is nicknamed the "99.9%25" attack is because you would literally need to flood the lattice with enough transactions to literally cover the entire surface, except for 1 single transaction.  Since a new transaction needs 2 old transactions to connect, you would literally have to connect to all other transactions in the lattice except one in order to force new transactions to confirm the fradulent ones.  %0a%3c %0a%3c Now practically speaking you might get less rigorous miners to confirm some of your fradulent transactions if they aren't willing to check the validity of everything, but this should never happen, a miner should always check validity of the transactions it is connecting to, but some may decide not to, leading to the downfall of the network.%0a%3c %0a%3c If the 99.9%25 attack only achieves 99.8%25 for example (fudging numbers here for illustration) then new transactions can find the "hole" and connect only to the good transactions and this would create what amounts to a "genetic bottleneck" and basically would grow out through this opening and slowly move out of the prison created by the opsonization attack.%0a%3c %0a%3c Surface area to volume is 3/R [[https://van.physics.illinois.edu/ask/listing/791|#]]  So surface area is directly proportional to volume.  This means that as the size of the actionlattice grows, so does the difficulty in performing the opsonization attack.%0a%3c %0a%3c %0a
author:1664415831=
diff:1664415831:1664415728:=1c1%0a%3c (:Summary:A lattice of individual cross-confirming transactions that can be mined offline as a replacement to a blockchain or blockDAG.  It scales to infinite transactions per second, is immune to traditional 51%25 attacks, can get initial confirmation within a few seconds, reward is proportional, CPU dominated, ASICs will never dominate, and also resists GPU and Quantum computer takeover while allowing them to mine.:)%0a---%0a> (:Summary:A lattice of individual cross-confirming transactions that can be mined offline as a replacement to a blockchain or blockDAG.  It scales to infinite transactions per second, is immune to traditional 51%25 attacks, can get initial confirmation within a few seconds, reward is proportional, CPU dominated, ASICs will never be viable, and also resists GPU and Quantum computer takeover while allowing them to mine.:)%0a
author:1664415728=
diff:1664415728:1664415657:=15c15%0a%3c An actionlattice is a new method to create, order, and store transactions, prove work, confirm transaction validity, prevent double spending, maintain privacy, and issue rewards (cips).  It replaces the blockchain.%0a---%0a> An actionlattice is a new method to create, order, and store transactions, prove work, confirm transaction validity, prevent double spending, maintain privacy, and issue coins.  It replaces the blockchain.%0a
author:1664415657=
diff:1664415657:1664415578:=116,118c116%0a%3c What length numbers do people ECM the most [[https://www.mersenneforum.org/showthread.php?t=25115|#]]%0a%3c %0a%3c Lattice sieving on a GPU [[https://www.mersenneforum.org/showthread.php?t=27515|#]]%0a\ No newline at end of file%0a---%0a> What length numbers do people ECM the most [[https://www.mersenneforum.org/showthread.php?t=25115|#]]%0a\ No newline at end of file%0a
author:1664415578=
diff:1664415578:1664415486:=114,116c114%0a%3c Simple explanation of GNFS [[https://www.mersenneforum.org/showthread.php?t=26984|#]] [[https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.219.2389&rep=rep1&type=pdf|#]]%0a%3c %0a%3c What length numbers do people ECM the most [[https://www.mersenneforum.org/showthread.php?t=25115|#]]%0a\ No newline at end of file%0a---%0a> Simple explanation of GNFS [[https://www.mersenneforum.org/showthread.php?t=26984|#]] [[https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.219.2389&rep=rep1&type=pdf|#]]%0a\ No newline at end of file%0a
author:1664415486=
diff:1664415486:1664415410:=113,114d112%0a%3c %0a%3c Simple explanation of GNFS [[https://www.mersenneforum.org/showthread.php?t=26984|#]] [[https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.219.2389&rep=rep1&type=pdf|#]]  %0a\ No newline at end of file%0a
author:1664415410=
diff:1664415410:1664415320:=111,112d110%0a%3c %0a%3c Resuming factoring [[https://www.mersenneforum.org/showthread.php?t=26664|#]]%0a
author:1664415320=
diff:1664415320:1664415205:=109,110d108%0a%3c %0a%3c ECM depth on 150 digit number [[https://www.mersenneforum.org/showthread.php?t=26707|#]]%0a
author:1664415205=
diff:1664415205:1664414690:=107,108d106%0a%3c %0a%3c Matrix vector multiplication on GPU [[https://www.mersenneforum.org/showthread.php?t=24862|#]] also [[oPoW]] uses this.%0a
author:1664414690=
diff:1664414690:1664413208:=100,106c100%0a%3c Factorn integer factorization proof of work [[https://github.com/FACT0RN/FACT0RN|#]] [[https://www.mersenneforum.org/showthread.php?t=27807|#]] [[https://www.coinbase.com/blog/fact0rn-blockchain-integer-factorization-as-proof-of-work-pow|#]]%0a%3c %0a%3c Factorn whitepaper [[https://fact0rn.io/FACT0RN_whitepaper.pdf|#]]%0a%3c %0a%3c Original mersennes proposal [[https://www.mersenneforum.org/showthread.php?t=26659|#]]%0a%3c %0a%3c Original proposal to Monero [[https://www.reddit.com/r/Monero/comments/grms1c/a_holy_grail_pow_for_monero_outlined_gnfs/|#]]%0a---%0a> Factorn integer factorization proof of work [[https://github.com/FACT0RN/FACT0RN|#]] [[https://www.mersenneforum.org/showthread.php?t=27807|#]]%0a
author:1664413208=
diff:1664413208:1664413169:=1c1%0a%3c (:Summary:A lattice of individual cross-confirming transactions that can be mined offline as a replacement to a blockchain or blockDAG.  It scales to infinite transactions per second, is immune to traditional 51%25 attacks, can get initial confirmation within a few seconds, reward is proportional, CPU dominated, ASICs will never be viable, and also resists GPU and Quantum computer takeover while allowing them to mine.:)%0a---%0a> (:Summary:A lattice of individual cross-confirming transactions that can be mined offline as a replacement to a blockchain or blockDAG.  It scales to infinite transactions per second, is immune to 51%25 attacks, can get initial confirmation within a few seconds, reward is proportional, CPU dominated, ASICs will never be viable, and also resists GPU and Quantum computer takeover while allowing them to mine.:)%0a
author:1664413169=
diff:1664413169:1664413107:=1c1%0a%3c (:Summary:A lattice of individual cross-confirming transactions that can be mined offline as a replacement to a blockchain or blockDAG.  It scales to infinite transactions per second, is immune to 51%25 attacks, can get initial confirmation within a few seconds, reward is proportional, CPU dominated, ASICs will never be viable, and also resists GPU and Quantum computer takeover while allowing them to mine.:)%0a---%0a> (:Summary:A lattice of individual cross-confirming transactions that can be mined offline as a replacement to a blockchain or blockDAG.  It scales to infinite transactions per second, can get initial confirmation within a few seconds, reward is proportional, CPU dominated, ASICs will never be viable, and also resists GPU and Quantum computer takeover while allowing them to mine.:)%0a
author:1664413107=
diff:1664413107:1664410608:=10c10%0a%3c (:Archive:[[|Archive.is]], [[https://web.archive.org/web/20220929004452/https://www.naturevault.org/wiki/pmwiki.php/CryptoProjects/Actionlattice|Archive.org]],  [[https://web.archive.org/web/20220928204808/https://www.naturevault.org/wiki/pmwiki.php/CryptoProjects/Actionlattice|OLDArchive.org]]:)%0a---%0a> (:Archive:[[|Archive.is]], [[https://web.archive.org/web/20220928204808/https://www.naturevault.org/wiki/pmwiki.php/CryptoProjects/Actionlattice|Archive.org]]:)%0a
author:1664410608=
diff:1664410608:1664409396:=98,100d97%0a%3c !!Notes%0a%3c %0a%3c Factorn integer factorization proof of work [[https://github.com/FACT0RN/FACT0RN|#]] [[https://www.mersenneforum.org/showthread.php?t=27807|#]]%0a
author:1664409396=
diff:1664409396:1664409045:=35c35%0a%3c Each transaction contains public addresses and signatures for each of the cips being sent and the public addresses for each cip to be received to, a cipbase address where a new cip is created and given to, and a message field that an be used for iterating nonces and including messages.%0a---%0a> Each transaction contains public addresses and signatures for each of the bits being sent and the public addresses for each bit to be received to, a bitbase address where a new bit is created and given to, and a message field that an be used for iterating nonces and including messages.%0a
author:1664409045=
diff:1664409045:1664408783:=27,29c27,29%0a%3c All a cryptocurrency would need is an actionlattice.  Also a UTXO may be used, and will be helpful because of pruning.  The UTXO would simply carry a list of addresses with balance of 1 cip, and used addresses (that contain 0 cips) and these cannot be reused (this is done to maintain privacy).  That said UTXO omission could be a feature as it would mean transactions keep needing to be re-mined at current difficulty to not be purged (and effectively reversed).%0a%3c %0a%3c Each transaction is it's very own "block" and stands alone.  It can be broadcast with or without [[proof of semiprime]] [[Posi]].  If it is broadcast to the network with no proof, then a miner would need to activate and connect it wherever they want in the lattice (they will probably selfishly connect it to their own transactions to add confirmations).%0a---%0a> All a cryptocurrency would need is an actionlattice.  Also a UTXO is probably needed, and will be helpful because of pruning.  The UTXO would simply carry a list of addresses with balance of 1 bit, and used addresses (that contain 0 bits) and these cannot be reused (this is done to maintain privacy).  That said UTXO omission could be a feature as it would mean transactions keep need to be re-mined at current difficulty to not be purged (and effectively reversed).%0a> %0a> Each transaction is it's very own "block" and stands alone.  It can be broadcast with or without [[proof of semiprime]] [[Posi]].%0a
author:1664408783=
diff:1664408783:1664408499:=31,34c31,34%0a%3c Each transaction can send cips from one public key to another.  Each public key can hold only 1 cip.  Think of each cip as a "bit".  Each bit is immutable and cannot be split or added to.  Each bit (cip) has one public and private key.%0a%3c %0a%3c Mining any size transaction will require a certain amount of proof of semiprime, lets say a 20 minute target.  This is set by the nodes.  Perhaps a target of a few seconds can act as an initial confirmation and later a 20 min proof would be important to get all the nodes to accept it.%0a%3c %0a---%0a> Each transaction can send coins from one public key to another.  Each public key can hold only 1 cip.  Think of each coin as a "bit".  Each bit is immutable and cannot be split or added to.  Each bit has one public and private key.%0a> %0a> Mining any size transaction will require a certain amount of proof of sieve, lets say a 20 minute target.  This is set by the nodes.%0a> %0a36d35%0a%3c %0a
author:1664408499=
diff:1664408499:1664408367:=25c25%0a%3c In addition to setting the max transaction size they record, nodes also decide how much proof (bitlength) is needed to activate a transaction.  Some nodes might accept 120 digit numbers (397 bit - cip397's) , some 140 (463 bit - cip463's).  More proof can be added to the transaction later (basically any transaction can be re-mined just as long as it has a higher bitlevel proof than the original.  The original is kept and not deleted unless its proof level falls below the nodes requirement) which works because cips cannot be double spent by definition, addresses are throwaway and cannot hold more than 1 cip and once they send it they cannot recieve another cip ever again.  So "fast" nodes will accept small proofs and thus transactions can be initially confirmed quickly and then as more proof gets added slower nodes will recognize the transactions.  The more proof you the miner provides, the more valuable the "cip" the miner receives as a reward is.  Some merchants may accept only cip463's, and others may accept cip397's as well, but assign a lesser value to them.%0a---%0a> In addition to setting the max transaction size they record, nodes also decide how much proof (bitlength) is needed to activate a transaction.  Some nodes might accept 120 digit numbers (397 bit - cip397's) , some 140 (463 bit - cip463's).  More proof can be added to the transaction later (basically any transaction can be re-mined just as long as it has a higher bitlevel proof than the original.  The original is kept and not deleted unless its proof level falls below the nodes requirement) which works because cips cannot be double spent by definition, addresses are throwaway and cannot hold more than 1 cip and once they send it they cannot recieve another cip ever again.  So "fast" nodes will accept small proofs and thus transactions can be initially confirmed quickly and then as more proof gets added slower nodes will recognize the transactions.  The more proof you the miner provides, the more valuable the "cip" you receive as a reward is.  Some merchants may accept only cip463's, and others may accept cip397's as well, but assign a lesser value to them.%0a
author:1664408367=
diff:1664408367:1664408040:=25c25%0a%3c In addition to setting the max transaction size they record, nodes also decide how much proof (bitlength) is needed to activate a transaction.  Some nodes might accept 120 digit numbers (397 bit - cip397's) , some 140 (463 bit - cip463's).  More proof can be added to the transaction later (basically any transaction can be re-mined just as long as it has a higher bitlevel proof than the original.  The original is kept and not deleted unless its proof level falls below the nodes requirement) which works because cips cannot be double spent by definition, addresses are throwaway and cannot hold more than 1 cip and once they send it they cannot recieve another cip ever again.  So "fast" nodes will accept small proofs and thus transactions can be initially confirmed quickly and then as more proof gets added slower nodes will recognize the transactions.  The more proof you the miner provides, the more valuable the "cip" you receive as a reward is.  Some merchants may accept only cip463's, and others may accept cip397's as well, but assign a lesser value to them.%0a---%0a> In addition to setting the max transaction size they record, nodes also decide how much proof (bitlength) is needed to activate a transaction.  Some nodes might accept 120 digit numbers (397 bit - cip397's) , some 140 (463 bit - cip463's).  More proof can be added to the transaction later (basically any transaction can be re-mined just as long as it has a higher bitlevel proof than the original.  The original is kept and not deleted unless its proof level falls below the nodes requirement) which works because cips cannot be double spent by definition, addresses are throwaway and cannot hold more than 1 cip and once they send it they cannot recieve another cip ever again.  So "fast" nodes will accept small proofs and thus transactions can be initially confirmed quickly and then as more proof gets added slower nodes will recognize the transactions.  The more proof you the miner provides, the more valuable the "cips" you receive as a reward are.  Some merchants may accept only cip463's, and others may accept cip397's as well, but assign a lesser value to them.%0a
author:1664408040=
diff:1664408040:1664407927:=17c17%0a%3c The smallest (and only) unit of account is the cip (dust). The name is a convolution of "bit", "semiprime" maybe "cipher" or "sip".%0a---%0a> The smallest (and only) unit of account is the cip (dust). The name is a convolution of "bit", "semiprime" maybe "cipher"%0a
author:1664407927=
diff:1664407927:1664407815:=1c1%0a%3c (:Summary:A lattice of individual cross-confirming transactions that can be mined offline as a replacement to a blockchain or blockDAG.  It scales to infinite transactions per second, can get initial confirmation within a few seconds, reward is proportional, CPU dominated, ASICs will never be viable, and also resists GPU and Quantum computer takeover while allowing them to mine.:)%0a---%0a> (:Summary:A lattice of individual transactions that can be mined offline as a replacement to a blockchain or blockDAG.  It scales to infinite transactions per second, can get initial confirmation within a few seconds, reward is proportional, CPU dominated, ASICs will never be viable, and also resists GPU and Quantum computer takeover while allowing them to mine.:)%0a
author:1664407815=
diff:1664407815:1664407453:=48c48%0a%3c ----%0a---%0a> -----%0a
author:1664407453=
diff:1664407453:1664407253:=76,77d75%0a%3c %0a%3c Since you don't want the transactions your transaction is connected to to dissapear due to node pruning, you are going to want your transaction to be connected to small transactions that have a high proof level.  Transactions closest to the surface will have the most up-to-date proof level so are good candidates to connect to.  One nice thing is that if the transaction size is acceptable to most of the nodes now, chances are it will continue to be in the future because as hard drives grow due to moores law, storage capacity increases and likely nodes will allow bigger transactions over time because they can and it supports the network.%0a
author:1664407253=
diff:1664407253:1664407088:=75d74%0a%3c However nodes can prune their lattice to only include transactions under a certain size or that have a sufficient proof of semiprime.  Say the Posi starts at 120 digit number factorization, when the node moves to require 130 digit all the 120 digit proven transactions need to be remined at 130 digit proof.  Every re-mining to increase the proof level produces a new cip, and a higher value cip in fact.%0a
author:1664407088=
diff:1664407088:1664406895:=70,73d69%0a%3c %0a%3c !!!Node considerations%0a%3c %0a%3c The actionlattice can be thought of like a database where each transaction is a new line.  Just like a blockchain, an actionlattice is append-only.%0a
author:1664406895=
diff:1664406895:1664406622:=82,83d81%0a%3c %0a%3c SNFS numbers should not be allowed [[https://www.mersenneforum.org/showthread.php?t=26852|#]]%0a
author:1664406622=
diff:1664406622:1664405961:=75,81d74%0a%3c Prime factorization on optical (photonic) computers [[https://iopscience.iop.org/article/10.1143/JJAP.48.09LA02/meta|#]]%0a%3c %0a%3c Quantum computers would need to use shor's algorithm.%0a%3c %0a%3c CPU's are favored for challenges with over roughly 140 digits.%0a%3c %0a%3c GPU's can ECM up to around 140 digits.%0a
author:1664405961=
diff:1664405961:1664405871:=77c77%0a%3c The genesis, called lattigenesis, requires 3 transactions (a trinity) to begin that cross reference (connect) to eachother.%0a---%0a> The genesis, called lattigenesis, requires 3 transactions (a trinity) to begin that cross connect to eachother.%0a
author:1664405871=
diff:1664405871:1664405614:=77c77%0a%3c The genesis, called lattigenesis, requires 3 transactions (a trinity) to begin that cross connect to eachother.%0a---%0a> The genesis, called lattigenesis, requires 3 transactions to begin that cross connect to eachother.%0a
author:1664405614=
diff:1664405614:1664405271:=1c1%0a%3c (:Summary:A lattice of individual transactions that can be mined offline as a replacement to a blockchain or blockDAG.  It scales to infinite transactions per second, can get initial confirmation within a few seconds, reward is proportional, CPU dominated, ASICs will never be viable, and also resists GPU and Quantum computer takeover while allowing them to mine.:)%0a---%0a> (:Summary:A lattice of individual transactions that can be mined offline as a replacement to a blockchain or blockDAG:)%0a
author:1664405271=
diff:1664405271:1664404483:=1c1%0a%3c (:Summary:A lattice of individual transactions that can be mined offline as a replacement to a blockchain or blockDAG:)%0a---%0a> (:Summary:A Lattice of individually mined transactions as a replacement to a blockchain or blockDAG:)%0a
author:1664404483=
diff:1664404483:1664404267:=27c27%0a%3c All a cryptocurrency would need is an actionlattice.  Also a UTXO is probably needed, and will be helpful because of pruning.  The UTXO would simply carry a list of addresses with balance of 1 bit, and used addresses (that contain 0 bits) and these cannot be reused (this is done to maintain privacy).  That said UTXO omission could be a feature as it would mean transactions keep need to be re-mined at current difficulty to not be purged (and effectively reversed).%0a---%0a> All a cryptocurrency would need is an actionlattice.  Also a UTXO is probably needed, and will be helpful because of pruning.  The UTXO would simply carry a list of addresses with balance of 1 bit, and used addresses (that contain 0 bits) and these cannot be reused (this is done to maintain privacy).%0a
author:1664404267=
diff:1664404267:1664404143:=76,77d75%0a%3c %0a%3c The genesis, called lattigenesis, requires 3 transactions to begin that cross connect to eachother.%0a
author:1664404143=
diff:1664404143:1664404094:=19c19%0a%3c Every transaction is free to propose, and then a miner (or you - if you mine your own tx) gets paid with a reward cip if they "activate" the proposed transaction using proof of semiprime ([[Posi]]) and point (connect) it to two other transactions that they validate and vouch for, preferably these two other transactions are near the "surface" but whose cip genesis is deep below the surface.  Next, other new activated transactions will point (connect) to yours which "confirms" yours.  Some factors that will help decide whether they confirm yours or not is if it fits in the majority of nodes "max transaction size", and if it is near the surface but the cip genesis is deep from the surface.  The surface is just the layer of unconfirmed transactions on the edge of the lattice.%0a---%0a> Every transaction is free to propose and a miner (or you - if you mine your own tx) gets paid with a reward cip if they "activate" the proposed transaction using proof of semiprime ([[Posi]]) and point (connect) it to two other transactions that they validate and vouch for, preferably these two other transactions are near the "surface" but whose cip genesis is deep below the surface.  Next, other new activated transactions will point (connect) to yours which "confirms" yours.  Some factors that will help decide whether they confirm yours or not is if it fits in the majority of nodes "max transaction size", and if it is near the surface but the cip genesis is deep from the surface.  The surface is just the layer of unconfirmed transactions on the edge of the lattice.%0a
author:1664404094=
diff:1664404094:1664399064:=17c17%0a%3c The smallest (and only) unit of account is the cip (dust). The name is a convolution of "bit", "semiprime" maybe "cipher"%0a---%0a> The smallest (and only) unit is the cip (dust). The name is a convolution of "bit", "semiprime" maybe "cipher"%0a
author:1664399064=
diff:1664399064:1664398112:=74,77d73%0a%3c %0a%3c !!Genesis%0a%3c %0a%3c Attach:lattigenesis.png%0a
author:1664398112=
diff:1664398112:1664397982:=10c10%0a%3c (:Archive:[[|Archive.is]], [[https://web.archive.org/web/20220928204808/https://www.naturevault.org/wiki/pmwiki.php/CryptoProjects/Actionlattice|Archive.org]]:)%0a---%0a> (:Archive:[[|Archive.is]], [[|Archive.org]]:)%0a
author:1664397982=
diff:1664397982:1664396128:=25c25%0a%3c In addition to setting the max transaction size they record, nodes also decide how much proof (bitlength) is needed to activate a transaction.  Some nodes might accept 120 digit numbers (397 bit - cip397's) , some 140 (463 bit - cip463's).  More proof can be added to the transaction later (basically any transaction can be re-mined just as long as it has a higher bitlevel proof than the original.  The original is kept and not deleted unless its proof level falls below the nodes requirement) which works because cips cannot be double spent by definition, addresses are throwaway and cannot hold more than 1 cip and once they send it they cannot recieve another cip ever again.  So "fast" nodes will accept small proofs and thus transactions can be initially confirmed quickly and then as more proof gets added slower nodes will recognize the transactions.  The more proof you the miner provides, the more valuable the "cips" you receive as a reward are.  Some merchants may accept only cip463's, and others may accept cip397's as well, but assign a lesser value to them.%0a---%0a> In addition to setting the max transaction size they record, nodes also decide how much proof (bitlength) is needed to activate a transaction.  Some nodes might accept 120 digit numbers (397 bit - cip397's) , some 140 (463 bit - cip463's).  More proof can be added to the transaction later.  So "fast" nodes will accept small proofs and thus transactions can be initially confirmed quickly and then as more proof gets added slower nodes will recognize the transactions.  The more proof you the miner provides, the more valuable the "cips" you receive as a reward are.  Some merchants may accept only cip463's, and others may accept cip397's as well, but assign a lesser value to them.%0a
author:1664396128=
diff:1664396128:1664396099:=15c15%0a%3c An actionlattice is a new method to create, order, and store transactions, prove work, confirm transaction validity, prevent double spending, maintain privacy, and issue coins.  It replaces the blockchain.%0a---%0a> An actionlattice is a new method to create, order, and store transactions, prove work, confirm transaction validity, prevent double spending, maintain privacy, and issues coins.  It replaces the blockchain.%0a
author:1664396099=
diff:1664396099:1664396056:=36,38c36,38%0a%3c !!Process%0a%3c !!!Transactor side%0a%3c %0a---%0a> %0a> Transactor side%0a> %0a49,50c49,50%0a%3c !!!Miner's side%0a%3c %0a---%0a> Miner's side%0a> %0a65c65%0a%3c !!!Node settings%0a---%0a> Node settings%0a
author:1664396056=
diff:1664396056:1664395420:=73c73%0a%3c See [[NatureVault/Digital Collectible Network#mine]]%0a---%0a> [[NatureVault/Digital Collectible Network#mine]]%0a
author:1664395420=
diff:1664395420:1664394846:=70,73d69%0a%3c %0a%3c !!Proof of Semiprime%0a%3c %0a%3c [[NatureVault/Digital Collectible Network#mine]]%0a
author:1664394846=
diff:1664394846:1664394821:=17c17%0a%3c The smallest (and only) unit is the cip (dust). The name is a convolution of "bit", "semiprime" maybe "cipher"%0a---%0a> The smallest (and only) unit is the cip. The name is a convolution of "bit", "semiprime" maybe "cipher"%0a
author:1664394821=
diff:1664394821:1664394776:=2c2%0a%3c (:Published:9/28/2022:)%0a---%0a> (:Published:9/27/2022:)%0a
author:1664394776=
diff:1664394776:1664394653:=1,2c1,3%0a%3c (:Summary:A Lattice of individually mined transactions as a replacement to a blockchain or blockDAG:)%0a%3c (:Published:9/27/2022:)%0a---%0a> (:nogroupheader:)%0a> (:Summary::)%0a> (:Published::)%0a
author:1664394653=
diff:1664394653:1664394436:=18c18%0a%3c The smallest (and only) unit is the cip. The name is a convolution of "bit", "semiprime" maybe "cipher"%0a---%0a> The smallest (and only) unit is the cip. A convolution of "bit", "semiprime" maybe "cipher"%0a
author:1664394436=
diff:1664394436:1664392769:=24,25d23%0a%3c Attach:actionlattice.png%0a%3c %0a32c30%0a%3c Each transaction can send coins from one public key to another.  Each public key can hold only 1 cip.  Think of each coin as a "bit".  Each bit is immutable and cannot be split or added to.  Each bit has one public and private key.%0a---%0a> Each transaction can send coins from one public key to another.  Each public key can hold only 1 coin.  Think of each coin as a "bit".  Each bit is immutable and cannot be split or added to.  Each bit has one public and private key.%0a
author:1664392769=
diff:1664392769:1664383639:=18c18%0a%3c The smallest (and only) unit is the cip. A convolution of "bit", "semiprime" maybe "cipher"%0a---%0a> The smallest (and only) unit is the cip.%0a
author:1664383639=
diff:1664383639:1664383086:=18,21c18,19%0a%3c The smallest (and only) unit is the cip.%0a%3c %0a%3c Every transaction is free to propose and a miner (or you - if you mine your own tx) gets paid with a reward cip if they "activate" the proposed transaction using proof of semiprime ([[Posi]]) and point (connect) it to two other transactions that they validate and vouch for, preferably these two other transactions are near the "surface" but whose cip genesis is deep below the surface.  Next, other new activated transactions will point (connect) to yours which "confirms" yours.  Some factors that will help decide whether they confirm yours or not is if it fits in the majority of nodes "max transaction size", and if it is near the surface but the cip genesis is deep from the surface.  The surface is just the layer of unconfirmed transactions on the edge of the lattice.%0a%3c %0a---%0a> Every transaction is free to propose and a miner (or you - if you mine your own tx) gets paid with reward if they "activate" the proposed transaction using proof of semiprime ([[Posi]]) and point (connect) it to two other transactions that they validate and vouch for, preferably these two other transactions are near the "surface".  Next, other new activated transactions will point (connect) to yours which "confirms" yours.  Some factors that will help decide whether they confirm yours or not is if it fits in the majority of nodes "max transaction size", and if it is near the surface.  The surface is just the layer of unconfirmed transactions on the edge of the lattice.%0a> %0a24c22%0a%3c In addition to setting the max transaction size they record, nodes also decide how much proof (bitlength) is needed to activate a transaction.  Some nodes might accept 120 digit numbers (397 bit - cip397's) , some 140 (463 bit - cip463's).  More proof can be added to the transaction later.  So "fast" nodes will accept small proofs and thus transactions can be initially confirmed quickly and then as more proof gets added slower nodes will recognize the transactions.  The more proof you the miner provides, the more valuable the "cips" you receive as a reward are.  Some merchants may accept only cip463's, and others may accept cip397's as well, but assign a lesser value to them.%0a---%0a> In addition to setting the max transaction size they record, nodes also decide how much proof (bitlength) is needed to activate a transaction.  Some nodes might accept 120 digit numbers (397bits) , some 140 (463bits).  More proof can be added to the transaction later.  So "fast" nodes will accept small proofs and thus transactions can be initially confirmed quickly and then as more proof gets added slower nodes will recognize the transactions.  The more proof you the miner provides, the more valuable the "bits" you receive as a reward are.  Some merchants may accept only 463bits, and others may accept 397bits as well, but assign a lesser value to them.%0a
author:1664383086=
diff:1664383086:1664383028:=18c18%0a%3c Every transaction is free to propose and a miner (or you - if you mine your own tx) gets paid with reward if they "activate" the proposed transaction using proof of semiprime ([[Posi]]) and point (connect) it to two other transactions that they validate and vouch for, preferably these two other transactions are near the "surface".  Next, other new activated transactions will point (connect) to yours which "confirms" yours.  Some factors that will help decide whether they confirm yours or not is if it fits in the majority of nodes "max transaction size", and if it is near the surface.  The surface is just the layer of unconfirmed transactions on the edge of the lattice.%0a---%0a> Every transaction is free and a miner (or you - if you mine your own tx) gets paid with reward if they "activate" it using proof of semiprime ([[Posi]]) and point (connect) it to two other transactions that they validate and vouch for, preferably these two other transactions are near the "surface".  Next, other new activated transactions will point (connect) to yours which "confirms" yours.  Some factors that will help decide whether they confirm yours or not is if it fits in the majority of nodes "max transaction size", and if it is near the surface.  The surface is just the layer of unconfirmed transactions on the edge of the lattice.%0a
author:1664383028=
diff:1664383028:1664382749:=19,20d18%0a%3c %0a%3c The mining reward for activating a transaction would mature by whether your transaction is confirmed by others linking their transactions to yours.  Some consensus on how "well connected" your transaction needs to be (how deep from the surface) in order for your mining reward to be valid.  I suppose you can try to spend them immediately and it is up to each miner whether they build on a transaction whose genesis isn't deep from the surface.  I suppose it would take a while for your spending transaction to be confirmed before miners feel it is valid.%0a
author:1664382749=
diff:1664382749:1664382686:=16c16%0a%3c An actionlattice is a new method to create, order, and store transactions, prove work, confirm transaction validity, prevent double spending, maintain privacy, and issues coins.  It replaces the blockchain.%0a---%0a> An actionlattice is a new method to create, order, and store transactions, prove work, confirm transaction validity, prevent double spending, maintain privacy, and issues coins.%0a
author:1664382686=
diff:1664382686:1664382447:=18,20c18,20%0a%3c Every transaction is free and a miner (or you - if you mine your own tx) gets paid with reward if they "activate" it using proof of semiprime ([[Posi]]) and point (connect) it to two other transactions that they validate and vouch for, preferably these two other transactions are near the "surface".  Next, other new activated transactions will point (connect) to yours which "confirms" yours.  Some factors that will help decide whether they confirm yours or not is if it fits in the majority of nodes "max transaction size", and if it is near the surface.  The surface is just the layer of unconfirmed transactions on the edge of the lattice.%0a%3c %0a%3c In addition to setting the max transaction size they record, nodes also decide how much proof (bitlength) is needed to activate a transaction.  Some nodes might accept 120 digit numbers (397bits) , some 140 (463bits).  More proof can be added to the transaction later.  So "fast" nodes will accept small proofs and thus transactions can be initially confirmed quickly and then as more proof gets added slower nodes will recognize the transactions.  The more proof you the miner provides, the more valuable the "bits" you receive as a reward are.  Some merchants may accept only 463bits, and others may accept 397bits as well, but assign a lesser value to them.%0a---%0a> Every transaction is free and a miner (or you - if you mine your own tx) gets paid with reward if they "activate" it using proof of semiprime ([[Posi]]) and connect it to two other transactions that they validate, preferably these two other transactions are near the "surface".  Next more activated transactions will point to yours which "confirms" yours.  Some factors that will help decide whether they confirm yours or not is if it fits in the majority of nodes "max transaction size", and if it is near the surface.  The surface is just the layer of unconfirmed transactions.%0a> %0a> In addition to setting the max transaction size they record, nodes also decide how much proof (bitlength) is needed to activate a transaction.  Some nodes might accept 120 digit numbers (397bits) , some 140 (463bits).  More proof can be added to the transaction later.  So "fast" nodes will accept small proofs and thus transactions can be initially confirmed quickly and then as more proof gets added slower nodes will recognize the transactions.  The more proof you the miner provides, the more valuable the "bits" you receive as a reward are.%0a
author:1664382447=
diff:1664382447:1664382328:=18c18%0a%3c Every transaction is free and a miner (or you - if you mine your own tx) gets paid with reward if they "activate" it using proof of semiprime ([[Posi]]) and connect it to two other transactions that they validate, preferably these two other transactions are near the "surface".  Next more activated transactions will point to yours which "confirms" yours.  Some factors that will help decide whether they confirm yours or not is if it fits in the majority of nodes "max transaction size", and if it is near the surface.  The surface is just the layer of unconfirmed transactions.%0a---%0a> Every transaction is free and a miner (or you if you mine your own tx) gets paid with reward if they "activate" it using proof of semiprime ([[Posi]]) and connect it to two other transactions that they validate, preferably these two other transactions are near the "surface".  Next more activated transactions will point to yours which "confirms" yours.  Some factors that will help decide whether they confirm yours or not is if it fits in the majority of nodes "max transaction size", and if it is near the surface.  The surface is just the layer of unconfirmed transactions.%0a
author:1664382328=
diff:1664382328:1664381873:=20,22c20,22%0a%3c In addition to setting the max transaction size they record, nodes also decide how much proof (bitlength) is needed to activate a transaction.  Some nodes might accept 120 digit numbers (397bits) , some 140 (463bits).  More proof can be added to the transaction later.  So "fast" nodes will accept small proofs and thus transactions can be initially confirmed quickly and then as more proof gets added slower nodes will recognize the transactions.  The more proof you the miner provides, the more valuable the "bits" you receive as a reward are.%0a%3c %0a%3c All a cryptocurrency would need is an actionlattice.  Also a UTXO is probably needed, and will be helpful because of pruning.  The UTXO would simply carry a list of addresses with balance of 1 bit, and used addresses (that contain 0 bits) and these cannot be reused (this is done to maintain privacy).%0a---%0a> In addition to setting the max transaction size they record, nodes also decide how much proof (bitlength) is needed to activate a transaction.  Some nodes might accept 120 digit numbers, some 150.  More proof can be added to the transaction later.  So "fast" nodes will accept small proofs and thus transactions can be initially confirmed quickly and then as more proof gets added slower nodes will recognize the transactions.%0a> %0a> All a cryptocurrency would need is an actionlattice.  Also a UTXO is probably needed, and will be helpful because of pruning.  The UTXO would simply carry a list of addresses with balance of 1 bit, and used addresses (that contain 0 bits) which cannot be reused.%0a
author:1664381873=
diff:1664381873:1664381332:=18,20c18%0a%3c Every transaction is free and a miner (or you if you mine your own tx) gets paid with reward if they "activate" it using proof of semiprime ([[Posi]]) and connect it to two other transactions that they validate, preferably these two other transactions are near the "surface".  Next more activated transactions will point to yours which "confirms" yours.  Some factors that will help decide whether they confirm yours or not is if it fits in the majority of nodes "max transaction size", and if it is near the surface.  The surface is just the layer of unconfirmed transactions.%0a%3c %0a%3c In addition to setting the max transaction size they record, nodes also decide how much proof (bitlength) is needed to activate a transaction.  Some nodes might accept 120 digit numbers, some 150.  More proof can be added to the transaction later.  So "fast" nodes will accept small proofs and thus transactions can be initially confirmed quickly and then as more proof gets added slower nodes will recognize the transactions.%0a---%0a> Every transaction is free and a miner (or you if you mine your own tx) gets paid with reward if they "confirm" it using proof of semiprime ([[Posi]]).  One factor that will help decide whether they confirm it or not is if it fits in the majority of nodes "max transaction size". Nodes also decide how much proof (bitlength) is needed.  Some nodes might accept 120 digit numbers, some 150.  More proof can be added to the transaction later.%0a
author:1664381332=
diff:1664381332:1664381262:=16c16%0a%3c An actionlattice is a new method to create, order, and store transactions, prove work, confirm transaction validity, prevent double spending, maintain privacy, and issues coins.%0a---%0a> An actionlattice is a new method to create and store transactions, prove work, confirm transaction validity, prevent double spending, maintain privacy, and issues coins.%0a
author:1664381262=
diff:1664381262:1664380683:=14,15c14,15%0a%3c See also [[Blocklattice]], [[CollectBit]], [[NatureVault/Digital Collectible Network]], [[BlockDAG]], [[NatureVault/Solvum]], [[NatureVault/Quantum]], [[Dustyplasma]]%0a%3c %0a---%0a> See also [[Blocklattice]], [[CollectBit]], [[NatureVault/Digital Collectible Network]], [[BlockDAG]], [[NatureVault/Solvum]], [[NatureVault/Quantum]]%0a> %0a20,21c20,21%0a%3c All a cryptocurrency would need is an actionlattice.  Also a UTXO is probably needed, and will be helpful because of pruning.  The UTXO would simply carry a list of addresses with balance of 1 bit, and used addresses (that contain 0 bits) which cannot be reused.%0a%3c %0a---%0a> All a cryptocurrency would need is an actionlattice.  Even a UTXO is not needed, but may be helpful in the case of pruning.  The UTXO would simply carry a list of addresses with balance of 1 bit, and used addresses (that contain 0 bits) that cannot be reused.%0a> %0a23a24,25%0a> Each transaction "costs" a certain amount regardless of how many kilobytes large it is.%0a> %0a36c38%0a%3c #"Receiving Public Addresses" (RPA's) - One address for each bit being received.%0a---%0a> #"Recieving Public Addresses" (RPA's) - One address for each bit being received.%0a
author:1664380683=
diff:1664380683:1664380176:=18,20c18%0a%3c Every transaction is free and a miner (or you if you mine your own tx) gets paid with reward if they "confirm" it using proof of semiprime ([[Posi]]).  One factor that will help decide whether they confirm it or not is if it fits in the majority of nodes "max transaction size". Nodes also decide how much proof (bitlength) is needed.  Some nodes might accept 120 digit numbers, some 150.  More proof can be added to the transaction later.%0a%3c %0a%3c All a cryptocurrency would need is an actionlattice.  Even a UTXO is not needed, but may be helpful in the case of pruning.  The UTXO would simply carry a list of addresses with balance of 1 bit, and used addresses (that contain 0 bits) that cannot be reused.%0a---%0a> All a cryptocurrency would need is an actionlattice.  Even a UTXO is not needed.%0a
author:1664380176=
diff:1664380176:1664347653:=16c16%0a%3c An actionlattice is a new method to create and store transactions, prove work, confirm transaction validity, prevent double spending, maintain privacy, and issues coins.%0a---%0a> An actionlattice is a new method to create and store transactions, prove work, confirm transaction validity, maintains privacy, and issues coins.%0a
author:1664347653=
diff:1664347653:1664346484:=22,23c22,23%0a%3c Each transaction "costs" a certain amount regardless of how many kilobytes large it is.%0a%3c %0a---%0a> Each transaction "costs" a certain amount depending on how many kilobytes large it is.%0a> %0a26,27c26,27%0a%3c Mining any size transaction will require a certain amount of proof of sieve, lets say a 20 minute target.  This is set by the nodes.%0a%3c %0a---%0a> Mining a 10 kb transaction will require a certain amount of proof of sieve, lets say a 20 minute target. 20kb might require a 30 min target, etc.%0a> %0a32,33c32,33%0a%3c #"Sending Public Addresses" (SPA's) of each bit being sent%0a%3c %0a---%0a> #"Sending Public Addresses" (SPA's) of each bit bieng sent%0a> %0a36,37c36,37%0a%3c #"Recieving Public Addresses" (RPA's) - One address for each bit being received.%0a%3c %0a---%0a> #"Recieving Public Addresses" (RPA's) - One address for each bit being recieved.%0a> %0a57c57%0a%3c ----%0a---%0a> %0a
author:1664346484=
diff:1664346484:1664345413:=54,57c54,55%0a%3c This miner can provide a proof of semiprime can be done on any transaction of any size for the same cost.  Solve a 396 bit (or higher) challenge and you get to pick where the 2 bonds (prior art transactions) are directed.%0a%3c %0a%3c Now another miner can also do the same exact challenge and add the same transaction to the lattice however the challenge has to be harder, say a 400 bit mumber instead of 396.  This means multiple miners can mine the same transactions, they are all in the lattice but since each transaction is a non-reversible change (since by definition each address can only hold 1 bit, no more no less, once it sends its bit it can never recieve another, its worn out.  this solves the double spending problem.  Each address is one and done.  It either doesn't exist, holds a bit, or is spent.  So a transaction from one specific address to another can only ever happen once and never be reversed.  We solve double spending to not allow any address to make more than one transaction ever.  And we achieve this by allowing infinite addresses.  That also gives privacy.%0a%3c %0a---%0a> Now the proof of %0a> %0a60,62c58,60%0a%3c #Max transaction size of transactions you save (not everyone has to save every transaction). Set to 0 for no pruning.%0a%3c %0a%3c #Minimum factored number bitlength you will accept (I would suggest 120 (396 bits) digits as of now) this should be increased over time, but not too fast as to create orphans of old transactions.%0a---%0a> #Max transaction size of transactions you save (not everyone has to save every tranasaction). Set to 0 for no pruning.%0a> %0a> #Minimum factored number bitlength you will accept%0a
author:1664345413=
diff:1664345413:1664344787:=53,61d52%0a%3c %0a%3c Now the proof of %0a%3c %0a%3c Node settings%0a%3c %0a%3c #Max transaction size of transactions you save (not everyone has to save every tranasaction). Set to 0 for no pruning.%0a%3c %0a%3c #Minimum factored number bitlength you will accept%0a%3c %0a
author:1664344787=
diff:1664344787:1664344529:=20c20%0a%3c Each transaction is it's very own "block" and stands alone.  It can be broadcast with or without [[proof of semiprime]] [[Posi]].%0a---%0a> Each transaction is it's very own "block" and stands alone.  It can be broadcast with or without [[proof of sieve]] [[Posi]].%0a
author:1664344529=
diff:1664344529:1664344335:=30,31d29%0a%3c Transactor side%0a%3c %0a36,37c34,35%0a%3c #"Recieving Public Addresses" (RPA's) - One address for each bit being recieved.%0a%3c %0a---%0a> #"Recieving Public Addresses" (RPA's) - %0a> %0a41,42d38%0a%3c -----%0a%3c Miner's side%0a
author:1664344335=
diff:1664344335:1664343742:=34,35c34,35%0a%3c #"Recieving Public Addresses" (RPA's) - %0a%3c %0a---%0a> #"Recieving Public Addresses" (RPA's) - this includes the bitbase receiving address %0a> %0a38,48c38,42%0a%3c #Completed transaction signature - Signs over the whole transaction done by the sender.  This prevents man in the middle (MITM) attack.%0a%3c %0a%3c #Proof of Sieve (Posi) message - %0a%3c %0a%3c #Proof of Proven Sieve (Props) - number to factor, nonce, and 2 factors%0a%3c %0a%3c #Peer blocks - 2 peer blocks Msig within the last epoch that you confirm are correct (if you are wrong about their validity your transaction may become voided)%0a%3c %0a%3c #Bitbase address which is the Miners public address (MPA) where the bitbase is sent, 1 bit for 10 kb or whatever it is.%0a%3c %0a%3c #Miners signature (Msig) - one who found the Props signs the entire "block" (the transaction and everything they added to it)%0a---%0a> #Completed transaction signature - Done by the sender.  This prevents man in the middle (MITM) attack.%0a> %0a> #Proof of Sieve (Posi) message - this can be a nonce to iterate to find a viable proof.%0a> %0a> #Proof of Proven Sieve (Props)%0a\ No newline at end of file%0a
author:1664343742=
diff:1664343742:1664342583:=20,21c20,21%0a%3c Each transaction is it's very own "block" and stands alone.  It can be broadcast with or without [[proof of sieve]] [[Posi]].%0a%3c %0a---%0a> Each transaction is it's very own "block" and stands alone.  It can be broadcast with or without [[proof of sieve]] [[PoSi]].%0a> %0a26,42c26%0a%3c Mining a 10 kb transaction will require a certain amount of proof of sieve, lets say a 20 minute target. 20kb might require a 30 min target, etc.%0a%3c %0a%3c Each transaction contains public addresses and signatures for each of the bits being sent and the public addresses for each bit to be received to, a bitbase address where a new bit is created and given to, and a message field that an be used for iterating nonces and including messages.%0a%3c %0a%3c #"Sending Public Addresses" (SPA's) of each bit bieng sent%0a%3c %0a%3c #Signatures (proves private key ownership) for the addresses for each bit being sent%0a%3c %0a%3c #"Recieving Public Addresses" (RPA's) - this includes the bitbase receiving address %0a%3c %0a%3c #Internal Message (IM) which can be anything%0a%3c %0a%3c #Completed transaction signature - Done by the sender.  This prevents man in the middle (MITM) attack.%0a%3c %0a%3c #Proof of Sieve (Posi) message - this can be a nonce to iterate to find a viable proof.%0a%3c %0a%3c #Proof of Proven Sieve (Props)%0a\ No newline at end of file%0a---%0a> Mining a 1 kb transaction will require a certain amount of proof of sieve, lets say%0a\ No newline at end of file%0a
author:1664342583=
diff:1664342583:1664342371:=20,26c20%0a%3c Each transaction is it's very own "block" and stands alone.  It can be broadcast with or without [[proof of sieve]] [[PoSi]].%0a%3c %0a%3c Each transaction "costs" a certain amount depending on how many kilobytes large it is.%0a%3c %0a%3c Each transaction can send coins from one public key to another.  Each public key can hold only 1 coin.  Think of each coin as a "bit".  Each bit is immutable and cannot be split or added to.  Each bit has one public and private key.%0a%3c %0a%3c Mining a 1 kb transaction will require a certain amount of proof of sieve, lets say%0a\ No newline at end of file%0a---%0a> Each transaction is it's very own "block" and stands alone.  It can be broadcast with or without [[proof of sieve]] [[PoSi]].%0a\ No newline at end of file%0a
author:1664342371=
diff:1664342371:1664342334:=
author:1664342334=
diff:1664342334:1664341894:=18,20c18%0a%3c All a cryptocurrency would need is an actionlattice.  Even a UTXO is not needed.%0a%3c %0a%3c Each transaction is it's very own "block" and stands alone.  It can be broadcast with or without [[proof of sieve]] [[PoSi]].%0a\ No newline at end of file%0a---%0a> All a cryptocurrency would need is an actionlattice.  Even a UTXO is not needed.%0a\ No newline at end of file%0a
author:1664341894=
diff:1664341894:1664341693:=16,18c16%0a%3c An actionlattice is a new method to create and store transactions, prove work, confirm transaction validity, maintains privacy, and issues coins.%0a%3c %0a%3c All a cryptocurrency would need is an actionlattice.  Even a UTXO is not needed.%0a\ No newline at end of file%0a---%0a> An actionlattice is a new method to create and store transactions, prove work, confirm transaction validity, and issue coins.%0a\ No newline at end of file%0a
author:1664341693=
diff:1664341693:1664341680:=16c16%0a%3c An actionlattice is a new method to create and store transactions, prove work, confirm transaction validity, and issue coins.%0a\ No newline at end of file%0a---%0a> An Actionlattice is a new method to create and store transactions, prove work, confirm transaction validity, and issue coins.%0a\ No newline at end of file%0a
author:1664341680=
diff:1664341680:1664341652:=14c14%0a%3c See also [[Blocklattice]], [[CollectBit]], [[NatureVault/Digital Collectible Network]], [[BlockDAG]], [[NatureVault/Solvum]], [[NatureVault/Quantum]]%0a---%0a> See also [[Blocklattice]], [[CollectBit]], [[NatureVault/Digital Collectible Network]], [[BlockDAG]]%0a
author:1664341652=
diff:1664341652:1664341577:=14,16c14%0a%3c See also [[Blocklattice]], [[CollectBit]], [[NatureVault/Digital Collectible Network]], [[BlockDAG]]%0a%3c %0a%3c An Actionlattice is a new method to create and store transactions, prove work, confirm transaction validity, and issue coins.%0a\ No newline at end of file%0a---%0a> See also [[Blocklattice]], [[CollectBit]], [[NatureVault/Digital Collectible Network]], [[BlockDAG]]%0a\ No newline at end of file%0a
author:1664341577=
diff:1664341577:1664341553:=14c14%0a%3c See also [[Blocklattice]], [[CollectBit]], [[NatureVault/Digital Collectible Network]], [[BlockDAG]]%0a\ No newline at end of file%0a---%0a> See also [[Blocklattice]], [[CollectBit]], [[NatureVault/Digital Collectible Network]], [[%0a\ No newline at end of file%0a
author:1664341553=
diff:1664341553:1664341526:=14c14%0a%3c See also [[Blocklattice]], [[CollectBit]], [[NatureVault/Digital Collectible Network]], [[%0a\ No newline at end of file%0a---%0a> See also [[Blocklattice]], [[CollectBit]], [[NatureVault/Digital Collectible Network]]%0a\ No newline at end of file%0a
author:1664341526=
diff:1664341526:1664341422:=14c14%0a%3c See also [[Blocklattice]], [[CollectBit]], [[NatureVault/Digital Collectible Network]]%0a\ No newline at end of file%0a---%0a> See also [[Blocklattice]]%0a\ No newline at end of file%0a
author:1664341422=
diff:1664341422:1664341422:=1,14d0%0a%3c (:nogroupheader:)%0a%3c (:Summary::)%0a%3c (:Published::)%0a%3c (:Author:[[~GiverofMemory]]:)%0a%3c (:License:[[https://en.m.wikipedia.org/wiki/Res_communis|Site License]]:)%0a%3c (:Update::)%0a%3c (:Maintainer:[[~GiverofMemory]]:)%0a%3c (:Creator:[[]]:)%0a%3c (:Categories:[[!Cryptics]]:)%0a%3c (:Also:none:)%0a%3c (:Archive:[[|Archive.is]], [[|Archive.org]]:)%0a%3c (:Download:[[{$FullName}?action=print|URL]],[[https://www.web2pdfconvert.com/|PDF from URL]]:)%0a%3c %0a%3c See also [[Blocklattice]]%0a\ No newline at end of file%0a
