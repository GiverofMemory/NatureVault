version=pmwiki-2.2.133 ordered=1 urlencoded=1
agent=Mozilla/5.0 (Linux; Android 8.0.0; SAMSUNG-SM-G891A Build/R16NW) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.156 Mobile Safari/537.36
author=
charset=UTF-8
csum=Byzantine fault tolerance [[https://en.m.wikipedia.org/wiki/Byzantine_fault|#]]. 
ctime=1611105737
host=68.2.112.187
name=NatureVault.Chromaton
rev=585
targets=NatureVault.3DChromatonDisc,NatureVault.DigitalCollectibleNetwork,NatureVault.PhysicalErrorCorrection,NatureVault.ChromatonDisc,Category.Cryptics
text=(:include SkinsHeader:)%0a(:Summary:A QR Code alternative that is infinitely scale-able, open source, human readable, and compact:)%0a(:Published:1/19/2021:)%0a(:Author:[[~NatureHacker]]:)%0a(:License:[[https://en.m.wikipedia.org/wiki/Res_communis|Site License]]:)%0a(:Update:1/28/2021:)%0a(:Maintainer:[[~NatureHacker]]:)%0a(:Categories:[[!Cryptics]]:)%0a(:Also:[[Digital collectible network]], [[Chromaton disc]], [[3D chromaton disc]]:)%0a(:Archive:[[https://archive.vn/oMUtN|Archive.is]], [[https://web.archive.org/web/20210128172139/http://www.naturewiki.org/wiki/pmwiki.php/NatureWiki/Chromaton|Archive.org]]:)%0a(:Download:[[{$FullName}?action=print|URL]],[[https://www.web2pdfconvert.com/|PDF from URL]]:)%0a%0a%0a!!Overview%0aSee [[#v2|Version 2]] and also [[#v3|version 3]] for a more up to date version.%0a%0aSuper important that chromaton shall never be tied to an identity.  Chromaton must never be used to identify people or contain identifying information.  Chromaton must never be used to surveil or categorize people like those who have or have not done something.  Chromaton must always be anonymous and never tied to identity.%0a%0aChromaton is a free and open source visual code system similar to the patented QR (Quick Response) code.  Chromaton was natively designed to use six colors and is human readable.  Black and white are used for processing and do not constitute data.  The chromaton system is infinitely scalable in a fractal way.  Kilochromaton, Megachromaton, Gigachromaton, Terachromaton and more are all possible, the only limitation is the fidelity of the camera and printing/etching ability.%0a%0aChromaton "dots" can be any shape including circles or squares, hexagons are used here for placement and organization sake but any shape can be used.%0a%0aChromaton can be rotated any way desired, the processing marks will help the software to orient to count correctly.  Also chromaton can be stacked together with a forward bias, or backward bias when fitting them together like puzzle pieces.  Again this does not effect anything. In the following images a forward stacking bias is used.%0a%0aColors determined from complementary and primary colors [[https://www.ecgprod.com/everything-you-know-about-color-is-probably-wrong/|#]].  Using colors introduces new potential for errors as seen here [[http://www.doiserbia.nb.rs/img/doi/1820-0214/2014/1820-02141400054Q.pdf|#]].%0a%0aOur color wheel at the center of chromaton is not perfect for best contrast.  A better version is found in [[#mega|megachromaton]] [[https://www.ecgprod.com/everything-you-know-about-color-is-probably-wrong/|#]].%0a%0a!!!Name%0aThe name chromaton was originally intended for a cryptocurrency but finds a better use in data storage (which can also service cryptovalue).  From the beginning the name meant the smallest unit of color.  Here that fits as the chromaton is the smallest repeating unit and it contains color.  Also it so happens the data storage in chromaton is similar to data storage in chromatin in DNA.  This was not intended, neither the similarity of the name nor the DNA-like storage in the chromaton unit.  The chromaton unit was simply designed as a hexagonal spiral with black and white to break up the data for easier processing.  Even the fact that it scales infinitely was not realized until halfway through the designing.%0a%0a!!Chromaton[[#chromaton]]%0aChromaton contains 48 base-6 digits which is 120 bits.  This chromaton is the smallest repeating unit, and thus is like the "atom" of the chromaton code system.  Chromaton is only 11 units long and 90 total units, which is roughly half the size of the smallest QR code; version 1 which has 21x21 or 441 units.  In spite of this chromaton contains around 3/4 the data of a version 1 QR code while having only 20%25 of the units.[[https://www.qrcode.com/en/about/version.html|#]]%0a%0aThe purple hexagons are the data containing units.  Each purple hexagon can be one of the six colors seen in the center (the center colors used for color correction) thus giving base-6 encoding.%0a%0aAttach:chromaton.png%0a%0a!!!Chromaton reading[[#chromatonlabel]]%0a%0aThe data is read in a spiral starting towards the center and working outwards clockwise.  This makes it easily human decodable/readable which is imperative and is not accomplished with any other QR like code.%0aAttach:chromatonlabel.png%0a%0aIt helps that the data in any one region is a sampling of data from across the message, so that if one area is damaged then you don't have a total loss of say the beginning of the message.  Also the center of the chromaton contains no data, so it is difficult to damage the chromaton in a way that destroys most of the data, basically the outer edges would need to be destroyed all the way around the chromaton.%0a%0a!!!!Check bits%0a%0aError correction in biology [[http://www.ece.iit.edu/~biitcomm/research/references/Manish%2520K.%2520Gupta/The%2520Quest%2520for%2520Error%2520Correction%2520in%2520Biology%2520-%25202006.pdf|#]].  Easy to understand explanation of error detection and correction [[http://web.mit.edu/6.02/www/f2006/handouts/bits_ecc.pdf|#]]%0a%0aBit 13 is the Error Correction delineating bit.  If it has one of the 6 colors, then there is no error correction (and bit 13 is a data bit).  If it is white then there is 1 bit error correction, if it is black then there is 2 bit error correction.%0a%0aFor 1 bit errors a minimum of 6 check bits are required for data + check bits between 31 and 63 (we have 48 data + check bits which puts us at dead center in that range) [[https://www.chegg.com/homework-help/many-check-bits-needed-hamming-error-correction-code-used-de-chapter-5-problem-13p-solution-9780134102061-exc|#]] [[https://computing.dcu.ie/~humphrys/Notes/Networks/data.hamming.html|#]].%0a%0aFor 2 bit errors; 11 check bits would be required [[https://stackoverflow.com/questions/5631871/what-is-the-minimum-number-of-bits-needed-to-correct-all-2-bit-errors|#]].%0a%0aSee non-binary error correction [[https://sites.bu.edu/mark/files/2018/12/CDT-2018-5008-FINAL.pdf|#]] [[http://www.mth.msu.edu/~jhall/classes/codenotes/Hamming.pdf|#]] [[https://math.stackexchange.com/questions/379672/non-binary-hamming-codes|#]].%0a%0aTo use reed solomon you would need a prime power alphabet so we would need to choose either base 4, 5, 7, or 8 instead of base-6 [[https://en.m.wikipedia.org/wiki/Reed–Solomon_error_correction|#]]. If we chose base 5 we would probably omit blue since it is similar to black.%0a%0aSimplex codes for base-6 [[https://www.researchgate.net/publication/342464492_Quasi_Self-dual_Codes_over_Non-Unital_Rings_of_Order_Six|#]] [[https://www.researchgate.net/publication/247481215_Self-dual_codes_over_rings_and_the_Chinese_Remainder_Theorem|#]] [[https://www.researchgate.net/publication/260230094_On_Senary_Simplex_Codes|#]].%0a%0aPrime candidates for check bits are 2, 4, 6, 8, 10, 12.  This is ideal because there is a check bit on every chunk of data and also it makes the data bits (non check bits) follow a nice pattern of 6 on the inner ring, 12 on the mid ring, and 24 on the outer ring.  It is also nice that the majority of our data is found in the outer ring, and all the check bits are in the inner ring.  So it is unlikely that both are compromised.%0a%0aFor 2 bit error correction preferably bits 1-11 could be error correction and the 12th would be the first data hexagon.%0a%0aAttach:chromatoncheckbits.png%0a%0aSee also [[https://en.wikipedia.org/wiki/Error_correction_code|Error correction code]]%0a%0aOf course in kilo, mega, etc chromaton the error correction scales up so entire chromaton can be missing in kilochromaton for example and still be ok.%0a%0a!!!Chromaton example%0a\\%0aRed = 0\\%0aCyan = 1\\%0aYellow = 2\\%0aMagenta = 3\\%0aGreen = 4\\%0aBlue = 5\\%0a\\%0aAttach:chromatoncolor.png%0a%0aHere is an example chromaton that would be seen in the wild.  The data it encodes is:\\%0a\\%0aNative Base-6 (senary):505300514114023455100250211322031424243343234551 (48 digits)\\%0a\\%0aBase-2 (binary):1110100000011010010010111101001101100001100001101000010011011010010011111011101010111111101110110011000000100111110111100011 (124 digits)\\%0a\\%0aBase-10 (decimal):19282339541779226363068247068383542755 (38 digits)\\%0a\\%0aBase-16 (hex):E81A4BD3618684DA4FBABFBB3027DE3 (31 digits)\\%0a\\%0aBase-26:33B9OJEK8A63N9F6D7AOL9HIAH1 (27 digits)\\%0a\\%0aBase-26 (alpha):DDLJYTOUIKGDXJPGNHKYVJRSKRB (27 digits)\\%0a%0a%0a!!Encryption%0aEncryption would be done on the data before encoding into chromaton.  Therefore Chromaton can be encrypted and only decrypted by the intended recipient if desired.%0a%0a!!Dichrome%0aDichrome contains 2 chromaton and thus has 2x48 (96 digits) base-6 or 2x120 (240 digits) bits. This is a bit less than a version 2 QR code.%0aAttach:dichrome.png%0a%0a%0a!!Trichrome%0aTrichrome contains 3 chromaton which is 144 base-6 digits or 360 binary digits (bits). This capacity is between version 2 and 3 QR code.%0aAttach:trichrome.png%0aIt is read starting at the top and going clockwise.%0a%0aTrichrome can encode for a private key which is handy for transferring cryptocollectibles [[https://www.dummies.com/software/other-software/bitcoin-public-private-keys/|#]].  It appears that base-58 keys are 51 units long.  Base-6 keys should be 99 units.%0a%0a!!Tetrachrome%0aTetrachrome contains four chromaton and thus has 4x48 (192 digits) base-6 or 4x120 (480 digits) bits. This is a bit more than a version 3 QR code.%0aAttach:tetrachrome.png%0a%0a!!Pentachrome%0aPentachrome contains six chromaton and thus has 5x48 (240 digits) base-6 or 5x120 (600 digits) bits. This is a bit less than a version 4 QR code.%0aAttach:pentachrome.png%0aPentachrome can encode for 2 private keys.%0a!!Hexachrome%0aHexachrome contains six chromaton and thus has 6x48 (288 digits) base-6 or 6x120 (720 digits) bits.  This is as bit more than a version 4 QR code.%0aAttach:hexachrome.png%0a%0a%0a!!Chroma%0aChroma is 7 chromaton and thus contains 336 base-6 digits or 840 bits, roughly equivalent to a version 5 QR code.%0aAttach:chroma.png%0aIt is read starting at the top and going clockwise, with the center the last.%0a%0aChroma can encode for 3 private keys.%0a!!Nonachrome%0aNonachrome is nine chromaton and thus has 9x48 (432) base-6 digits or 9x120 (1,080) binary digits.  This is similar to a version 6 QR code.%0aAttach:nonachrome.png%0aNonachrome can encode for 4 private keys.%0a!!Monochroma%0aMonochroma contains 12 chromaton and thus contains 12x48 (576) base-6 or 12x120 (1,400) binary bits.  This is similar to a version 8 QR code.%0aAttach:monochroma.png%0aMonochroma can encode for 5 private keys.%0a!!Dichroma%0aDichroma contains 18 chromaton and thus contains  18x48 (864) base-6 or 18x120 (2,160) binary bits.  This is similar to a version 10 QR code.%0aAttach:dichroma.png%0aDichroma can encode for 8 private keys.%0a!!Trichroma%0aTrichroma contains 30 chromaton and thus contains 30x48 (1,440) base-6 or 30x120 (3,600) binary bits.  This is similar to a version 14 QR code.%0aAttach:trichroma.png%0aTrichroma can encode 14 private keys.%0a!!Kilochromaton[[#kilochromaton]]%0aKilochromaton contain 48 chromaton and thus contains 2,304 base-6 digits or 5,760 bits which is comparable to a version 18 QR code.  Kilochromaton contains 90x90 = 8,100 modules whereas the version 18 QR contains 89x89 or 7,921 modules.  Even though the data capacity per unit has now decreased from QR code, it is expected to be much more robust and faster reading than QR as there is much more empty space in chromaton compared to QR.%0aAttach:kilochromaton.png%0aThe segments are numbered in the same way as [[#chromatonlabel|chromaton]].%0aKilochromaton can encode for 23 private keys.%0a%0a!!Kilodichrome%0aAttach:kilodichrome.png%0a!!Kilotrichrome%0aKilotrichrome contains 3 [[#kilochromaton|kilochromaton]] which is 6,912 base-6 digits or 17,712 binary bits.  This is similar to a version 34 QR code.%0aAttach:kilotrichrome.png%0aIt is read starting at the top and going clockwise. Kilotrichrome encodes 69 private keys.%0a%0a!!Kilotetrachrome%0aAttach:kilotetrachrome.png%0a%0a!!Kilopentachrome%0aAttach:kilopentachrome.png%0a!!Kilohexachrome%0aKilohexachrome contains 6 kilochromaton.  This means it has 2304x6 (13,824) base-6 or 5904x6 (35,424) binary bits.  This is over 50%25 more data than the largest QR code, version 40.%0aAttach:kilohexachrome.png%0aKilohexachrome can encode up to 138 private keys.%0a%0a!!Kilochroma%0aKilochroma contains 7 [[#kilochromaton|kilochromaton]] and thus contains 16,128 base-6 digits or 41,328 binary digits which is nearly double the data of the largest QR code; version 40.%0aAttach:kilochroma.png%0aKilochroma can encode 161 private keys.%0a!!Kilononachrome%0aKilononachrome is 9 kilochromaton and thus has 9x2304 (20,736) base-6 digits or 9x5904 (53,136) binary digits.  This is more than double the largest QR code, version 40.%0aAttach:kilononachrome.png%0aKilononachrome can encode 207 private keys.%0a!!Kilomonochroma%0aKilomonochroma contains 12 kilochromaton and thus contains 12x2304 (27,648) base-6 or 12x5904 (70,848) binary bits.  This is roughly 3x more than the biggest QR code version 40.  Contains less than half the largest iQR code, version 61.%0aAttach:kilomonochroma.png%0aKilomonochroma can encode 276 private keys.%0a!!Kilodichroma%0aKilomonochroma contains 18 kilochromaton and thus contains 18x2304 (41,472) base-6 or 18x5904 (106,272) binary bits.  This is roughly 5x more data than a version 40 QR code, the largest.  Contains nearly 2/3 the data of a version 61 iQR code, the largest.%0aAttach:kilodichroma.png%0aKilodichroma can encode 415 private keys.%0a%0a!!Kilotrichroma%0aAttach:kilotrichroma.png%0a!!Megachromaton [[#mega]]%0aMegachromaton contains 48 kilochromaton and thus contains 110,592 base-6 digits or 283,392 bits which is roughly 12x the data capacity of the largest QR code; version 40.  Also it is over 50%25 more storage than version 61 iQR code which stores 171,727 bits in 422x422 modules.%0a%0aMegachromaton contains 90x90x90 units (729,000) compared to iQR which contains 422x422 units (178,084).  Again the megachromaton holds 50%25 more data than the version 61 iQR code and likely would be read and processed even faster than the iQR.%0aAttach:megachromaton.png%0a%0aMegachromaton can encode up to 1,107 private keys!%0a%0aYou may notice the center colors are ordered differently than chromaton and kilochromaton.  This is an improved color scheme and should be applied to all chromaton versions to improve contrast.%0a%0a!!Chromaton Version 2[[#v2]]%0a%0aWhy version 2?  Better [[#v2error|error correction]]%0aUnlike version 1 which could be stacked any way, version 2 requires a backwards stacking bias.  If a forward stacking bias is needed then the white and black dots on the outer ring need to be swapped.%0a%0aAgain it is critical that chromaton never be tied to an identity or its use tied to an identity.  Identifying information must never be contained within chromaton nor should it be used to indicate proof of an identity.  Chromaton must neverbe used to discriminate between compliant people and non-compliant.  Chromaton is only for fully anonymous use and content, use and content must never be tied to identity.  Not even if by consent.%0a%0aThe grey dots function as black dots but are used for orientation (they can be white if grey is undesired).  The black and white dots are used for timing and image flattening.  The white dots are used for markers for reading.  The reading algorithm would look at a white dot and read all the base pairs around the white dot in a clockwise fashion.  Then it would find the next white dot clockwise and read all base pairs around that clockwise.  It continues this in an outward spiral just like chromaton v1.  Even the outer white dots are used in the same way.  Notice that every base pair is read twice for redundancy...except the very corner data dots.  Actually when chromaton are linked together, the next chromaton will check that corner dot as well as the dot in it's own corner.  So the more chromaton linked together, the more complete the redundancy check.%0a%0aAttach:chromaton2.png%0a!!!Error correction [[#v2error]]%0aStudying error correction I realized that in the original chromaton as a senary system, this would be quite a challenge to incorporate algorithmic error correction.  So Chromaton v2 was born, with the goal of physical error correction.  This is physics based information theory and has never been done before to my knowledge.  I discovered it studying DNA and how it has base pairs A-T and G-C that are always paired together.  I realized that this gives perfect 1 bit error detection.  I don't think there is error correction in DNA code, the polymerase just needs to be able to detect errors so it can fix them manually.  You don't want to gloss over damaged DNA by just adding bits for error correction, that is wasteful when you want the code to be maintained perfectly for life.%0a%0aAnyway I started with pairing complementary colors.  I had 12 colors so with 6 pairs that gives 12 combinations.  I also realized that if I [[#orient|limit the directions]] the colors could go, so for example the lightest color always goes upwards, then there are only 6 combinations.  Doing this starts adding error correction ability.  With this restraint, we now have 50%25 1 bit error correction and 2 bit error detection.  The reason this works is if we have a random color error bit, there is a 50%25 chance it is in the wrong spot, and if so we know it was the wrong one and can correct it.  Next I figured I could improve the error correction ability more.  What if I added [[#filter|filters]] to areas of the chromaton, sort of like epigenetic modifications in DNA.  Filters would add another dimension to chromaton and could improve error detection.  I broke the chromaton into 12 areas each with one of the unique colors applied as a light filter.  Now the chances that a bad bit has the correct filter applied is 1 in 12.  So now we are at 1/2 * 1/12 = 96%25 1-bit error correction and 96%25 2-bit error detection!  This is closely approaching perfect algorithmic 1 bit error and 2 bit detection technology which typically would require 4 bits to achieve and we did it with only 2.%0a%0a!!!Allowed pair orientations[[#orient]]%0aAttach:colororientations.png%0a%0a!!!Filter regions[[#filter]]%0aAttach:filters.png%0a%0a%0a!!!Chromaton v2 Numbering%0aThe color correction bits are labeled with a "C" in front of them like "C1" and "C2".  The senary data bits (including inbuilt error correction) are labeled 1-24.%0aAttach:chromatonnumber.png%0a24 senary (base-6) data bits means each chromaton contains 60 binary bits of data.%0a!!!Machine reading%0aNotice there are 54 reads of 24 bits and that every double bit gets checked in full twice, and half of the double bit gets checked again for a total of 3x on each double bit.  The 3 checks vote and if it gets the same read 2 out of 3 times those 2 are considered the correct read.  If all 3 reads are different then it starts reading from the beginning again until there is a majority vote.%0a%0aWhen you stack more chromaton on eachother with the proper stacking bias, the corners of the next chromaton get checked with this chromaton.  %0a%0aThe machine goes from one white bit to the next and reads the lower left bit first and moves around clockwise checking all bits.%0a%0aAttach:machinechromaton.png%0a%0a!!!Higher order%0aUnlike v1 where any error correction can be carried out the same way on higher orders of magnitude, our color coding shortcuts cannot work on higher levels without degrading error correction performance on all levels (as far as I can design).  So we will opt for the standard physical error detection and correction; redundancy (again, the same error correction that DNA uses [[https://en.m.wikipedia.org/wiki/Genetic_redundancy|#]]).  Algorithmic data correction is weak.  If one check bit of algorithmic data correction becomes corrupted, error correction for multiple data bits is compromized. If one check bit of physical data correction becomes corrupted, error correction of only 1 data bit is compromized.  Therefore algorithmic always has tradeoffs.%0a%0aIn chromaton v2 (Cv2), in higher orders of magnitude there will be 3 of each data "bit" where one bit is a lower level chromaton.  This can detect max of 2 bit errors and correct a maximum of 1 bit errors in the order of magnitude you are at.  For example in kilochromaton the 3 redundant bits means you can correct 1 bit errors in kilochromaton.  But what this means is this method can actually detect and correct errors of literally any size in the lower level of chromaton since it is comparing thier entire checksums. The nice thing here is this is perfect error correction instead of 96%25 like our first level.  The tradeoff is we can hold significantly less data in this method.  Instead of having 24 base-6 digits of storage like level 1, level 2 and beyond can only hold 16 digits each, but to integrity of data is astronomically high and virtually 100%25 perfection.%0a%0aHigher order of magnitude error correction checks the "checksum" of each chromaton that is 1 order of magnitude below it and compares it between the 3 total copies of each.  One way to look at single bit error correction is the 3 copies vote and majority wins.  If none match, then that is considered detection of a 2 bit error.  This is a little different than normal.  Normally 4 copies are needed for 2 bit error detection and 1 bit correction.  Bit in this case the checksum's are so big that the chances of 2 checksums matching and both were in error, are very slim.  4 bits are needed for binary data.  For checksums which contain many more possibilities besides 0 and 1, only 3 bits are needed. %0a%0aTherefore instead of having 100%25 error detection and correction rate since we are using perfect setup, since the check sum has only 72 possible outcomes (max sum would be 6x12) and the first level has 144 possible outcomes.  Therefore the actual rate is just over 99%25 for checking level 1, and just under 99%25 for each subsequent level.  Compound the 96%25 with the ~99%25 of each subsequent level and you have what quickly approaches perfect 1 bit error correction and 2 bit detection.%0a%0aCv2 chromaton doesn't have a perfect fractaling outwards from the base level and beyond, but neither does DNA structure.  I am happy with Cv2 as a super robust error correcting design, perhaps the most practically robust ever designed by humans.%0a%0a!!!!Kilochromaton%0aKilochromaton holds 16×24= senary digits or 16×60=960 binary bits of data. Megachromaton is needed to achieve the highest level of what a QR code can store by storing 15,360 error free bits, and %0aGigachromaton more than doubles what an iQR code can do by storing 245,760 error free bits.%0aAttach:kilov2.png%0a%0a!!!!Kilochromaton numbering%0a%0aIgnore the colors, that is just for visualization purposes.%0a%0aKilochromaton for Cv2 uses 3 redundant bits for each data bit.  It uses 1 bit error correction, if checksum's of the 3 replicates don't match, then error correction is run on all 3 on the lower chromaton level.  Then checksums are matched again.  If 2 match and one doesn't, the ones that matched are used as the correct data.  If all 3 still don't match then a 2 bit error is detected at the kilo level.%0aAttach:kilov2machine.png%0a%0a!!Chromaton Version 3 (Cv3) [[#v3]]%0aChromaton v3 means data perfection.%0a%0aAgain, chromaton is never to be used in or for identity or tied to identity in any way.  Not even some egalitarian vision of identity like Tim Berners-Lee is advocating for.  Chromatom must always be anonymous and free of any ties of any kind.  Even consent does not make tying chromaton to an identity ok.%0a%0aIn version 3 we want to accomplish 2 things.  Firstly we want to get rid of color filters altogether so Chromaton becomes a more versatile protocol.  Secondly we need to resist burst errors so redundant data needs to be placed far apart from eachother.%0a%0aAttach:chromaton2.png%0a%0aThe basic data structure is the same as version 2.  In chromaton we had 48 unique digits that included some error correction.  In chromaton v2 we had a base level of 24 digits, and subsequent levels of 16 digits. In chromaton v3 every level has 16 digits.  Like in [[#v2|v2]], the grey dots can be white and achieve the same goal if desired (if grey is too hard to encode).%0a%0a!!!Storage calculations%0a%0aIn terms of storage, a chromaton contains 29 bits of data.  So a kilochromaton has 29×29=841 bits.  Megachromaton has 24,389 bits. Gigachromaton has 707,281 bits which is 88.4 kilobytes of data. Terachromaton has 20,511,149 bits which is 2.56 megabytes of data (which can store close to this entire website).  A petachromaton has 594,823,321 bits which is 74.4 megabytes of data.  An exachromaton has 17,249,876,309 bits which is 2.16 gigabytes of data.  A zettachromaton has 500,246,412,961 bits which is 62.5 gigabytes of data. A yottachromaton has 14507145975869 bits which is 1.8 terabytes of data. And in my mind that will be about the limit of practical 2D chromaton.  See [[3D chromaton disc]] for larger storages.%0a%0a!!!!Byte calculations%0a%0aAssuming an 11cm chromaton disk chromaton would have 1cm wide hexagons.  Kilochromaton would have 0.0909cm. Megachromaton is 0.008cm, or 80 microns which is larger than a pixel of a 4k screen of the size of the megachromaton  since 4k is 8 megapixel, it should fit on any wqhd screen.  Gigachromaton is 0.00075cm which is 7.5 micron, which would require a 30k screen or roughly 450 megapixels.  Terachromaton is 680nm (size of a DVD pit [[https://electronics.howstuffworks.com/dvd2.htm|#]]). Petachromaton is 62nm.  Exachromaton is 5.6nm.  So a CD size chromaton could potentially hold up to a couple gigabytes of data.  Not bad.  Especially when you consider data stored as chromaton is perfect data.%0a%0aIf we started with 110cm chromaton sort of the size of very large book pages or posters a chromaton would have 10 cm pixels. Kilochromaton 0.909cm. Megachromaton 0.083cm.  Gigachromaton 0.0075cm. Terachromaton 0.00068cm. Pentachromaton 620nm (size of a dvd pit). Exachromaton 62nm. Zettachromaton is 5.6nm which is probably the limit for the near future. This means you could have a (very expensive) book that holds 62.5 gigabytes of data per page and have flawless error correction.%0a%0a!!!!Private key calculations%0a%0aA private key is 256 bits.  In the [[digital collectible network]], private keys might be valued around $0.50 in 2021 dollars.%0a%0aKilochromaton: 3 private keys, $1.50. Very practical.%0a%0aMegachromaton: 95 private keys, $47.50. Quite practical with 4k screen display of the chromaton.%0a%0aGigachromaton: 2,762 private keys, $1381.00.  Somewhat practical, this will probably be within the range of consumer displays and cameras in 10-20 years as it requires around 450 megapixel or 30k resolution.  This is well within the range of CD-like resolution so gigachromaton disks could be practical today.%0a%0aTerachromaton: 80,121 private keys, $40,060.50.  Possibly practical, this is in the realm of chromaton on specialized disks with color centers about the size of a DVD pit.%0a%0a%0a!!!Version 3 numbering [[#cv3number]]%0aThis applies to all levels of Cv3; base, kilo, mega, giga, etc.  So in Cv3 we achieve full fractal again.%0a%0aThe colors here denote a certain shape that the color set (triad) can take, thus there are 4 shapes (green, orange, light blue, red)%0a%0aThe numbers represent the shape redundant data takes.  So each "1" is a replicate of the same data (in kilochromaton and greater it is the exact same data, but in base chromaton it represents a unique color combination triad, which all represent the same number as well).  And same for "2" and so on.  So version 3 chromaton can have 16 digits of base-4 numbers.  So each of these numbers can be 0,1,2 or 3.  Red-green-blue is 0. Purple-orange-bluegreen is 1. Yellow-cyan-magenta is 2. lightblue-yellowgreen-redmagenta is 3.%0aAttach:chromaton3.png%0a%0a!!!!Error correction [[#v3error]]%0aTo get up to speed with probability calculations you will need to learn all these concepts found here [[https://www.statisticshowto.com/probability-and-statistics/probability-main-index/probability-of-a-and-b/|#]].%0a%0aTo get rid of the color filters in Cv2, we need to use 3-color triads instead of 2-color pairs.  We will also force orientation in certain ways so there are 12 colors and only base-4.  We are giving up 8 bases (2/3rds) in order to have robust error detection and correction.  This means that each color is only in a set of 3 and must maintain a certain orientation. These methods, like in [[#v2|Cv2]], are part of physical information theory (PIT) or [[physical error correction]] (PEC) which is in contrast to algorithmic error correction (AEC) invented by Hamming.  PEC uses physical properties of data to detect and/or correct and/or prevent errors.  Some of these properties, as also explained in [[#v2|Cv2]], can be replicates, recombination, location, orientation, partnering, tagging, keying, contrast, etc.  [[Physical error correction]] is the methodology most used in nature and can be found in DNA, visual field, neurons (such as memory and recall); and other data storage, transmission, and processing.  If PEC is bieng used exclusively over AEC, then the only algorithms used would be in the reading and decoding, not in the encoding.  Only physical factors are used for encoding in purely PEC.  Of course algorithms can be used to choose or dictate how/when PEC is used based on the data used.%0a%0aAs will be shown below, the Cv3 PEC system gives us 100%25 detection and correction of 1-bit errors, 98%25 detection and correction of 2-bit errors, and 30%25 detection of 3-bit errors.  These numbers increase astronomically when kilochromaton or higher are employed.  In kilochromaton most errors up to 48 bits will be corrected!%0a%0a%0a!!!!!1-bit error%0aWe will be able to correct every 1-bit error and only falsely correct (3/12)*(1/12)= 2.1%25 of 2-bit errors without detection because we diagnosed them as 1-bit errors wrongly.  This is because the chance that an error color is in an allowable spot is 1/3 (which is 4/12) but can't be the correct color (so subtract 1/12 from 4/12 and get 3/12) and the chance the last spot has the perfect color to go with the last error color, is 1/12. This way the correct color actually seems wrong and the error colors seem right.  %0a%0aThe chance that a 3-bit error is diagnosed wrongly as a 1-bit error is 10.9%25 as seen in the below calculations.%0a%0a!!!!!2-bit error%0aFor that 97.9%25 of 2-bit errors we were able to detect, we can also correct them all!  Just as long as one bit was in an allowable spot and the other 2 were not, then we correct the ones that were not, with the other colors in the triad of the one color that was allowable.  We still record this as a 2-bit error though, because the chance we corrected it wrongly is quite high, since as seen below, the chance that a 3-bit error goes undetected is over 70%25.  Many of these undetected 3-bit errors will look like 2-bit errors.  It turns out 59.2%25 of 3-bit errors actually look like 2-bit errors and get wrongly diagnosed and corrected, see below for calculations.%0a%0a!!!!!3-bit error%0aSee probability of "at least one" [[https://math.stackexchange.com/questions/85849/calculating-the-probability-that-at-least-one-of-a-series-of-events-will-happen#85852|#]].%0a%0aWhen all 3 colors in a triad are unallowable, this is a detectable 3-bit error.  Because of this we can detect some 3-bit errors.  %0a%0aTo determine the chance we will need to calculate the chance that at least one color is in an allowable position.  The chance a color error bit is in an allowable position is 1/3.  So the chance that at least one color is in one of the allowable positions is 1-(chance none are in allowable positions) so 1-(2/3)*(2/3)*(2/3) = 70.4%25.  This means that in a 3-bit error, the chance that at least one color is in an allowable position is 70%25. So since we need all colors to be in an unallowable position, this means that we can only detect 30%25 of 3-bit errors.%0a%0aHaving 3 colors all in unallowable positions is nonsense to a computer.  We cannot have a nonsense bit like this so we have to correct it, even though the chance of correcting it wrongly are extremely high.  To "correct" it and make it into a sensical bit (triad) we first look to see what colors the nonsensical triad contains.  If it contains all the colors of a sensical triad, just in the wrong locations, or if it contains the same color 2 times in the wrong spots we choose to correct it to that triad that contains that color bit.  Also if it contains 2 colors of a certain triad in the wrong locations we correct it to that triad.  If it contains 3 different colors all of different triads, at least that removes one of the 4 possible triads.  To select which triad to correct it to out of these 3, we now have a simple solution, correct it to the triad that gives the middle value.  Since all 4 triads are numbered 0-3, and all 3 triads are different in this case, one will have a value between the other 2.  We choose this one since it will effect the checksum of the chromaton the least.%0a%0aThe chance a 3-bit error is undetected and looks like a 2-bit error or 1-bit error or no error is 70.4%25, since at least one needs to be in an allowable position.  Using the below calculation, the chance of it looking like a 2-bit error exactly, is 70.4-11.2 = 59.2%25 chance.%0a%0aThe chance a 3-bit error is undetected and looks like a 1-bit error or no error is 0.704*(1-(11/12)*(11/12)) = 11.2%25.  This means that there is a 70.4%25 chance of at least one spot having an allowable color and then at least one of the remaining spots having the exact right color, a 1/12 chance.  So 11.2%25 of 3-bit errors look like at least 2 of the colors are in the right spot. Using the below calculation, the chance a 3-bit error looks like a 1-bit error exactly, that 2 of the colors are correct and 1 is wrong is 11.2 - 0.23 = 10.97%25 chance, see the calculation below for how we got the 0.23.%0a%0aThe chance a 3-bit error is undetected and looks like no error at all is (1/3)×(1/12)×(1/12) or 0.23%25 chance.%0a%0a%0a!!!!!Conclusion%0a%0aWe have a 97.9%25 2-bit error detection and correction rate and 100%25 1-bit error detection and correction rate.  This is excellent, triads of Cv3 when compared to the pairs of Cv2, Cv2 only had 50%25 2-bit error detection (without filters) whereas with Cv3 and 3 bits, we get 97.9%25 2-bit error detection.  This is more than enough especially when using kilochromaton and higher as it will correct even more errors. 2-bit errors are still recorded because of the small chance it was corrected wrongly. %0a%0aThat 30%25 chance when we diagnose a 3-bit error correctly, we will still "correct" it wrongly but we will make a note that it is a 3-bit error [[https://electronics.stackexchange.com/questions/71410/single-bit-error-correction-double-bit-error-detection|#]].  This is because we do not know what the correct value is supposed to be so we have to make it something.  It would be nice if we could keep it and compare each color of each triad with the other replicate chromaton at the kilo- level, but unfortunatly we don't record a value for each color, only for each triad.  So if we can't get consensus within the triad, we have to correct it to a wrong value and record it as an error.  The good news is at the kilo- level, if the other 2 chromaton don't have an error recorded here, their data will take precedence over our erroneous data. Also see [[#kerror|kilochromaton error correction]].%0a%0a%0a%0a!!!Version 3 combinations%0aThe colors these were circled with match the colors above in the numbering picture.%0aAttach:v3combos.png%0aThese were figured out using the below color wheel to get colors in the same possible position spaced out as far as possible on the color wheel.  This is an example of the PEC called "contrast".%0aAttach:wheel1.png%0a%0a!!!Kilochromaton v3%0aThe basic data structure of Cv3 is the same as Cv2.  In version 3 kilochromaton, three copies of each chromaton are used.  The way the data is organized the [[#cv3number|same as base cv3]].%0aAttach:kilov2.png%0a%0a!!!!Kilo error correction [[#kerror]]%0aThe farther the error correction on this level makes it, the less severe of an error.  The lower the error number, the more severe the error.  So an error at step 1 is more severe than an error at step 5 for example.  This will help us in megachromaton error correction.%0a%0a!!!!!1. Sum%0aKilochromaton (and higher) gives us another check of the lower chromaton we are reading.  At this level we use "sum" of the lower level.  So first we decode and [[#v3error|error correct all base level]] chromaton.  Then we sum up all the numbers contained in each chromaton and this is the sum, one for each chromaton.  In kilochromaton level we compare the three sums for each replicate chromaton.  If all 3 are the same then we verified that everything is perfect (we have 16 base-4 numbers so the chance that we randomly got the sums to equal yet actually be wrong is 1/48 × 1/48 × 1/48 = 9×10^(-6) or 9 times in 1 million).  But for 2 of them to randomly give the same sum wrongly is 1/48 * (1-(47/48)*(47/48)) = 0.086%25 or 859 times in a million.  So since we will accept if 2 of them add to the same sum, we will have a %25 correct - error correction rate.  This not only corrects 1-bit or 2-bit errors at this level, this corrects up to 48-bit errors!  An entire base chromaton could be wrong and it could be fixed at this level. If 2 or 3 replicates have the same sum, go to [[#samesum|this step]] next. If not, go to the below step.%0a%0a!!!!!!All different%0a%0aIf all 3 of the sums are different, what do we do?  Firstly I want to say that all 3 being different will be extremely rare since we already have perfect 1-bit error correction and roughly 98%25 2-bit error detection at the base level. But when it does rarely happen we can do something else so we don't loose all the data in the base chromaton just because of a couple errors.  What we will do is take the 2 chromaton with the fewest detected errors (or the least serious errors, 3-bit error more serious than 2-bit). If there is a 3-way tie, favor the 2 chromaton with fewest/less serious errors and most similar sums, if still a 3-way tie then compare and correct all 3 at the same time at the base chromaton triad level.  Anything that is different between the 2 (or 3), we check to see if there were any errors detected previously in those spots.  If in one of the chromaton one triad was detected as an error and the other chromaton does not have an error detected in that triad, then the error triad is replaced with the non-error triad.  This is the PEC technique of error recombination.  After all of this what we will be left with is 2 chromaton (or 3) that are either now identical or only vary in one of two ways.  The first way they can vary is if both have different errors in the same triad.  The second way is they both have different values in the same triad and neither was detected as an error.  In both of these cases the data from the third chromaton is used to fix these, unless the third chromaton has worse errors in those spots (3-bit error) in which case just use the triad from the chromaton in the first position, that is the chromaton nearest the upper left of the kilochromaton.  Even if the loser chromaton also has a 2-bit error in the same spot as a 2-bit error in the 2 winners, use the loser chromaton triad so there is convergence.  In the case that the 3rd loser chromaton has an 2-bit error in the triad where the 2 winner chromaton have no errors but different values, then use the 2-bit error.  The reason for this is 98%25 of 2-bit errors will have been corrected correctly, but if no errors were detected but both winners have a different triad, the chance that one of those is right is less than 50%25.  In the case the 3rd loser chromaton has a 3-bit error in a triad where the 2 winner chromaton have no errors but different values, choose one of the winner chromaton's triad.  Just choose the triad from the chromaton in the first spot, that is the spot closest to the upper left of the kilochromaton. Now the 2 chromaton that were being compared (or 3 if still all tied) are as good as we can get them in this step.  If you choose a winner here, if one chromaton now has the least amount of errors/least serious errors, then report a soft error of [#1].  This is the most serious soft error in the kilochromaton level.  If there is no winner and we now have 2 chromaton with the same number/severity of errors, report a soft error of [#1] and bring these two to step 3 (skipping step 2 since we already did it), and discard the loser chromaton.  If there are 3 chromaton with the same amount/severity of errors and the sums the same distance apart, report soft error of [#1] and bring all three to step 3.%0a%0a!!!!!!Two or three same [[#samesum]]%0aIf 2 or more agree on the sum without performing the "all different" protocol above, then this is great; if the sums equal then the overwhelming chance is the chromaton are in fact the same. However we still have to decide which one to correct it to!  We can't just keep all the chromaton since they are replicates at this level.  One idea would be to choose one randomly.  The reason we won't do this is 2-fold.  Firstly it would take a lot of processing power to run a pseudorandom algorithm every time we needed to make a decision.  Another reason is random algorithms can be cracked and a malicious attacker could know ahead of time which one you will pick and insert a malicious chromaton in the position that he knows will beat the detection.  So we need to use actual intelligent decisions so we are all on the same page.  The following techniques will go from fast and easy to slower and more complicated.  If the fast and simple methods can converge us on an answer then it will save us time and give us soft errors that will tell us how close our data is to perfect, and if not then we go to the more expensive techniques. See history of error correction for more info on the following checks [[https://www.techradar.com/news/computing/how-error-detection-and-correction-works-1080736|#]]. %0a%0aIf two or three of the replicates have the same sum, we go to the next step, step 2, with all the chromaton replicates, even if one doesn't have the same sum.  We will get rid of the one without the same sum in step 2 after we use it for recombination.%0a%0a%0a!!!!!2. Error recombination%0aIn this step we pick the one with the least amount of errors (and/or least severe errors; since 3-bit errors are more serious than 2-bit) reported in the [[#v3error|original error correction steps]] to use as the "one correct version" ("winner").%0a%0a!!!!!!If only two replicates from the previous step have the same sum:%0aWe recombine the errors between the two replicates that had the same sum.  To do this we look at each triad with an error, and see if the other replicate does not have an error in that spot.  If not, then replace the error triad with the non-error triad.  Also we use the replicate with the different sum, the looser from step 1, and if this has an error-free triad that the winners need, it is substituted into the winners.  %0a%0a[[#priority]]%0aThe priority is this.  All else bieng equal favor triads from the winners.  If the winners have different values for a triad so they are not matching but niether contained an error, then substitute the triad from the third chromaton unless it is a 3-bit error.  If it is a 3-bit error then take whatever triad was from one of the winning chromaton from the first location, basically the location closest to the upper left of the kilochromaton.  If there are 2-bit errors in both of the winners and the 3rd chromaton, or if there is a tie in anyway between the 3, favor the triad from the losing chromaton.%0a%0aIf there is now one replicate with least/lowest severity of errors, then go to the [[#recombwinner| winner section]] a couple paragraphs down.  If both winning replicates now have the same number/severity of errors, discard the looser replicate with the different sum from step 1, and go to step 3.%0a%0a!!!!!!If all 3 from the previous step have the same sum:%0aIf there is a replicate that has the fewest/least severe errors, then that is the winner.  If there is a detected error in one or more triads in this winner, and if there is a matching triad in another replicate that does not have an error at that location, then the error free triad is substituted into the winner chromaton. Continue to the part below: "[[#recombwinner|If there is a winner determined]]".  %0a%0aBut if a winner was not determined and there are two or three with the same amount/severity of errors, then do recombination as well.  Compare the two with the same amount of errors and the same sums (or all three in the case they all are tied) and see if you can correct any using the data from the other.  So if one triad that gave an error has a match in the other replicate chromaton with no error, use the error free version.  You can use the third loser replicate (the one with more errors) to fix any errors you couldn't fix using only the winner replicates.  %0a%0aIf there are two tied with the lowest number/severity of errors, use this [[#priority|priority]].  If three are tied, use that priority but instead of using the loser chromaton to break ties, use the chromaton in the first position in the kilochromaton.%0a%0aAfter this discard the loser replicate if there is one. If now one replicate has less errors/severity than the others you have a winner and continue to [[#recombwinner|"if there is a winner"]] section.  If you still have the two or three replicates with that had the same sum in the previous step tied with number/severity of errors even after recombination, continue to step 3 after discarding any loser replicate chromaton.%0a%0a!!!!!!If there is a winner determined:[[#recombwinner]]%0aIf a winner is chosen in this step, then report a soft error of [#2].%0a!!!!!3. Parity check%0aIf they all have the same amount of errors or 2 have the same amount, then we need something more than a sum, we can use a "parity check".  %0a%0aA parity check is a count of how many times a certain value showed up in our chromaton. Add up the number of each type of triad, our base-4 numbers. So add up the number of each "0"s, the "1"s, the "2"s, and the "3"s. And compare the results across the remaining chromaton.  This would be something like chromaton1 contains 5x "0", 10x "1", 1x "2", 0x "3".  Now if chromaton2 matches chromaton1 parity check but chromaton3 has a different parity check, then we can exclude chromaton3.  If all remaining replicate chromaton have different parity checks, then choose the one with the most even distribution of numbers. We can use a sort of "r^2 method". In our case there are 16 numbers so an even distribution would be 4x of each 0,1,2,3. Our r^2 method would subtract our actual number by 4 and then square the value.  So for our sample set it would be (5-4)^2 + (10-4)^2 + (1-4)^2 + (0-4)^2.  Now choose the one with the lowest value of this test.  After this test the only errors that would be matching is if all the right values were included in both chromaton, but the location of the values were different.  If a winner is chosen here, which means one has a lower parity check than the other 2, report a soft error of [#3].  If 2 or 3 of the replicate chromaton have the same parity check or two are tied with the lowest parity check, go to step 4 after you discard any replicates without matching parity checks.%0a%0a!!!!!4. Checksum%0a%0aTo check for possible locational error we will use a checksum which is a little more computationally intensive since it requires a 2D matrix.%0aBasically each of the 16 values in the chromaton, 0-3, is placed in a 4x4 matrix.%0aAttach:checksum.png%0aNext the rows are added and the columns added.  Mod 4 means that the sum is then divided by 4 and the remainder is reported.  Now these remainders are compared between the 2 (or 3) replicate chromaton.  If there are 3 chromaton left and 2 match and one doesn't, then discard the non-matching.  If 2 or 3 are remaining and they agree then great, go to next step with all of the agreeing replicates.  If they do not agree, choose the one with the average checksum closest to 1.5.  To determine this you take all 8 checksums, add them together, divide by 8, and call that "answer".  Then take (1.5-answer)^2 and compare this value to the other chromaton's value.  The smaller number wins.  If they are the same, go to next step.  If there is only one winner at this step, report a soft error of [#4].%0a%0a!!!!!5. Compare each value%0a%0aIf you are here, then chances are at least 2 of your 3 replicate chromaton are identical.  Congratulations!  For the final check, each and every value is compared between eachother.  We already have the 4x4 matrix set-up for each chromaton and each of the 16 values are compared between eachother.  If they all/both match, great, select the [[#cv3number|first chromaton in the triad]] of one of the matching replicates as the winner, the replicate closest to the upper left of the kilochromaton, with no error reported!  Simply report a "0" if all 3 replicates matched, and a "1" if 2 of the replicates matched. If none of the remaining replicates match, we again just choose the first replicate, the one closest to the upper left of the kilochromaton as the winner and report error [#5].%0a!!!!!Conclusion%0aWe just put these replicates through the wringer!  We now have an excellent gauge on if we have correct data at the kilochromaton level.  The megachromaton level will look at the data from the kilochromaton level and take into account the reported errors at this level.  The higher the "#" error, the less serious it is considered since the higher the # the more hurdles the data overcame before being left with only 1 replicate remaining.%0a%0a%0a%0a%0a%0a%0a!!Uses%0aThe Chromaton system can be used for any purpose including data transmission (including cryptographic keys and/or signatures proving ownership) and/or storage that is both human and computer readable, making visual displays for any use or purpose, for doing computations, etc.  It was invented to be used in transferring private keys between users of [[digital collectible network]].  Chromaton can also be used as data storage for photonic computers.%0a%0aFor digital data storage and/or transmission uses, colors don't need to be used at all and can be replaced with numbers.  Using this system virtually perfect data transmission can be achieved free of any size bit error.  The whole purpose of the colors is making the data transmittible via visible photons at the speed of light with no prior established data link.  But if there is an established data link between the 2 (like bluetooth or internet) then colors are not needed. One thing that would not work with numbers would be the the color filters ([[#v2|chromaton version 2]]), so if that was removed only 50%25 error correction could be carried out on the lowest level of chromaton.  Perhaps instead of 2 bit groupings, 3 bit groupings could be used on the lowest level similar to higher levels of chromaton. And instead of having 24 base-6 digits on the lowest level and thus 60 binary bits, you would have 16 base-4 digits and thus 29 binary bits.  This was done in [[#v3|Chromaton v3]].%0a%0aFor physical storage diffraction patterns (diffraction grating), thicknesses and angle of transparent layers (refraction: prism effect/internal reflection), or other methods can be used to achieve a certain fingerprint of light reflection/absorption that can be read as a "color" bit.  See also [[Chromaton disc]].%0a%0aFor the time being chromaton is a 2D color representation of data.  Using diffraction of light chromaton could become 3D and instead of each 2D position of color defining the data, 3D position of color would define the data.%0a%0aChromaton should absolutely never be used to identify people, should never be tied to an identity, and never used to verify people's identities or any mandatory or voluntary control or categorization of humans (including verifying compliance, which should never be done).  Chromaton use should never be tracked and should always be anonymous (not merely "anonymized").%0a%0aKeep Chromaton Free.%0a%0a!!Links%0aHexagonal spiral numbering scalable [[https://tex.stackexchange.com/questions/275490/is-there-an-easy-way-to-number-a-hexagonal-spiral|#]]%0a%0aDiceware uses dice to create random numbers in base-6 [[https://en.m.wikipedia.org/wiki/Diceware|#]]%0a%0aFemto laser creates color centers down to 3x10-3 um^3 which is around 100nm wide [[https://europepmc.org/article/PMC/PMC7823324|#]].%0a%0aA complete history of error detection and correction [[https://www.techradar.com/news/computing/how-error-detection-and-correction-works-1080736|#]].%0a%0aVisualizing data sizes, bible is 4.5 megabytes,%0aHuman genome under a gigabyte [[https://simplyted.blogspot.com/2005/12/how-to-visualize-data.html?m=1|#]]%0a%0aBase pairs per ng of DNA is 9.13x10^11 [[https://answers.yahoo.com/question/index?qid=20061107080441AA23nhV|#]].%0a%0aDNA from shed skin cells on airbag containing 5.87 ng of extracted DNA [[https://pubmed.ncbi.nlm.nih.gov/25434092/|#]] which gives us (9.13*10^11)*(5.87) = 5359310000000 base pairs.  Each base pair is a bit of data so that gives us 669.9 gigabytes of data.  Therefore if we assume about 1 TB of data is shed in skin cells and hair and other things, 19.6 petabytes are shed over 80 years.  With 7.8 billion people about 1.86 yottabytes of data per year from the human species.%0a%0aHuman DNA shed in stool [[https://pubmed.ncbi.nlm.nih.gov/10683738/|#]].%0a%0aByzantine fault tolerance [[https://en.m.wikipedia.org/wiki/Byzantine_fault|#]].%0a
time=1613895198
author:1613895198=
diff:1613895198:1611962226:=442d441%0a%3c Byzantine fault tolerance [[https://en.m.wikipedia.org/wiki/Byzantine_fault|#]].%0a
host:1613895198=68.2.112.187
author:1611962226=
diff:1611962226:1611962028:=380,384c380%0a%3c But if a winner was not determined and there are two or three with the same amount/severity of errors, then do recombination as well.  Compare the two with the same amount of errors and the same sums (or all three in the case they all are tied) and see if you can correct any using the data from the other.  So if one triad that gave an error has a match in the other replicate chromaton with no error, use the error free version.  You can use the third loser replicate (the one with more errors) to fix any errors you couldn't fix using only the winner replicates.  %0a%3c %0a%3c If there are two tied with the lowest number/severity of errors, use this [[#priority|priority]].  If three are tied, use that priority but instead of using the loser chromaton to break ties, use the chromaton in the first position in the kilochromaton.%0a%3c %0a%3c After this discard the loser replicate if there is one. If now one replicate has less errors/severity than the others you have a winner and continue to [[#recombwinner|"if there is a winner"]] section.  If you still have the two or three replicates with that had the same sum in the previous step tied with number/severity of errors even after recombination, continue to step 3 after discarding any loser replicate chromaton.%0a---%0a> But if a winner was not determined and there are two or three with the same amount/severity of errors, then do recombination as well.  Compare the two with the same amount of errors and the same sums (or all three in the case they all are tied) and see if you can correct any using the data from the other.  So if one triad that gave an error has a match in the other replicate chromaton with no error, use the error free version.  You can use the third loser replicate (the one with more errors) to fix any errors you couldn't fix using only the winner replicates.  After this discard the loser replicate if there is one. If now one replicate has less errors/severity than the others you have a winner and continue to [[#recombwinner|"if there is a winner"]] section.  If you still have the two or three replicates with that had the same sum in the previous step tied with number/severity of errors even after recombination, continue to step 3 after discarding any loser replicate chromaton.%0a
host:1611962226=104.175.54.158
author:1611962028=
diff:1611962028:1611961984:=371d370%0a%3c %0a
host:1611962028=104.175.54.158
author:1611961984=
diff:1611961984:1611961844:=371c371%0a%3c [[#priority]]%0a---%0a> %0a
host:1611961984=104.175.54.158
author:1611961844=
diff:1611961844:1611960852:=370,374c370%0a%3c We recombine the errors between the two replicates that had the same sum.  To do this we look at each triad with an error, and see if the other replicate does not have an error in that spot.  If not, then replace the error triad with the non-error triad.  Also we use the replicate with the different sum, the looser from step 1, and if this has an error-free triad that the winners need, it is substituted into the winners.  %0a%3c %0a%3c The priority is this.  All else bieng equal favor triads from the winners.  If the winners have different values for a triad so they are not matching but niether contained an error, then substitute the triad from the third chromaton unless it is a 3-bit error.  If it is a 3-bit error then take whatever triad was from one of the winning chromaton from the first location, basically the location closest to the upper left of the kilochromaton.  If there are 2-bit errors in both of the winners and the 3rd chromaton, or if there is a tie in anyway between the 3, favor the triad from the losing chromaton.%0a%3c %0a%3c If there is now one replicate with least/lowest severity of errors, then go to the [[#recombwinner| winner section]] a couple paragraphs down.  If both winning replicates now have the same number/severity of errors, discard the looser replicate with the different sum from step 1, and go to step 3.%0a---%0a> We recombine the errors between the two replicates that had the same sum.  To do this we look at each triad with an error, and see if the other replicate does not have an error in that spot.  If not, then replace the error triad with the non-error triad.  Also we use the replicate with the different sum, the looser from step 1, and if this has an error-free triad that the winners need, it is substituted into the winners.  If there is now one replicate with least/lowest severity of errors, then go to the [[#recombwinner| winner section]] a couple paragraphs down.  If both winning replicates now have the same number/severity of errors, discard the looser replicate with the different sum from step 1, and go to step 3.%0a
host:1611961844=104.175.54.158
author:1611960852=
diff:1611960852:1611955930:=370c370%0a%3c We recombine the errors between the two replicates that had the same sum.  To do this we look at each triad with an error, and see if the other replicate does not have an error in that spot.  If not, then replace the error triad with the non-error triad.  Also we use the replicate with the different sum, the looser from step 1, and if this has an error-free triad that the winners need, it is substituted into the winners.  If there is now one replicate with least/lowest severity of errors, then go to the [[#recombwinner| winner section]] a couple paragraphs down.  If both winning replicates now have the same number/severity of errors, discard the looser replicate with the different sum from step 1, and go to step 3.%0a---%0a> We recombine the errors between the two replicates that had the same sum.  To do this we look at each triad with an error, and see if the other replicate does not have an error in that spot.  If not, then replace the error triad with the non-error triad.  Also we use the replicate with the different sum, the looser from step 1, and if this has an error-free triad that one of the winners needs, it is substituted into the winners.  If there is now one replicate with least/lowest severity of errors, then go to the [[#recombwinner| winner section]] a couple paragraphs down.  If both winning replicates now have the same number/severity of errors, discard the looser replicate with the different sum from step 1, and go to step 3.%0a
host:1611960852=104.175.54.158
author:1611955930=
diff:1611955930:1611955708:=358c358%0a%3c If all 3 of the sums are different, what do we do?  Firstly I want to say that all 3 being different will be extremely rare since we already have perfect 1-bit error correction and roughly 98%25 2-bit error detection at the base level. But when it does rarely happen we can do something else so we don't loose all the data in the base chromaton just because of a couple errors.  What we will do is take the 2 chromaton with the fewest detected errors (or the least serious errors, 3-bit error more serious than 2-bit). If there is a 3-way tie, favor the 2 chromaton with fewest/less serious errors and most similar sums, if still a 3-way tie then compare and correct all 3 at the same time at the base chromaton triad level.  Anything that is different between the 2 (or 3), we check to see if there were any errors detected previously in those spots.  If in one of the chromaton one triad was detected as an error and the other chromaton does not have an error detected in that triad, then the error triad is replaced with the non-error triad.  This is the PEC technique of error recombination.  After all of this what we will be left with is 2 chromaton (or 3) that are either now identical or only vary in one of two ways.  The first way they can vary is if both have different errors in the same triad.  The second way is they both have different values in the same triad and neither was detected as an error.  In both of these cases the data from the third chromaton is used to fix these, unless the third chromaton has worse errors in those spots (3-bit error) in which case just use the triad from the chromaton in the first position, that is the chromaton nearest the upper left of the kilochromaton.  Even if the loser chromaton also has a 2-bit error in the same spot as a 2-bit error in the 2 winners, use the loser chromaton triad so there is convergence.  In the case that the 3rd loser chromaton has an 2-bit error in the triad where the 2 winner chromaton have no errors but different values, then use the 2-bit error.  The reason for this is 98%25 of 2-bit errors will have been corrected correctly, but if no errors were detected but both winners have a different triad, the chance that one of those is right is less than 50%25.  In the case the 3rd loser chromaton has a 3-bit error in a triad where the 2 winner chromaton have no errors but different values, choose one of the winner chromaton's triad.  Just choose the triad from the chromaton in the first spot, that is the spot closest to the upper left of the kilochromaton. Now the 2 chromaton that were being compared (or 3 if still all tied) are as good as we can get them in this step.  If you choose a winner here, if one chromaton now has the least amount of errors/least serious errors, then report a soft error of [#1].  This is the most serious soft error in the kilochromaton level.  If there is no winner and we now have 2 chromaton with the same number/severity of errors, report a soft error of [#1] and bring these two to step 3 (skipping step 2 since we already did it), and discard the loser chromaton.  If there are 3 chromaton with the same amount/severity of errors and the sums the same distance apart, report soft error of [#1] and bring all three to step 3.%0a---%0a> If all 3 of the sums are different, what do we do?  Firstly I want to say that all 3 being different will be extremely rare since we already have perfect 1-bit error correction and roughly 98%25 2-bit error detection at the base level. But when it does rarely happen we can do something else so we don't loose all the data in the base chromaton just because of a couple errors.  What we will do is take the 2 chromaton with the fewest detected errors (or the least serious errors, 3-bit error more serious than 2-bit). If there is a 3-way tie, favor the 2 chromaton with fewest/less serious errors and most similar sums, if still a 3-way tie then compare and correct all 3 at the same time at the base chromaton triad level.  Anything that is different between the 2 (or 3), we check to see if there were any errors detected previously in those spots.  If in one of the chromaton one triad was detected as an error and the other chromaton does not have an error detected in that triad, then the error triad is replaced with the non-error triad.  This is the PEC technique of error recombination.  After all of this what we will be left with is 2 chromaton (or 3) that are either now identical or only vary in one of two ways.  The first way they can vary is if both have different errors in the same triad.  The second way is they both have different values in the same triad and neither was detected as an error.  In both of these cases the data from the third chromaton is used to fix these, unless the third chromaton has worse errors in those spots (3-bit error)in which case just use the chromaton in the first spot's triad, that is the chromaton nearest the upper left of the kilochromaton.  Even if the loser chromaton also has a 2-bit error in the same spot as a 2-bit error in the 2 winners, use the loser chromaton triad so there is convergence.  In the case that the 3rd loser chromaton has an 2-bit error in the triad where the 2 winner chromaton have no errors but different values, then use the 2-bit error.  The reason for this is 98%25 of 2-bit errors will have been corrected correctly, but if no errors were detected but both winners have a different triad, the chance that one of those is right is less than 50%25.  In the case the 3rd loser chromaton has a 3-bit error in a triad where the 2 winner chromaton have no errors but different values, choose one of the winner chromaton's triad.  Just choose the triad from the chromaton in the first spot, that is the spot closest to the upper left of the kilochromaton. Now the 2 chromaton that were being compared (or 3 if still all tied) are as good as we can get them in this step.  If you choose a winner here, if one chromaton now has the least amount of errors/least serious errors, then report a soft error of [#1].  This is the most serious soft error in the kilochromaton level.  If there is no winner and we now have 2 chromaton with the same number/severity of errors, report a soft error of [#1] and bring these two to step 3 (skipping step 2 since we already did it), and discard the loser chromaton.  If there is 3 chromaton with the same amount/severity of errors and the sums the same distance apart, report soft error of [#1] and bring all three to step 3.%0a
host:1611955930=104.175.54.158
author:1611955708=
diff:1611955708:1611955357:=358c358%0a%3c If all 3 of the sums are different, what do we do?  Firstly I want to say that all 3 being different will be extremely rare since we already have perfect 1-bit error correction and roughly 98%25 2-bit error detection at the base level. But when it does rarely happen we can do something else so we don't loose all the data in the base chromaton just because of a couple errors.  What we will do is take the 2 chromaton with the fewest detected errors (or the least serious errors, 3-bit error more serious than 2-bit). If there is a 3-way tie, favor the 2 chromaton with fewest/less serious errors and most similar sums, if still a 3-way tie then compare and correct all 3 at the same time at the base chromaton triad level.  Anything that is different between the 2 (or 3), we check to see if there were any errors detected previously in those spots.  If in one of the chromaton one triad was detected as an error and the other chromaton does not have an error detected in that triad, then the error triad is replaced with the non-error triad.  This is the PEC technique of error recombination.  After all of this what we will be left with is 2 chromaton (or 3) that are either now identical or only vary in one of two ways.  The first way they can vary is if both have different errors in the same triad.  The second way is they both have different values in the same triad and neither was detected as an error.  In both of these cases the data from the third chromaton is used to fix these, unless the third chromaton has worse errors in those spots (3-bit error)in which case just use the chromaton in the first spot's triad, that is the chromaton nearest the upper left of the kilochromaton.  Even if the loser chromaton also has a 2-bit error in the same spot as a 2-bit error in the 2 winners, use the loser chromaton triad so there is convergence.  In the case that the 3rd loser chromaton has an 2-bit error in the triad where the 2 winner chromaton have no errors but different values, then use the 2-bit error.  The reason for this is 98%25 of 2-bit errors will have been corrected correctly, but if no errors were detected but both winners have a different triad, the chance that one of those is right is less than 50%25.  In the case the 3rd loser chromaton has a 3-bit error in a triad where the 2 winner chromaton have no errors but different values, choose one of the winner chromaton's triad.  Just choose the triad from the chromaton in the first spot, that is the spot closest to the upper left of the kilochromaton. Now the 2 chromaton that were being compared (or 3 if still all tied) are as good as we can get them in this step.  If you choose a winner here, if one chromaton now has the least amount of errors/least serious errors, then report a soft error of [#1].  This is the most serious soft error in the kilochromaton level.  If there is no winner and we now have 2 chromaton with the same number/severity of errors, report a soft error of [#1] and bring these two to step 3 (skipping step 2 since we already did it), and discard the loser chromaton.  If there is 3 chromaton with the same amount/severity of errors and the sums the same distance apart, report soft error of [#1] and bring all three to step 3.%0a---%0a> If all 3 of the sums are different, what do we do?  Firstly I want to say that all 3 being different will be extremely rare since we already have perfect 1-bit error correction and roughly 98%25 2-bit error detection at the base level. But when it does rarely happen we can do something else so we don't loose all the data in the base chromaton just because of a couple errors.  What we will do is take the 2 chromaton with the fewest detected errors (or the least serious errors, 3-bit error more serious than 2-bit). If there is a 3-way tie, favor the 2 chromaton with fewest/less serious errors and most similar sums, if still a 3-way tie then compare and correct all 3 at the same time at the base chromaton triad level.  Anything that is different between the 2 (or 3), we check to see if there were any errors detected previously in those spots.  If in one of the chromaton one triad was detected as an error and the other chromaton does not have an error detected in that triad, then the error triad is replaced with the non-error triad.  This is the PEC technique of error recombination.  After all of this what we will be left with is 2 chromaton (or 3) that are either now identical or only vary in one of two ways.  The first way they can vary is if both have different errors in the same triad.  The second way is they both have different values in the same triad and neither was detected as an error.  In both of these cases the data from the third chromaton is used to fix these, unless the third chromaton has worse errors in those spots (3-bit error).  Even if the loser chromaton also has a 2-bit error in the same spot as a 2-bit error in the 2 winners, use the loser chromaton triad so there is convergence.  In the case that the 3rd loser chromaton has an 2-bit error in the triad that the 2 winner chromaton have no errors but different values then use the 2-bit error.  The reason for this is 98%25 of 2-bit errors will have been corrected correctly, but if no errors were detected but both winners hqve a different triad, chance that one of those is right is less than 50%25.  In the case the 3rd loser chromaton has a 3-bit error in a triad where the 2 winner chromaton have no errors but different values, choose one of the winner chromaton's triad.  Just choose the one in the first spot, that is the spot closest to the upper left of the kilochromaton. Now the 2 chromaton that were being compared (or 3 if still all tied) are as good as we can get them in this step.  If you choose a winner here, if one chromaton now has the least amount of errors/least serious errors, then report a soft error of [#1].  This is the most serious soft error in the kilochromaton level.  If there is no winner and we now have 2 chromaton with the same number/severity of errors, report a soft error of [#1] and bring these two to step 3 (skipping step 2 since we already did it), and discard the loser chromaton.  If there is 3 chromaton with the same amount/severity of errors, report soft error of [#1] and bring all three to step 3.%0a
host:1611955708=104.175.54.158
author:1611955357=
diff:1611955357:1611955281:=358c358%0a%3c If all 3 of the sums are different, what do we do?  Firstly I want to say that all 3 being different will be extremely rare since we already have perfect 1-bit error correction and roughly 98%25 2-bit error detection at the base level. But when it does rarely happen we can do something else so we don't loose all the data in the base chromaton just because of a couple errors.  What we will do is take the 2 chromaton with the fewest detected errors (or the least serious errors, 3-bit error more serious than 2-bit). If there is a 3-way tie, favor the 2 chromaton with fewest/less serious errors and most similar sums, if still a 3-way tie then compare and correct all 3 at the same time at the base chromaton triad level.  Anything that is different between the 2 (or 3), we check to see if there were any errors detected previously in those spots.  If in one of the chromaton one triad was detected as an error and the other chromaton does not have an error detected in that triad, then the error triad is replaced with the non-error triad.  This is the PEC technique of error recombination.  After all of this what we will be left with is 2 chromaton (or 3) that are either now identical or only vary in one of two ways.  The first way they can vary is if both have different errors in the same triad.  The second way is they both have different values in the same triad and neither was detected as an error.  In both of these cases the data from the third chromaton is used to fix these, unless the third chromaton has worse errors in those spots (3-bit error).  Even if the loser chromaton also has a 2-bit error in the same spot as a 2-bit error in the 2 winners, use the loser chromaton triad so there is convergence.  In the case that the 3rd loser chromaton has an 2-bit error in the triad that the 2 winner chromaton have no errors but different values then use the 2-bit error.  The reason for this is 98%25 of 2-bit errors will have been corrected correctly, but if no errors were detected but both winners hqve a different triad, chance that one of those is right is less than 50%25.  In the case the 3rd loser chromaton has a 3-bit error in a triad where the 2 winner chromaton have no errors but different values, choose one of the winner chromaton's triad.  Just choose the one in the first spot, that is the spot closest to the upper left of the kilochromaton. Now the 2 chromaton that were being compared (or 3 if still all tied) are as good as we can get them in this step.  If you choose a winner here, if one chromaton now has the least amount of errors/least serious errors, then report a soft error of [#1].  This is the most serious soft error in the kilochromaton level.  If there is no winner and we now have 2 chromaton with the same number/severity of errors, report a soft error of [#1] and bring these two to step 3 (skipping step 2 since we already did it), and discard the loser chromaton.  If there is 3 chromaton with the same amount/severity of errors, report soft error of [#1] and bring all three to step 3.%0a---%0a> If all 3 of the sums are different, what do we do?  Firstly I want to say that all 3 being different will be extremely rare since we already have perfect 1-bit error correction and roughly 98%25 2-bit error detection at the base level. But when it does rarely happen we can do something else so we don't loose all the data in the base chromaton just because of a couple errors.  What we will do is take the 2 chromaton with the fewest detected errors (or the least serious errors, 3-bit error more serious than 2-bit). If there is a 3-way tie, favor chromaton with fewest/less serious errors and most similar sums, if still a 3-way tie then compare and correct all 3 at the same time at the base chromaton triad level.  Anything that is different between the 2 (or 3), we check to see if there were any errors detected previously in those spots.  If in one of the chromaton one triad was detected as an error and the other chromaton does not have an error detected in that triad, then the error triad is replaced with the non-error triad.  This is the PEC technique of error recombination.  After all of this what we will be left with is 2 chromaton (or 3) that are either now identical or only vary in one of two ways.  The first way they can vary is if both have different errors in the same triad.  The second way is they both have different values in the same triad and neither was detected as an error.  In both of these cases the data from the third chromaton is used to fix these, unless the third chromaton has worse errors in those spots (3-bit error).  Even if the loser chromaton also has a 2-bit error in the same spot as a 2-bit error in the 2 winners, use the loser chromaton triad so there is convergence.  In the case that the 3rd loser chromaton has an 2-bit error in the triad that the 2 winner chromaton have no errors but different values then use the 2-bit error.  The reason for this is 98%25 of 2-bit errors will have been corrected correctly, but if no errors were detected but both winners hqve a different triad, chance that one of those is right is less than 50%25.  In the case the 3rd loser chromaton has a 3-bit error in a triad where the 2 winner chromaton have no errors but different values, choose one of the winner chromaton's triad.  Just choose the one in the first spot, that is the spot closest to the upper left of the kilochromaton. Now the 2 chromaton that were being compared (or 3 if still all tied) are as good as we can get them in this step.  If you choose a winner here, if one chromaton now has the least amount of errors/least serious errors, then report a soft error of [#1].  This is the most serious soft error in the kilochromaton level.  If there is no winner and we now have 2 chromaton with the same number/severity of errors, report a soft error of [#1] and bring these two to step 3 (skipping step 2 since we already did it), and discard the loser chromaton.  If there is 3 chromaton with the same amount/severity of errors, report soft error of [#1] and bring all three to step 3.%0a
host:1611955357=104.175.54.158
author:1611955281=
diff:1611955281:1611954645:=358c358%0a%3c If all 3 of the sums are different, what do we do?  Firstly I want to say that all 3 being different will be extremely rare since we already have perfect 1-bit error correction and roughly 98%25 2-bit error detection at the base level. But when it does rarely happen we can do something else so we don't loose all the data in the base chromaton just because of a couple errors.  What we will do is take the 2 chromaton with the fewest detected errors (or the least serious errors, 3-bit error more serious than 2-bit). If there is a 3-way tie, favor chromaton with fewest/less serious errors and most similar sums, if still a 3-way tie then compare and correct all 3 at the same time at the base chromaton triad level.  Anything that is different between the 2 (or 3), we check to see if there were any errors detected previously in those spots.  If in one of the chromaton one triad was detected as an error and the other chromaton does not have an error detected in that triad, then the error triad is replaced with the non-error triad.  This is the PEC technique of error recombination.  After all of this what we will be left with is 2 chromaton (or 3) that are either now identical or only vary in one of two ways.  The first way they can vary is if both have different errors in the same triad.  The second way is they both have different values in the same triad and neither was detected as an error.  In both of these cases the data from the third chromaton is used to fix these, unless the third chromaton has worse errors in those spots (3-bit error).  Even if the loser chromaton also has a 2-bit error in the same spot as a 2-bit error in the 2 winners, use the loser chromaton triad so there is convergence.  In the case that the 3rd loser chromaton has an 2-bit error in the triad that the 2 winner chromaton have no errors but different values then use the 2-bit error.  The reason for this is 98%25 of 2-bit errors will have been corrected correctly, but if no errors were detected but both winners hqve a different triad, chance that one of those is right is less than 50%25.  In the case the 3rd loser chromaton has a 3-bit error in a triad where the 2 winner chromaton have no errors but different values, choose one of the winner chromaton's triad.  Just choose the one in the first spot, that is the spot closest to the upper left of the kilochromaton. Now the 2 chromaton that were being compared (or 3 if still all tied) are as good as we can get them in this step.  If you choose a winner here, if one chromaton now has the least amount of errors/least serious errors, then report a soft error of [#1].  This is the most serious soft error in the kilochromaton level.  If there is no winner and we now have 2 chromaton with the same number/severity of errors, report a soft error of [#1] and bring these two to step 3 (skipping step 2 since we already did it), and discard the loser chromaton.  If there is 3 chromaton with the same amount/severity of errors, report soft error of [#1] and bring all three to step 3.%0a---%0a> If all 3 of the sums are different, what do we do?  Firstly I want to say that all 3 being different will be extremely rare since we already have perfect 1-bit error correction and roughly 98%25 2-bit error detection at the base level. But when it does rarely happen we can do something else so we don't loose all the data in the base chromaton just because of a couple errors.  What we will do is take the 2 chromaton with the fewest detected errors (or the least serious errors, 3-bit error more serious than 2-bit). If there is a 3-way tie, favor chromaton with fewest/less serious errors and most similar sums, if still a 3-way tie then compare and correct all 3 at the same time at the base chromaton triad level.  Anything that is different between the 2 (or 3), we check to see if there were any errors detected previously in those spots.  If in one of the chromaton one triad was detected as an error and the other chromaton does not have an error detected in that triad, then the error triad is replaced with the non-error triad.  This is the PEC technique of error recombination.  After all of this what we will be left with is 2 chromaton (or 3) that are either now identical or only vary in one of two ways.  The first way they can vary is if both have different errors in the same triad.  The second way is they both have different values in the same triad and neither was detected as an error.  In both of these cases the data from the third chromaton is used to fix these, unless the third chromaton has worse errors in those spots (3-bit error).  Even if the loser chromaton also has a 2-bit error in the same spot as a 2-bit error in the 2 winners, use the loser chromaton triad so there is convergence.  Now the 2 chromaton that were being compared (or 3 if still all tied) are as good as we can get them in this step.  If you choose a winner here, if one chromaton now has the least amount of errors/least serious errors then report a soft error of [#1].  This is the most serious soft error in the kilochromaton level.  If there is no winner and we now have 2 chromaton with the same number/severity of errors, report a soft error of [#1] and bring these two to step 3 (skipping step 2 since we already did it), and discard the loser chromaton.  If there is 3 chromaton with the same amount/severity of errors, report soft error of [#1] and bring all three to step 3.%0a
host:1611955281=104.175.54.158
author:1611954645=
diff:1611954645:1611954394:=354c354%0a%3c Kilochromaton (and higher) gives us another check of the lower chromaton we are reading.  At this level we use "sum" of the lower level.  So first we decode and [[#v3error|error correct all base level]] chromaton.  Then we sum up all the numbers contained in each chromaton and this is the sum, one for each chromaton.  In kilochromaton level we compare the three sums for each replicate chromaton.  If all 3 are the same then we verified that everything is perfect (we have 16 base-4 numbers so the chance that we randomly got the sums to equal yet actually be wrong is 1/48 × 1/48 × 1/48 = 9×10^(-6) or 9 times in 1 million).  But for 2 of them to randomly give the same sum wrongly is 1/48 * (1-(47/48)*(47/48)) = 0.086%25 or 859 times in a million.  So since we will accept if 2 of them add to the same sum, we will have a %25 correct - error correction rate.  This not only corrects 1-bit or 2-bit errors at this level, this corrects up to 48-bit errors!  An entire base chromaton could be wrong and it could be fixed at this level. If 2 or 3 replicates have the same sum, go to [[#samesum|this step]] next. If not, go to the below step.%0a---%0a> Kilochromaton (and higher) gives us another check of the lower chromaton we are reading.  At this level we use "sum" of the lower level.  So first we decode and [[#v3error|error correct all base level]] chromaton.  Then we sum up all the numbers contained in each chromaton and this is the sum, one for each chromaton.  In kilochromaton level we compare the three sums for each replicate chromaton.  If all 3 are the same then we verified that everything is perfect (we have 16 base-4 numbers so the chance that we randomly got the sums to equal yet actually be wrong is 1/48 × 1/48 × 1/48 = 3.8×10^(-6) or times in 1 million).  But for 2 of them to randomly give the same sum wrongly is 1/48 * (1-(47/48)*(47/48)) = 0.0%25 or  times in a million.  So since we will accept if 2 of them add to the same sum, we will have a %25 correct - error correction rate.  This not only corrects 1-bit or 2-bit errors at this level, this corrects up to 48-bit errors!  An entire base chromaton could be wrong and it could be fixed at this level. If 2 or 3 replicates have the same sum, go to [[#samesum|this step]] next. If not, go to the below step.%0a
host:1611954645=104.175.54.158
author:1611954394=
diff:1611954394:1611936389:=354c354%0a%3c Kilochromaton (and higher) gives us another check of the lower chromaton we are reading.  At this level we use "sum" of the lower level.  So first we decode and [[#v3error|error correct all base level]] chromaton.  Then we sum up all the numbers contained in each chromaton and this is the sum, one for each chromaton.  In kilochromaton level we compare the three sums for each replicate chromaton.  If all 3 are the same then we verified that everything is perfect (we have 16 base-4 numbers so the chance that we randomly got the sums to equal yet actually be wrong is 1/48 × 1/48 × 1/48 = 3.8×10^(-6) or times in 1 million).  But for 2 of them to randomly give the same sum wrongly is 1/48 * (1-(47/48)*(47/48)) = 0.0%25 or  times in a million.  So since we will accept if 2 of them add to the same sum, we will have a %25 correct - error correction rate.  This not only corrects 1-bit or 2-bit errors at this level, this corrects up to 48-bit errors!  An entire base chromaton could be wrong and it could be fixed at this level. If 2 or 3 replicates have the same sum, go to [[#samesum|this step]] next. If not, go to the below step.%0a---%0a> Kilochromaton (and higher) gives us another check of the lower chromaton we are reading.  At this level we use "sum" of the lower level.  So first we decode and [[#v3error|error correct all base level]] chromaton.  Then we sum up all the numbers contained in each chromaton and this is the sum, one for each chromaton.  In kilochromaton level we compare the three sums for each replicate chromaton.  If all 3 are the same then we verified that everything is perfect (we have 16 base-4 numbers so the chance that we randomly got the sums to equal yet actually be wrong is 1/64 × 1/64 × 1/64 = 3.8×10^(-6) or 4 times in 1 million).  But for 2 of them to randomly give the same sum wrongly is 1/64 * (1-(63/64)*(63/64)) = 0.049%25 or 484 times in a million.  So since we will accept if 2 of them add to the same sum, we will have a 99.95%25 correct - error correction rate.  This not only corrects 1-bit or 2-bit errors at this level, this corrects up to 48-bit errors!  An entire base chromaton could be wrong and it could be fixed at this level. If 2 or 3 replicates have the same sum, go to [[#samesum|this step]] next. If not, go to the below step.%0a
host:1611954394=104.175.54.158
author:1611936389=
diff:1611936389:1611936282:=358c358%0a%3c If all 3 of the sums are different, what do we do?  Firstly I want to say that all 3 being different will be extremely rare since we already have perfect 1-bit error correction and roughly 98%25 2-bit error detection at the base level. But when it does rarely happen we can do something else so we don't loose all the data in the base chromaton just because of a couple errors.  What we will do is take the 2 chromaton with the fewest detected errors (or the least serious errors, 3-bit error more serious than 2-bit). If there is a 3-way tie, favor chromaton with fewest/less serious errors and most similar sums, if still a 3-way tie then compare and correct all 3 at the same time at the base chromaton triad level.  Anything that is different between the 2 (or 3), we check to see if there were any errors detected previously in those spots.  If in one of the chromaton one triad was detected as an error and the other chromaton does not have an error detected in that triad, then the error triad is replaced with the non-error triad.  This is the PEC technique of error recombination.  After all of this what we will be left with is 2 chromaton (or 3) that are either now identical or only vary in one of two ways.  The first way they can vary is if both have different errors in the same triad.  The second way is they both have different values in the same triad and neither was detected as an error.  In both of these cases the data from the third chromaton is used to fix these, unless the third chromaton has worse errors in those spots (3-bit error).  Even if the loser chromaton also has a 2-bit error in the same spot as a 2-bit error in the 2 winners, use the loser chromaton triad so there is convergence.  Now the 2 chromaton that were being compared (or 3 if still all tied) are as good as we can get them in this step.  If you choose a winner here, if one chromaton now has the least amount of errors/least serious errors then report a soft error of [#1].  This is the most serious soft error in the kilochromaton level.  If there is no winner and we now have 2 chromaton with the same number/severity of errors, report a soft error of [#1] and bring these two to step 3 (skipping step 2 since we already did it), and discard the loser chromaton.  If there is 3 chromaton with the same amount/severity of errors, report soft error of [#1] and bring all three to step 3.%0a---%0a> If all 3 of the sums are different, what do we do?  Firstly I want to say that all 3 being different will be extremely rare since we already have perfect 1-bit error correction and roughly 98%25 2-bit error detection at the base level. But when it does rarely happen we can do something else so we don't loose all the data in the base chromaton just because of a couple errors.  What we will do is take the 2 chromaton with the fewest detected errors (or the least serious errors, 3-bit error more serious than 2-bit). If there is a 3-way tie, favor chromaton with fewest/less serious errors and most similar sums, if still a 3-way tie then compare and correct all 3 at the same time at the base chromaton triad level.  Anything that is different between the 2 (or 3), we check to see if there were any errors detected previously in those spots.  If in one of the chromaton one triad was detected as an error and the other chromaton does not have an error detected in that triad, then the error triad is replaced with the non-error triad.  This is the PEC technique of error recombination.  After all of this what we will be left with is 2 chromaton (or 3) that are either now identical or only vary in one of two ways.  The first way they can vary is if both have different errors in the same triad.  The second way is they both have different values in the same triad and neither was detected as an error.  In both of these cases the data from the third chromaton is used to fix these, unless the third chromaton has worse errors in those spots (3-bit error).  Even if the loser chromaton also has an error in the same spot as the 2 winners, use the loser chromaton triad so there is convergence.  Now the 2 chromaton that were being compared (or 3 if still all tied) are as good as we can get them in this step.  If you choose a winner here, if one chromaton now has the least amount of errors/least serious errors then report a soft error of [#1].  This is the most serious soft error in the kilochromaton level.  If there is no winner and we now have 2 chromaton with the same number/severity of errors, report a soft error of [#1] and bring these two to step 3 (skipping step 2 since we already did it), and discard the loser chromaton.  If there is 3 chromaton with the same amount/severity of errors, report soft error of [#1] and bring all three to step 3.%0a
host:1611936389=104.175.54.158
author:1611936282=
diff:1611936282:1611936134:=358c358%0a%3c If all 3 of the sums are different, what do we do?  Firstly I want to say that all 3 being different will be extremely rare since we already have perfect 1-bit error correction and roughly 98%25 2-bit error detection at the base level. But when it does rarely happen we can do something else so we don't loose all the data in the base chromaton just because of a couple errors.  What we will do is take the 2 chromaton with the fewest detected errors (or the least serious errors, 3-bit error more serious than 2-bit). If there is a 3-way tie, favor chromaton with fewest/less serious errors and most similar sums, if still a 3-way tie then compare and correct all 3 at the same time at the base chromaton triad level.  Anything that is different between the 2 (or 3), we check to see if there were any errors detected previously in those spots.  If in one of the chromaton one triad was detected as an error and the other chromaton does not have an error detected in that triad, then the error triad is replaced with the non-error triad.  This is the PEC technique of error recombination.  After all of this what we will be left with is 2 chromaton (or 3) that are either now identical or only vary in one of two ways.  The first way they can vary is if both have different errors in the same triad.  The second way is they both have different values in the same triad and neither was detected as an error.  In both of these cases the data from the third chromaton is used to fix these, unless the third chromaton has worse errors in those spots (3-bit error).  Even if the loser chromaton also has an error in the same spot as the 2 winners, use the loser chromaton triad so there is convergence.  Now the 2 chromaton that were being compared (or 3 if still all tied) are as good as we can get them in this step.  If you choose a winner here, if one chromaton now has the least amount of errors/least serious errors then report a soft error of [#1].  This is the most serious soft error in the kilochromaton level.  If there is no winner and we now have 2 chromaton with the same number/severity of errors, report a soft error of [#1] and bring these two to step 3 (skipping step 2 since we already did it), and discard the loser chromaton.  If there is 3 chromaton with the same amount/severity of errors, report soft error of [#1] and bring all three to step 3.%0a---%0a> If all 3 of the sums are different, what do we do?  Firstly I want to say that all 3 being different will be extremely rare since we already have perfect 1-bit error correction and roughly 98%25 2-bit error detection at the base level. But when it does rarely happen we can do something else so we don't loose all the data in the base chromaton just because of a couple errors.  What we will do is take the 2 chromaton with the fewest detected errors (or the least serious errors, 3-bit error more serious than 2-bit). If there is a 3-way tie, favor chromaton with fewest/less serious errors and most similar sums, if still a 3-way tie then compare and correct all 3 at the same time at the base chromaton triad level.  Anything that is different between the 2 (or 3), we check to see if there were any errors detected previously in those spots.  If in one of the chromaton one triad was detected as an error and the other chromaton does not have an error detected in that triad, then the error triad is replaced with the non-error triad.  This is the PEC technique of error recombination.  After all of this what we will be left with is 2 chromaton that are either now identical or only vary in one of two ways.  The first way they can vary is if both have different errors in the same triad.  The second way is they both have different values in the same triad and neither was detected as an error.  In both of these cases the data from the third chromaton is used to fix these, unless the third chromaton has worse errors in those spots (3-bit error).  Even if the loser chromaton also has an error in the same spot as the 2 winners, use the loser chromaton triad so there is convergence.  Now the 2 chromaton that were being compared (or 3 if still all tied) are as good as we can get them in this step.  If you choose a winner here, if one chromaton now has the least amount of errors/least serious errors then report a soft error of [#1].  This is the most serious soft error in the kilochromaton level.  If there is no winner and we now have 2 chromaton with the same number/severity of errors, report a soft error of [#1] and bring these two to step 3 (skipping step 2 since we already did it), and discard the loser chromaton.  If there is 3 chromaton with the same amount/severity of errors, report soft error of [#1] and bring all three to step 3.%0a
host:1611936282=104.175.54.158
author:1611936134=
diff:1611936134:1611935626:=358c358%0a%3c If all 3 of the sums are different, what do we do?  Firstly I want to say that all 3 being different will be extremely rare since we already have perfect 1-bit error correction and roughly 98%25 2-bit error detection at the base level. But when it does rarely happen we can do something else so we don't loose all the data in the base chromaton just because of a couple errors.  What we will do is take the 2 chromaton with the fewest detected errors (or the least serious errors, 3-bit error more serious than 2-bit). If there is a 3-way tie, favor chromaton with fewest/less serious errors and most similar sums, if still a 3-way tie then compare and correct all 3 at the same time at the base chromaton triad level.  Anything that is different between the 2 (or 3), we check to see if there were any errors detected previously in those spots.  If in one of the chromaton one triad was detected as an error and the other chromaton does not have an error detected in that triad, then the error triad is replaced with the non-error triad.  This is the PEC technique of error recombination.  After all of this what we will be left with is 2 chromaton that are either now identical or only vary in one of two ways.  The first way they can vary is if both have different errors in the same triad.  The second way is they both have different values in the same triad and neither was detected as an error.  In both of these cases the data from the third chromaton is used to fix these, unless the third chromaton has worse errors in those spots (3-bit error).  Even if the loser chromaton also has an error in the same spot as the 2 winners, use the loser chromaton triad so there is convergence.  Now the 2 chromaton that were being compared (or 3 if still all tied) are as good as we can get them in this step.  If you choose a winner here, if one chromaton now has the least amount of errors/least serious errors then report a soft error of [#1].  This is the most serious soft error in the kilochromaton level.  If there is no winner and we now have 2 chromaton with the same number/severity of errors, report a soft error of [#1] and bring these two to step 3 (skipping step 2 since we already did it), and discard the loser chromaton.  If there is 3 chromaton with the same amount/severity of errors, report soft error of [#1] and bring all three to step 3.%0a---%0a> If all 3 of the sums are different, what do we do?  Firstly I want to say that all 3 being different will be extremely rare since we already have perfect 1-bit error correction and roughly 98%25 2-bit error detection at the base level. But when it does rarely happen we can do something else so we don't loose all the data in the base chromaton just because of a couple errors.  What we will do is take the 2 chromaton with the fewest detected errors (or the least serious errors, 3-bit error more serious than 2-bit). If there is a 3-way tie, favor chromaton with fewest/less serious errors and most similar sums, if still a 3-way tie then compare and correct all 3 at the same time and then compare those two (or 3 if all tied) at the base chromaton triad level.  Anything that is different between the 2 (or 3), we check to see if there were any errors detected previously in those spots.  If in one of the chromaton one triad was detected as an error and the other chromaton does not have an error detected in that triad, then the error triad is replaced with the non-error triad.  This is the PEC technique of error recombination.  After all of this what we will be left with is 2 chromaton that are either now identical or only vary in one of two ways.  The first way they can vary is if both have different errors in the same triad.  The second way is they both have different values in the same triad and neither was detected as an error.  In both of these cases the data from the third chromaton is used to fix these, unless the third chromaton has worse errors in those spots (3-bit error).  Even if the loser chromaton also has an error in the same spot as the 2 winners, use the loser chromaton triad so there is convergence.  Now the 2 chromaton that were being compared (or 3 if still all tied) are as good as we can get them in this step.  If you choose a winner here, if one chromaton now has the least amount of errors/least serious errors then report a soft error of [#1].  This is the most serious soft error in the kilochromaton level.  If there is no winner and we now have 2 chromaton with the same number/severity of errors, report a soft error of [#1] and bring these two to step 3 (skipping step 2 since we already did it), and discard the loser chromaton.  If there is 3 chromaton with the same amount/severity of errors, report soft error of [#1] and bring all three to step 3.%0a
host:1611936134=104.175.54.158
author:1611935626=
diff:1611935626:1611901842:=325c325%0a%3c The chance a 3-bit error is undetected and looks like a 2-bit error or 1-bit error or no error is 70.4%25, since at least one needs to be in an allowable position.  Using the below calculation, the chance of it looking like a 2-bit error exactly, is 70.4-11.2 = 59.2%25 chance.%0a---%0a> The chance a 3-bit error is undetected and looks like a 2-bit error or 1-bit error or no error is 70.4%25, since at least one needs to be in an allowable position.  Using the below calculation the chance of it looking like a 2-bit error exactly, is 70.4-11.2 = 59.2%25 chance.%0a
host:1611935626=104.175.54.158
author:1611901842=
diff:1611901842:1611901632:=358c358%0a%3c If all 3 of the sums are different, what do we do?  Firstly I want to say that all 3 being different will be extremely rare since we already have perfect 1-bit error correction and roughly 98%25 2-bit error detection at the base level. But when it does rarely happen we can do something else so we don't loose all the data in the base chromaton just because of a couple errors.  What we will do is take the 2 chromaton with the fewest detected errors (or the least serious errors, 3-bit error more serious than 2-bit). If there is a 3-way tie, favor chromaton with fewest/less serious errors and most similar sums, if still a 3-way tie then compare and correct all 3 at the same time and then compare those two (or 3 if all tied) at the base chromaton triad level.  Anything that is different between the 2 (or 3), we check to see if there were any errors detected previously in those spots.  If in one of the chromaton one triad was detected as an error and the other chromaton does not have an error detected in that triad, then the error triad is replaced with the non-error triad.  This is the PEC technique of error recombination.  After all of this what we will be left with is 2 chromaton that are either now identical or only vary in one of two ways.  The first way they can vary is if both have different errors in the same triad.  The second way is they both have different values in the same triad and neither was detected as an error.  In both of these cases the data from the third chromaton is used to fix these, unless the third chromaton has worse errors in those spots (3-bit error).  Even if the loser chromaton also has an error in the same spot as the 2 winners, use the loser chromaton triad so there is convergence.  Now the 2 chromaton that were being compared (or 3 if still all tied) are as good as we can get them in this step.  If you choose a winner here, if one chromaton now has the least amount of errors/least serious errors then report a soft error of [#1].  This is the most serious soft error in the kilochromaton level.  If there is no winner and we now have 2 chromaton with the same number/severity of errors, report a soft error of [#1] and bring these two to step 3 (skipping step 2 since we already did it), and discard the loser chromaton.  If there is 3 chromaton with the same amount/severity of errors, report soft error of [#1] and bring all three to step 3.%0a---%0a> If all 3 of the sums are different, what do we do?  Firstly I want to say that all 3 being different will be extremely rare since we already have perfect 1-bit error correction and roughly 98%25 2-bit error detection at the base level. But when it does rarely happen we can do something else so we don't loose all the data in the base chromaton just because of a couple errors.  What we will do is take the 2 chromaton with the fewest detected errors (or the least serious errors, 3-bit error more serious than 2-bit). If there is a 3-way tie, favor chromaton with fewest/less serious errors and most similar sums, if still a 3-way tie then compare and correct all 3 at the same time) and then compare those two (or 3 if all tied) at the base chromaton triad level.  Anything that is different between the 2 (or 3), we check to see if there were any errors detected previously in those spots.  If in one of the chromaton one triad was detected as an error and the other chromaton does not have an error detected in that triad, then the error triad is replaced with the non-error triad.  This is the PEC technique of error recombination.  After all of this what we will be left with is 2 chromaton that are either now identical or only vary in one of two ways.  The first way they can vary is if both have different errors in the same triad.  The second way is they both have different values in the same triad and neither was detected as an error.  In both of these cases the data from the third chromaton is used to fix these, unless the third chromaton has worse errors in those spots (3-bit error).  Even if the loser chromaton also has an error in the same spot as the 2 winners, use the loser chromaton triad so there is convergence.  Now the 2 chromaton that were being compared (or 3 if still all tied) are as good as we can get them in this step.  If you choose a winner here, if one chromaton now has the least amount of errors/least serious errors then report a soft error of [#1].  This is the most serious soft error in the kilochromaton level.  If there is no winner and we now have 2 chromaton with the same number/severity of errors, report a soft error of [#1] and bring these two to step 3 (skipping step 2 since we already did it), and discard the loser chromaton.  If there is 3 chromaton with the same amount/severity of errors, report soft error of [#1] and bring all three to step 3.%0a
host:1611901842=104.175.54.158
author:1611901632=
diff:1611901632:1611901544:=351c351%0a%3c The farther the error correction on this level makes it, the less severe of an error.  The lower the error number, the more severe the error.  So an error at step 1 is more severe than an error at step 5 for example.  This will help us in megachromaton error correction.%0a---%0a> The farther the error correction on this level makes it, the less severe of an error.  The lower the error number, the more severe the error.  So an error at step 1 is more severe than an error at step 7 for example.  This will help us in megachromaton error correction.%0a
host:1611901632=104.175.54.158
author:1611901544=
diff:1611901544:1611901462:=393c393%0a%3c If you are here, then chances are at least 2 of your 3 replicate chromaton are identical.  Congratulations!  For the final check, each and every value is compared between eachother.  We already have the 4x4 matrix set-up for each chromaton and each of the 16 values are compared between eachother.  If they all/both match, great, select the [[#cv3number|first chromaton in the triad]] of one of the matching replicates as the winner, the replicate closest to the upper left of the kilochromaton, with no error reported!  Simply report a "0" if all 3 replicates matched, and a "1" if 2 of the replicates matched. If none of the remaining replicates match, we again just choose the first replicate, the one closest to the upper left of the kilochromaton as the winner and report error [#5].%0a---%0a> If you are here, then chances are at least 2 of your 3 replicate chromaton are identical.  Congratulations!  For the final check, each and every value is compared between eachother.  We already have the 4x4 matrix set-up for each chromaton and each of the 16 values are compared between eachother.  If they all/both match, great, select the [[#cv3number|first chromaton in the triad]] of one of the mat hing replicates as the winner, the replicate closest to the upper left of the chromaton, with no error reported!  Simply report a "0" if all 3 replicates matched, and a "1" if 2 of the replicates matched. If none of the remaining replicates match, we again just choose the first replicate, the one closest to the upper left of the kilochromaton as the winner and report error [#5].%0a
host:1611901544=104.175.54.158
author:1611901462=
diff:1611901462:1611901387:=393c393,399%0a%3c If you are here, then chances are at least 2 of your 3 replicate chromaton are identical.  Congratulations!  For the final check, each and every value is compared between eachother.  We already have the 4x4 matrix set-up for each chromaton and each of the 16 values are compared between eachother.  If they all/both match, great, select the [[#cv3number|first chromaton in the triad]] of one of the mat hing replicates as the winner, the replicate closest to the upper left of the chromaton, with no error reported!  Simply report a "0" if all 3 replicates matched, and a "1" if 2 of the replicates matched. If none of the remaining replicates match, we again just choose the first replicate, the one closest to the upper left of the kilochromaton as the winner and report error [#5].%0a---%0a> If you are here, then chances are at least 2 of your 3 replicate chromaton are identical.  Congratulations!  For the final check, each and every value is compared between eachother.  We already have the 4x4 matrix set-up for each chromaton and each of the 16 values are compared between eachother.  If they all/both match, great, select the [[#cv3number|first chromaton in the triad]] of one of the mat hing replicates as the winner, the replicate closest to the upper left of the chromaton, with no error reported!  Simply report a "0" if all 3 replicates matched, and a "1" if 2 of the replicates matched. If none of the remaining replicates match, we go to the next step, step 6.  %0a> %0a> %0a> %0a> %0a> %0a> %0a
host:1611901462=104.175.54.158
author:1611901387=
diff:1611901387:1611901366:=398a399,400%0a> !!!!!6. All else%0a> If all the remaining have the same number and severity of errors, just pick the first chromaton, basically the chromaton closest to the upper left of the kilochromaton and report a soft error of [#7].%0a
host:1611901387=104.175.54.158
author:1611901366=
diff:1611901366:1611901092:=393c393%0a%3c If you are here, then chances are at least 2 of your 3 replicate chromaton are identical.  Congratulations!  For the final check, each and every value is compared between eachother.  We already have the 4x4 matrix set-up for each chromaton and each of the 16 values are compared between eachother.  If they all/both match, great, select the [[#cv3number|first chromaton in the triad]] of one of the mat hing replicates as the winner, the replicate closest to the upper left of the chromaton, with no error reported!  Simply report a "0" if all 3 replicates matched, and a "1" if 2 of the replicates matched. If none of the remaining replicates match, we go to the next step, step 6.  %0a---%0a> If you are here, then chances are at least 2 of your 3 replicate chromaton are identical.  Congratulations!  For the final check, each and every value is compared between eachother.  We already have the 4x4 matrix set-up for each chromaton and each of the 16 values are compared between eachother.  If they all/both match, great, select the [[#cv3number|first chromaton in the triad]] as the winner, the replicate closest to the upper left of the chromaton, with no error reported!  Simply report a "0" if all 3 replicates matched, and a "1" if 2 of the replicates matched. If they do not match, we go to the next step, step 6.  %0a
host:1611901366=104.175.54.158
author:1611901092=
diff:1611901092:1611900972:=389c389%0a%3c Next the rows are added and the columns added.  Mod 4 means that the sum is then divided by 4 and the remainder is reported.  Now these remainders are compared between the 2 (or 3) replicate chromaton.  If there are 3 chromaton left and 2 match and one doesn't, then discard the non-matching.  If 2 or 3 are remaining and they agree then great, go to next step with all of the agreeing replicates.  If they do not agree, choose the one with the average checksum closest to 1.5.  To determine this you take all 8 checksums, add them together, divide by 8, and call that "answer".  Then take (1.5-answer)^2 and compare this value to the other chromaton's value.  The smaller number wins.  If they are the same, go to next step.  If there is only one winner at this step, report a soft error of [#4].%0a---%0a> Next the rows are added and the columns added.  Mod 4 means that the sum is then divided by 4 and the remainder is reported.  Now these remainders are compared between the 2 (or 3) replicate chromaton.  If there are 3 chromaton left and 2 match and one doesn't, then discard the non-matching.  If 2 are remaining and they agree then great, go to next step.  If they do not agree, choose the one with the average checksum closest to 1.5.  To determine this you take all 8 checksums, add them together, divide by 8, and call that "answer".  Then take (1.5-answer)^2 and compare this value to the other chromaton's value.  The smaller number wins.  If they are the same, go to next step.  If there is only one winner at this step, report a soft error of [#4].%0a
host:1611901092=104.175.54.158
author:1611900972=
diff:1611900972:1611900673:=382c382%0a%3c A parity check is a count of how many times a certain value showed up in our chromaton. Add up the number of each type of triad, our base-4 numbers. So add up the number of each "0"s, the "1"s, the "2"s, and the "3"s. And compare the results across the remaining chromaton.  This would be something like chromaton1 contains 5x "0", 10x "1", 1x "2", 0x "3".  Now if chromaton2 matches chromaton1 parity check but chromaton3 has a different parity check, then we can exclude chromaton3.  If all remaining replicate chromaton have different parity checks, then choose the one with the most even distribution of numbers. We can use a sort of "r^2 method". In our case there are 16 numbers so an even distribution would be 4x of each 0,1,2,3. Our r^2 method would subtract our actual number by 4 and then square the value.  So for our sample set it would be (5-4)^2 + (10-4)^2 + (1-4)^2 + (0-4)^2.  Now choose the one with the lowest value of this test.  After this test the only errors that would be matching is if all the right values were included in both chromaton, but the location of the values were different.  If a winner is chosen here, which means one has a lower parity check than the other 2, report a soft error of [#3].  If 2 or 3 of the replicate chromaton have the same parity check or two are tied with the lowest parity check, go to step 4 after you discard any replicates without matching parity checks.%0a---%0a> A parity check is a count of how many times a certain value showed up in our chromaton. Add up the number of each type of triad, our base-4 numbers. So add up the number of each "0"s, the "1"s, the "2"s, and the "3"s. And compare the results across the remaining chromaton.  This would be something like chromaton1 contains 5x "0", 10x "1", 1x "2", 0x "3".  Now if chromaton2 matches chromaton1 parity check but chromaton3 has a different parity check, then we can exclude chromaton3.  If all remaining replicate chromaton have different parity checks, then choose the one with the most even distribution of numbers. We can use a sort of "r^2 method". In our case there are 16 numbers so an even distribution would be 4x of each 0,1,2,3. Our r^2 method would subtract our actual number by 4 and then square the value.  So for our sample set it would be (5-4)^2 + (10-4)^2 + (1-4)^2 + (0-4)^2.  Now choose the one with the lowest value of this test.  After this test the only errors that would be matching is if all the right values were included in both chromaton, but the location of the values were different.  If a winner is chosen here report a soft error of [#3].  If 2 or 3 of the replicate chromaton have the same parity check go to step 4.%0a
host:1611900972=104.175.54.158
author:1611900673=
diff:1611900673:1611900339:=375c375%0a%3c But if a winner was not determined and there are two or three with the same amount/severity of errors, then do recombination as well.  Compare the two with the same amount of errors and the same sums (or all three in the case they all are tied) and see if you can correct any using the data from the other.  So if one triad that gave an error has a match in the other replicate chromaton with no error, use the error free version.  You can use the third loser replicate (the one with more errors) to fix any errors you couldn't fix using only the winner replicates.  After this discard the loser replicate if there is one. If now one replicate has less errors/severity than the others you have a winner and continue to [[#recombwinner|"if there is a winner"]] section.  If you still have the two or three replicates with that had the same sum in the previous step tied with number/severity of errors even after recombination, continue to step 3 after discarding any loser replicate chromaton.%0a---%0a> But if a winner was not determined and there are two or three with the same amount/severity of errors, then do recombination as well.  Compare the two with the same amount of errors and the same sums (or all three in the case they all are tied) and see if you can correct any using the data from the other.  So if one triad that gave an error has a match in the other replicate chromaton with no error, use the error free version.  You can use the third loser replicate to fix any errors you couldn't fix using only the winner replicates.  After this discard the loser replicate if there is one. If now one replicate has less errors/severity than the others you have a winner and continue to [[#recombwinner|"if there is a winner"]] section.  If you still have the two or three replicates with that had the same sum in the previous step tied with number/severity of errors even after recombination, continue to step 3 after discarding any loser replicate chromaton.%0a
host:1611900673=104.175.54.158
author:1611900339=
diff:1611900339:1611900231:=363c363%0a%3c If two or three of the replicates have the same sum, we go to the next step, step 2, with all the chromaton replicates, even if one doesn't have the same sum.  We will get rid of the one without the same sum in step 2 after we use it for recombination.%0a---%0a> If two or three of the replicates have the same sum, we go to the next step, step 2, with all the chromaton replicates, even if one doesn't have the same sum.  We will get rid of the one without the same sum in step 3 after we use it for recombination.%0a
host:1611900339=104.175.54.158
author:1611900231=
diff:1611900231:1611899963:=363c363%0a%3c If two or three of the replicates have the same sum, we go to the next step, step 2, with all the chromaton replicates, even if one doesn't have the same sum.  We will get rid of the one without the same sum in step 3 after we use it for recombination.%0a---%0a> If two or three of the replicates have the same sum, we go to the next step, step 2, with all the chromaton replicates, even if one doesn't have the same sum.%0a
host:1611900231=104.175.54.158
author:1611899963=
diff:1611899963:1611899846:=363c363%0a%3c If two or three of the replicates have the same sum, we go to the next step, step 2, with all the chromaton replicates, even if one doesn't have the same sum.%0a---%0a> If two or three of the replicates have the same sum, we go to the next step, step 2, with all the chromaton replicates including the one without the same sum if applicable.%0a
host:1611899963=104.175.54.158
author:1611899846=
diff:1611899846:1611899724:=358c358%0a%3c If all 3 of the sums are different, what do we do?  Firstly I want to say that all 3 being different will be extremely rare since we already have perfect 1-bit error correction and roughly 98%25 2-bit error detection at the base level. But when it does rarely happen we can do something else so we don't loose all the data in the base chromaton just because of a couple errors.  What we will do is take the 2 chromaton with the fewest detected errors (or the least serious errors, 3-bit error more serious than 2-bit). If there is a 3-way tie, favor chromaton with fewest/less serious errors and most similar sums, if still a 3-way tie then compare and correct all 3 at the same time) and then compare those two (or 3 if all tied) at the base chromaton triad level.  Anything that is different between the 2 (or 3), we check to see if there were any errors detected previously in those spots.  If in one of the chromaton one triad was detected as an error and the other chromaton does not have an error detected in that triad, then the error triad is replaced with the non-error triad.  This is the PEC technique of error recombination.  After all of this what we will be left with is 2 chromaton that are either now identical or only vary in one of two ways.  The first way they can vary is if both have different errors in the same triad.  The second way is they both have different values in the same triad and neither was detected as an error.  In both of these cases the data from the third chromaton is used to fix these, unless the third chromaton has worse errors in those spots (3-bit error).  Even if the loser chromaton also has an error in the same spot as the 2 winners, use the loser chromaton triad so there is convergence.  Now the 2 chromaton that were being compared (or 3 if still all tied) are as good as we can get them in this step.  If you choose a winner here, if one chromaton now has the least amount of errors/least serious errors then report a soft error of [#1].  This is the most serious soft error in the kilochromaton level.  If there is no winner and we now have 2 chromaton with the same number/severity of errors, report a soft error of [#1] and bring these two to step 3 (skipping step 2 since we already did it), and discard the loser chromaton.  If there is 3 chromaton with the same amount/severity of errors, report soft error of [#1] and bring all three to step 3.%0a---%0a> If all 3 of the sums are different, what do we do?  Firstly I want to say that all 3 being different will be extremely rare since we already have perfect 1-bit error correction and roughly 98%25 2-bit error detection at the base level. But when it does rarely happen we can do something else so we don't loose all the data in the base chromaton just because of a couple errors.  What we will do is take the 2 chromaton with the fewest detected errors (or the least serious errors, 3-bit error more serious than 2-bit). If there is a 3-way tie, favor chromaton with fewest/less serious errors and most similar sums, if still a 3-way tie then compare and correct all 3 at the same time) and then compare those two (or 3 if all tied) at the base chromaton triad level.  Anything that is different between the 2 (or 3), we check to see if there were any errors detected previously in those spots.  If in one of the chromaton one triad was detected as an error and the other chromaton does not have an error detected in that triad, then the error triad is replaced with the non-error triad.  This is the PEC technique of error recombination.  After all of this what we will be left with is 2 chromaton that are either now identical or only vary in one of two ways.  The first way they can vary is if both have different errors in the same triad.  The second way is they both have different values in the same triad and neither was detected as an error.  In both of these cases the data from the third chromaton is used to fix these, unless the third chromaton has worse errors in those spots (3-bit error).  Even if the loser chromaton also has an error in the same spot as the 2 winners, use the loser chromaton triad so there is convergence.  Now the 2 chromaton that were being compared (or 3 if still all tied) are as good as we can get them in this step.  If you choose a winner here, if one chromaton now has the least amount of errors/least serious errors then report a soft error of [#1].  This is the most serious soft error in the kilochromaton level.  If there is no winner and we now have 2 chromaton with the same number/severity of errors, report a soft error of [#1] and these two bring them to step 3 (skipping step 32 since we already did it), and discard the loser chromaton.  If there is 3 chromaton with the same amount/severity of errors, report soft error of [#1] and bring all three to step 3.%0a
host:1611899846=104.175.54.158
author:1611899724=
diff:1611899724:1611899705:=399c399%0a%3c !!!!!6. All else%0a---%0a> !!!!!7. All else%0a
host:1611899724=104.175.54.158
author:1611899705=
diff:1611899705:1611899312:=394a395,396%0a> !!!!!6. Fewest errors%0a> Favor each triad that has fewest detected errors at the base level and/or the least serious errors.  If there is one best, then choose it as the winner and report a soft error of [#6].  If there is no winner, then carry on the remaining chromaton to step 7.%0a
host:1611899705=104.175.54.158
author:1611899312=
diff:1611899312:1611898956:=358c358%0a%3c If all 3 of the sums are different, what do we do?  Firstly I want to say that all 3 being different will be extremely rare since we already have perfect 1-bit error correction and roughly 98%25 2-bit error detection at the base level. But when it does rarely happen we can do something else so we don't loose all the data in the base chromaton just because of a couple errors.  What we will do is take the 2 chromaton with the fewest detected errors (or the least serious errors, 3-bit error more serious than 2-bit). If there is a 3-way tie, favor chromaton with fewest/less serious errors and most similar sums, if still a 3-way tie then compare and correct all 3 at the same time) and then compare those two (or 3 if all tied) at the base chromaton triad level.  Anything that is different between the 2 (or 3), we check to see if there were any errors detected previously in those spots.  If in one of the chromaton one triad was detected as an error and the other chromaton does not have an error detected in that triad, then the error triad is replaced with the non-error triad.  This is the PEC technique of error recombination.  After all of this what we will be left with is 2 chromaton that are either now identical or only vary in one of two ways.  The first way they can vary is if both have different errors in the same triad.  The second way is they both have different values in the same triad and neither was detected as an error.  In both of these cases the data from the third chromaton is used to fix these, unless the third chromaton has worse errors in those spots (3-bit error).  Even if the loser chromaton also has an error in the same spot as the 2 winners, use the loser chromaton triad so there is convergence.  Now the 2 chromaton that were being compared (or 3 if still all tied) are as good as we can get them in this step.  If you choose a winner here, if one chromaton now has the least amount of errors/least serious errors then report a soft error of [#1].  This is the most serious soft error in the kilochromaton level.  If there is no winner and we now have 2 chromaton with the same number/severity of errors, report a soft error of [#1] and these two bring them to step 3 (skipping step 32 since we already did it), and discard the loser chromaton.  If there is 3 chromaton with the same amount/severity of errors, report soft error of [#1] and bring all three to step 3.%0a---%0a> If all 3 of the sums are different, what do we do?  Firstly I want to say that all 3 being different will be extremely rare since we already have perfect 1-bit error correction and roughly 98%25 2-bit error detection at the base level. But when it does rarely happen we can do something else so we don't loose all the data in the base chromaton just because of a couple errors.  What we will do is take the 2 chromaton with the fewest detected errors (or the least serious errors, 3-bit error more serious than 2-bit). If there is a 3-way tie, favor chromaton with fewest/less serious errors and most similar sums, if still a 3-way tie then compare and correct all 3 at the same time) and then compare those two (or 3 if all tied) at the base chromaton triad level.  Anything that is different between the 2 (or 3), we check to see if there were any errors detected previously in those spots.  If in one of the chromaton one triad was detected as an error and the other chromaton does not have an error detected in that triad, then the error triad is replaced with the non-error triad.  This is the PEC technique of error recombination.  After all of this what we will be left with is 2 chromaton that are either now identical or only vary in one of two ways.  The first way they can vary is if both have different errors in the same triad.  The second way is they both have different values in the same triad and neither was detected as an error.  In both of these cases the data from the third chromaton is used to fix these, unless the third chromaton has worse errors in those spots (3-bit error).  Even if the loser chromaton also has an error in the same spot as the 2 winners, use the loser chromaton triad so there is convergence.  Now the 2 chromaton that were being compared (or 3 if still all tied) are as good as we can get them in this step.  If you choose a winner here, if one chromaton now has the least amount of errors/least serious errors then report a soft error of [#1].  This is the most serious soft error in the kilochromaton level.  If there is no winner and we now have 2 chromaton with the same number/severity of errors, report a soft error of [#1] and these two bring them to step 2, and discard the loser chromaton.  If there is 3 chromaton with the same amount/severity of errors, report soft error of [#1] and bring all three to the next step, step 2.%0a
host:1611899312=104.175.54.158
author:1611898956=
diff:1611898956:1611898769:=358c358%0a%3c If all 3 of the sums are different, what do we do?  Firstly I want to say that all 3 being different will be extremely rare since we already have perfect 1-bit error correction and roughly 98%25 2-bit error detection at the base level. But when it does rarely happen we can do something else so we don't loose all the data in the base chromaton just because of a couple errors.  What we will do is take the 2 chromaton with the fewest detected errors (or the least serious errors, 3-bit error more serious than 2-bit). If there is a 3-way tie, favor chromaton with fewest/less serious errors and most similar sums, if still a 3-way tie then compare and correct all 3 at the same time) and then compare those two (or 3 if all tied) at the base chromaton triad level.  Anything that is different between the 2 (or 3), we check to see if there were any errors detected previously in those spots.  If in one of the chromaton one triad was detected as an error and the other chromaton does not have an error detected in that triad, then the error triad is replaced with the non-error triad.  This is the PEC technique of error recombination.  After all of this what we will be left with is 2 chromaton that are either now identical or only vary in one of two ways.  The first way they can vary is if both have different errors in the same triad.  The second way is they both have different values in the same triad and neither was detected as an error.  In both of these cases the data from the third chromaton is used to fix these, unless the third chromaton has worse errors in those spots (3-bit error).  Even if the loser chromaton also has an error in the same spot as the 2 winners, use the loser chromaton triad so there is convergence.  Now the 2 chromaton that were being compared (or 3 if still all tied) are as good as we can get them in this step.  If you choose a winner here, if one chromaton now has the least amount of errors/least serious errors then report a soft error of [#1].  This is the most serious soft error in the kilochromaton level.  If there is no winner and we now have 2 chromaton with the same number/severity of errors, report a soft error of [#1] and these two bring them to step 2, and discard the loser chromaton.  If there is 3 chromaton with the same amount/severity of errors, report soft error of [#1] and bring all three to the next step, step 2.%0a---%0a> If all 3 of the sums are different, what do we do?  Firstly I want to say that all 3 being different will be extremely rare since we already have perfect 1-bit error correction and roughly 98%25 2-bit error detection at the base level. But when it does rarely happen we can do something else so we don't loose all the data in the base chromaton just because of a couple errors.  What we will do is take the 2 chromaton with the fewest detected errors (or the least serious errors, 3-bit error more serious than 2-bit). If there is a 3-way tie, favor chromaton with fewest/less serious errors and most similar sums, if still a 3-way tie then compare and correct all 3 at the same time) and then compare those two (or 3 if all tied) at the base chromaton triad level.  Anything that is different between the 2 (or 3), we check to see if there were any errors detected previously in those spots.  If in one of the chromaton one triad was detected as an error and the other chromaton does not have an error detected in that triad, then the error triad is replaced with the non-error triad.  This is the PEC technique of error recombination.  After all of this what we will be left with is 2 chromaton that are either now identical or only vary in one of two ways.  The first way they can vary is if both have different errors in the same triad.  The second way is they both have different values in the same triad and neither was detected as an error.  In both of these cases the data from the third chromaton is used to fix these, unless the third chromaton has worse errors in those spots (3-bit error).  Even if the loser chromaton also has an error in the same spot as the 2 wi  ers, use the loser chromaton triad so there is convergence.  Now the 2 chromaton that were being compared (or 3 if still all tied) are as good as we can get them in this step.  If you choose a winner here, if one chromaton now has the least amount of errors/least serious errors then report a soft error of [#1].  This is the most serious soft error in the kilochromaton level.  If there is no winner and we now have 2 chromaton with the same number/severity of errors, report a soft error of [#1] and bring them to step 2.  If there is 3 chromaton with the same amount/severity of errors, report soft error of [#1] and bring all three to the next step, step 2.%0a
host:1611898956=104.175.54.158
author:1611898769=
diff:1611898769:1611898629:=
host:1611898769=104.175.54.158
author:1611898629=
diff:1611898629:1611897756:=358c358%0a%3c If all 3 of the sums are different, what do we do?  Firstly I want to say that all 3 being different will be extremely rare since we already have perfect 1-bit error correction and roughly 98%25 2-bit error detection at the base level. But when it does rarely happen we can do something else so we don't loose all the data in the base chromaton just because of a couple errors.  What we will do is take the 2 chromaton with the fewest detected errors (or the least serious errors, 3-bit error more serious than 2-bit). If there is a 3-way tie, favor chromaton with fewest/less serious errors and most similar sums, if still a 3-way tie then compare and correct all 3 at the same time) and then compare those two (or 3 if all tied) at the base chromaton triad level.  Anything that is different between the 2 (or 3), we check to see if there were any errors detected previously in those spots.  If in one of the chromaton one triad was detected as an error and the other chromaton does not have an error detected in that triad, then the error triad is replaced with the non-error triad.  This is the PEC technique of error recombination.  After all of this what we will be left with is 2 chromaton that are either now identical or only vary in one of two ways.  The first way they can vary is if both have different errors in the same triad.  The second way is they both have different values in the same triad and neither was detected as an error.  In both of these cases the data from the third chromaton is used to fix these, unless the third chromaton has worse errors in those spots (3-bit error).  Even if the loser chromaton also has an error in the same spot as the 2 wi  ers, use the loser chromaton triad so there is convergence.  Now the 2 chromaton that were being compared (or 3 if still all tied) are as good as we can get them in this step.  If you choose a winner here, if one chromaton now has the least amount of errors/least serious errors then report a soft error of [#1].  This is the most serious soft error in the kilochromaton level.  If there is no winner and we now have 2 chromaton with the same number/severity of errors, report a soft error of [#1] and bring them to step 2.  If there is 3 chromaton with the same amount/severity of errors, report soft error of [#1] and bring all three to the next step, step 2.%0a---%0a> If all 3 of the sums are different, what do we do?  Firstly I want to say that all 3 being different will be extremely rare since we already have perfect 1-bit error correction and roughly 98%25 2-bit error detection at the base level. But when it does rarely happen we can do something else so we don't loose all the data in the base chromaton just because of a couple errors.  What we will do is take the 2 chromaton with the fewest detected errors (or the least serious errors, 3-bit error more serious than 2-bit). if there is a 3-way tie, favor chromaton with fewest/less serious errors and most similar sums, if still a 3-way tie favor chromaton with the fewest/less serious errors and most different sums, if still a 3-way tie forget about errors and choose the two with the most different sums) and then compare those two at the base chromaton triad level.  Anything that is different between the 2, we check to see if there were any errors detected previously in those spots.  If in one of the chromaton one triad was detected as an error and the other chromaton does not have an error detected in that triad, then the error triad is replaced with the non-error triad.  This is the PEC technique of error recombination.  After all of this what we will be left with is 2 chromaton that are either now identical or only vary in one of two ways.  The first way they can vary is if both have different errors in the same triad.  The second way is they both have different values in the same triad and neither was detected as an error.  In both of these cases the data from the third chromaton is used to fix these.  Now the 2 chromaton that were being compared are as good as we can get them in this step.  If you choose a winner here, if one chromaton now has the least amount of errors/least serious errors then report a soft error of [#1].  This is the most serious soft error in the kilochromaton level.  If there is no winner and we now have 2 chromaton with the same number/severity of errors, report a soft error of [#1] and bring them to step 2.  If there is 3 chromaton with the same amount/severity of errors, report soft error of [#1] and bring all three to the next step, step 2.%0a
host:1611898629=104.175.54.158
author:1611897756=
diff:1611897756:1611896675:=358c358%0a%3c If all 3 of the sums are different, what do we do?  Firstly I want to say that all 3 being different will be extremely rare since we already have perfect 1-bit error correction and roughly 98%25 2-bit error detection at the base level. But when it does rarely happen we can do something else so we don't loose all the data in the base chromaton just because of a couple errors.  What we will do is take the 2 chromaton with the fewest detected errors (or the least serious errors, 3-bit error more serious than 2-bit). if there is a 3-way tie, favor chromaton with fewest/less serious errors and most similar sums, if still a 3-way tie favor chromaton with the fewest/less serious errors and most different sums, if still a 3-way tie forget about errors and choose the two with the most different sums) and then compare those two at the base chromaton triad level.  Anything that is different between the 2, we check to see if there were any errors detected previously in those spots.  If in one of the chromaton one triad was detected as an error and the other chromaton does not have an error detected in that triad, then the error triad is replaced with the non-error triad.  This is the PEC technique of error recombination.  After all of this what we will be left with is 2 chromaton that are either now identical or only vary in one of two ways.  The first way they can vary is if both have different errors in the same triad.  The second way is they both have different values in the same triad and neither was detected as an error.  In both of these cases the data from the third chromaton is used to fix these.  Now the 2 chromaton that were being compared are as good as we can get them in this step.  If you choose a winner here, if one chromaton now has the least amount of errors/least serious errors then report a soft error of [#1].  This is the most serious soft error in the kilochromaton level.  If there is no winner and we now have 2 chromaton with the same number/severity of errors, report a soft error of [#1] and bring them to step 2.  If there is 3 chromaton with the same amount/severity of errors, report soft error of [#1] and bring all three to the next step, step 2.%0a---%0a> If all 3 of the sums are different, what do we do?  Firstly I want to say that all 3 being different will be extremely rare since we already have perfect 1-bit error correction and roughly 98%25 2-bit error detection at the base level. But when it does rarely happen we can do something else so we don't loose all the data in the base chromaton just because of a couple errors.  What we will do is take the 2 chromaton with the fewest detected errors (or the least serious errors, 3-bit error more serious than 2-bit). if there is a 3-way tie, favor chromaton with fewest/less serious errors and most similar sums, if still a 3-way tie favor chromaton with the fewest/less serious errors and most different sums, if still a 3-way tie forget about errors and choose the two with the most different sums) and then compare those two at the base chromaton triad level.  Anything that is different between the 2, we check to see if there were any errors detected previously in those spots.  If in one of the chromaton one triad was detected as an error and the other chromaton does not have an error detected in that triad, then the error triad is replaced with the non-error triad.  This is the PEC technique of error recombination.  After all of this what we will be left with is 2 chromaton that are either now identical or only vary in one of two ways.  The first way they can vary is if both have different errors in the same triad.  The second way is they both have different values in the same triad and neither was detected as an error.  In both of these cases the data from the third chromaton is used to fix these.  Even if the third chromaton is wrong or has a detected error in the spot in question, we need a tie breaker, so the data in the third chromaton is used to settle any remaining disputes between the two chromaton being compared.  Now the 2 chromaton that were being compared are identical and are considered the correct version.  Choose the [[#v3number|first chromaton]], basically the one closest to the upper left of the kilochromaton. If you choose a winner here, report a soft error of [#1].  This is the most serious soft error in the kilochromaton level.%0a
host:1611897756=79.141.162.81
author:1611896675=
diff:1611896675:1611882227:=354c354%0a%3c Kilochromaton (and higher) gives us another check of the lower chromaton we are reading.  At this level we use "sum" of the lower level.  So first we decode and [[#v3error|error correct all base level]] chromaton.  Then we sum up all the numbers contained in each chromaton and this is the sum, one for each chromaton.  In kilochromaton level we compare the three sums for each replicate chromaton.  If all 3 are the same then we verified that everything is perfect (we have 16 base-4 numbers so the chance that we randomly got the sums to equal yet actually be wrong is 1/64 × 1/64 × 1/64 = 3.8×10^(-6) or 4 times in 1 million).  But for 2 of them to randomly give the same sum wrongly is 1/64 * (1-(63/64)*(63/64)) = 0.049%25 or 484 times in a million.  So since we will accept if 2 of them add to the same sum, we will have a 99.95%25 correct - error correction rate.  This not only corrects 1-bit or 2-bit errors at this level, this corrects up to 48-bit errors!  An entire base chromaton could be wrong and it could be fixed at this level. If 2 or 3 replicates have the same sum, go to [[#samesum|this step]] next. If not, go to the below step.%0a---%0a> Kilochromaton (and higher) gives us another check of the lower chromaton we are reading.  At this level we use "sum" of the lower level.  So first we decode and [[#v3error|error correct all base level]] chromaton.  Then we sum up all the numbers contained in each chromaton and this is the sum, one for each chromaton.  In kilochromaton level we compare the three sums for each replicate chromaton.  If all 3 are the same then we verified that everything is perfect (we have 16 base-4 numbers so the chance that we randomly got the sums to equal yet actually be wrong is 1/64 × 1/64 × 1/64 = 3.8×10^(-6) or 4 times in 1 million).  But for 2 of them to randomly give the same sum wrongly is 1/64 * (1-(63/64)*(63/64)) = 0.049%25 or 484 times in a million.  So since we will accept if 2 of them add to the same sum, we will have a 99.95%25 correct - error correction rate.  This not only corrects 1-bit errors at this level, this corrects up to 48-bit errors!  An entire base chromaton could be wrong and it could be fixed at this level. If 2 or 3 replicates have the same sum, go to [[#samesum|this step]] next. If not, go to the below step.%0a
host:1611896675=79.141.162.81
author:1611882227=
diff:1611882227:1611882147:=370c370%0a%3c We recombine the errors between the two replicates that had the same sum.  To do this we look at each triad with an error, and see if the other replicate does not have an error in that spot.  If not, then replace the error triad with the non-error triad.  Also we use the replicate with the different sum, the looser from step 1, and if this has an error-free triad that one of the winners needs, it is substituted into the winners.  If there is now one replicate with least/lowest severity of errors, then go to the [[#recombwinner| winner section]] a couple paragraphs down.  If both winning replicates now have the same number/severity of errors, discard the looser replicate with the different sum from step 1, and go to step 3.%0a---%0a> We recombine the errors between the two replicates that had the same sum.  To do this we look at each triad with an error, and see if the other replicate does not have an error in that spot.  If not, then replace the error triad with the non-error triad.  Also we use the replicate with the different sum, the looser from step 1, and if this has an error-free triad that one of the winners needs, it is substituted into the winners.  If there is now one replicate with least/lowest severity of errors, then go to the [[#recombwinner| winner section]] a couple paragraphs down.  If both winning replicates now have the same number/severity of errors, discard the looser replicate with the different sum, and go to step 3.%0a
host:1611882227=104.175.54.158
author:1611882147=
diff:1611882147:1611882023:=370c370%0a%3c We recombine the errors between the two replicates that had the same sum.  To do this we look at each triad with an error, and see if the other replicate does not have an error in that spot.  If not, then replace the error triad with the non-error triad.  Also we use the replicate with the different sum, the looser from step 1, and if this has an error-free triad that one of the winners needs, it is substituted into the winners.  If there is now one replicate with least/lowest severity of errors, then go to the [[#recombwinner| winner section]] a couple paragraphs down.  If both winning replicates now have the same number/severity of errors, discard the looser replicate with the different sum, and go to step 3.%0a---%0a> We recombine the errors between the two replicates that had the same sum.  To do this we look at each triad with an error, and see if the other replicate does not have an error in that spot.  If not, then replace the error triad with the non-error triad.  Also we use the replicate with the different sum, the looser from step 1, and if this has an error-free triad that one of the winners needs, it is substituted into the winners.  If there is now one replicate with least/lowest severity of errors, then go to the [[#recombwinner| winner section]] a couple paragraphs down.  If both winning replicates now have the same number/severity of errors, discard the looser replicate, and go to step 3.%0a
host:1611882147=104.175.54.158
author:1611882023=
diff:1611882023:1611881571:=370,371c370,371%0a%3c We recombine the errors between the two replicates that had the same sum.  To do this we look at each triad with an error, and see if the other replicate does not have an error in that spot.  If not, then replace the error triad with the non-error triad.  Also we use the replicate with the different sum, the looser from step 1, and if this has an error-free triad that one of the winners needs, it is substituted into the winners.  If there is now one replicate with least/lowest severity of errors, then go to the [[#recombwinner| winner section]] a couple paragraphs down.  If both winning replicates now have the same number/severity of errors, discard the looser replicate, and go to step 3.%0a%3c %0a---%0a> We recombine the errors between the two replicates that had the same sum.  To do this we look at each triad with an error, and see if the other replicate does not have an error in that spot.  If not, then replace the error triad with the non-error triad.  Also we use the replicate with the different sum, the looser from step 1, and if this has an error-free triad that one of the winners needs, it is substituted into the winners.  If there is now one replicate with least/lowest severity of errors, then go to the [[#recombwinner| winner section]] a couple paragraphs down.  If both winning replicates now have the same number/severity of errors, discard the looser replicate, and go to the [[#recombmult|multiple replicate section]] a couple paragraphs down.%0a> %0a375,376c375,380%0a%3c But if a winner was not determined and there are two or three with the same amount/severity of errors, then do recombination as well.  Compare the two with the same amount of errors and the same sums (or all three in the case they all are tied) and see if you can correct any using the data from the other.  So if one triad that gave an error has a match in the other replicate chromaton with no error, use the error free version.  You can use the third loser replicate to fix any errors you couldn't fix using only the winner replicates.  After this discard the loser replicate if there is one. If now one replicate has less errors/severity than the others you have a winner and continue to [[#recombwinner|"if there is a winner"]] section.  If you still have the two or three replicates with that had the same sum in the previous step tied with number/severity of errors even after recombination, continue to step 3 after discarding any loser replicate chromaton.%0a%3c %0a---%0a> But if a winner was not determined and there are two or three with the same amount/severity of errors, then do recombination as well.  Compare the two with the same amount of errors and the same sums (or all three in the case they all are tied) and see if you can correct any using the data from the other.  So if one triad that gave an error has a match in the other replicate chromaton with no error, use the error free version.  You can use the third loser replicate to fix any errors you couldn't fix using only the winner replicates.  After this discard the loser replicate if there is one. If now one replicate has less errors/severity than the others you have a winner and continue to [[#recombwinner|"if there is a winner"]] section.  If you still have the two or three replicates with that had the same sum in the previous step tied with number/severity of errors even after recombination, continue to step 3.%0a> %0a> !!!!!!If multiple replicates have the same number/severity of errors: [[#recombmult]]%0a> %0a> Keep the replicate(s) that are tied for having the least number and severity of errors.  If any replicates have more errors/severity than the others, these are determined the losers.  At this stage recombine any errors in the winners with each-other if possible, and also with the looser.  Basically what you do is if there was an error detected in a triad of any designated winners, replace them with other winners error free triad if they have one  in that spot.  If you can't come to a consensus with the triads in any winners, then use the looser to provide error free triads for the spot in question.  If you now only have 1 winning version, ie; the recombination makes it so only 1 winning version is left (one version has the fewest and least severe errors), then go to the below part: "If there is a winner determined".  If the recombination leaves you with still multiple versions that all have the same number and severity of errors, but the errors are different, then bring only the tied winners to step 3.%0a>  %0a
host:1611882023=104.175.54.158
author:1611881571=
diff:1611881571:1611881311:=375c375%0a%3c But if a winner was not determined and there are two or three with the same amount/severity of errors, then do recombination as well.  Compare the two with the same amount of errors and the same sums (or all three in the case they all are tied) and see if you can correct any using the data from the other.  So if one triad that gave an error has a match in the other replicate chromaton with no error, use the error free version.  You can use the third loser replicate to fix any errors you couldn't fix using only the winner replicates.  After this discard the loser replicate if there is one. If now one replicate has less errors/severity than the others you have a winner and continue to [[#recombwinner|"if there is a winner"]] section.  If you still have the two or three replicates with that had the same sum in the previous step tied with number/severity of errors even after recombination, continue to step 3.%0a---%0a> But if a winner was not determined and there are two with the same amount/severity of errors, which are also the 2 with the same sum, then do recombination as well.  Compare the two with the same amount of errors and the same sums and see if you can correct any using the data from the other.  So if one triad that gave an error has a match in the other replicate chromaton with no error, use the error free version.  You can use the third loser replicate to fix any errors you couldn't fix using only the winner replicates.  After this discard the loser replicate. If now one replkcate has less errors/severity than the others you have a winner and continue to [[#recombwinner|"if there is a winner"]] section.  If you still have the two replicates with that had the same sum in the previous step tied with njmber/severity of errors, continue to step 3.%0a
host:1611881571=104.175.54.158
author:1611881311=
diff:1611881311:1611880524:=375c375%0a%3c But if a winner was not determined and there are two with the same amount/severity of errors, which are also the 2 with the same sum, then do recombination as well.  Compare the two with the same amount of errors and the same sums and see if you can correct any using the data from the other.  So if one triad that gave an error has a match in the other replicate chromaton with no error, use the error free version.  You can use the third loser replicate to fix any errors you couldn't fix using only the winner replicates.  After this discard the loser replicate. If now one replkcate has less errors/severity than the others you have a winner and continue to [[#recombwinner|"if there is a winner"]] section.  If you still have the two replicates with that had the same sum in the previous step tied with njmber/severity of errors, continue to step 3.%0a---%0a> But if a winner was not determined and there are two with the same amount/severity of errors, then %0a
host:1611881311=104.175.54.158
author:1611880524=
diff:1611880524:1611880389:=351,352c351%0a%3c The farther the error correction on this level makes it, the less severe of an error.  The lower the error number, the more severe the error.  So an error at step 1 is more severe than an error at step 7 for example.  This will help us in megachromaton error correction.%0a%3c %0a---%0a> The farther the error correction on this level makes it, the less severe of an error.  The lower the error number, the more severe the error.  So an error at step 1 is more severe than an error at step 7 for example.%0a
host:1611880524=104.175.54.158
author:1611880389=
diff:1611880389:1611880279:=261c261%0a%3c Again, chromaton is never to be used in or for identity or tied to identity in any way.  Not even some egalitarian vision of identity like Tim Berners-Lee is advocating for.  Chromatom must always be anonymous and free of any ties of any kind.  Even consent does not make tying chromaton to an identity ok.%0a---%0a> Again, chromaton is never to be used in or for identity or tied to identity in any way.  Not even some egalitarian vision of identity like Tim Berners-Lee is advocating for.  Chromatom must always be anonymous and free of any ties of any kind.%0a
host:1611880389=104.175.54.158
author:1611880279=
diff:1611880279:1611879928:=204,205d203%0a%3c %0a%3c Again it is critical that chromaton never be tied to an identity or its use tied to an identity.  Identifying information must never be contained within chromaton nor should it be used to indicate proof of an identity.  Chromaton must neverbe used to discriminate between compliant people and non-compliant.  Chromaton is only for fully anonymous use and content, use and content must never be tied to identity.  Not even if by consent.%0a
host:1611880279=104.175.54.158
author:1611879928=
diff:1611879928:1611879718:=16,17d15%0a%3c %0a%3c Super important that chromaton shall never be tied to an identity.  Chromaton must never be used to identify people or contain identifying information.  Chromaton must never be used to surveil or categorize people like those who have or have not done something.  Chromaton must always be anonymous and never tied to identity.%0a
host:1611879928=104.175.54.158
author:1611879718=
diff:1611879718:1611872517:=256,257d255%0a%3c %0a%3c Again, chromaton is never to be used in or for identity or tied to identity in any way.  Not even some egalitarian vision of identity like Tim Berners-Lee is advocating for.  Chromatom must always be anonymous and free of any ties of any kind.%0a
host:1611879718=104.175.54.158
author:1611872517=
diff:1611872517:1611872462:=345c345%0a%3c The farther the error correction on this level makes it, the less severe of an error.  The lower the error number, the more severe the error.  So an error at step 1 is more severe than an error at step 7 for example.%0a---%0a> The farther the error correction on this level makes it, the less severe of an error.  The lower the error number, r more zevere the error.  So an error at step 1 is more severe than an error at step 7 for example.%0a
host:1611872517=104.175.54.158
author:1611872462=
diff:1611872462:1611868671:=345c345%0a%3c The farther the error correction on this level makes it, the less severe of an error.  The lower the error number, r more zevere the error.  So an error at step 1 is more severe than an error at step 7 for example.%0a---%0a> The farther the error correction on this level makes it, the %0a
host:1611872462=104.175.54.158
author:1611868671=
diff:1611868671:1611866180:=360,370c360,369%0a%3c In this step we pick the one with the least amount of errors (and/or least severe errors; since 3-bit errors are more serious than 2-bit) reported in the [[#v3error|original error correction steps]] to use as the "one correct version" ("winner").%0a%3c %0a%3c !!!!!!If only two replicates from the previous step have the same sum:%0a%3c We recombine the errors between the two replicates that had the same sum.  To do this we look at each triad with an error, and see if the other replicate does not have an error in that spot.  If not, then replace the error triad with the non-error triad.  Also we use the replicate with the different sum, the looser from step 1, and if this has an error-free triad that one of the winners needs, it is substituted into the winners.  If there is now one replicate with least/lowest severity of errors, then go to the [[#recombwinner| winner section]] a couple paragraphs down.  If both winning replicates now have the same number/severity of errors, discard the looser replicate, and go to the [[#recombmult|multiple replicate section]] a couple paragraphs down.%0a%3c %0a%3c !!!!!!If all 3 from the previous step have the same sum:%0a%3c If there is a replicate that has the fewest/least severe errors, then that is the winner.  If there is a detected error in one or more triads in this winner, and if there is a matching triad in another replicate that does not have an error at that location, then the error free triad is substituted into the winner chromaton. Continue to the part below: "[[#recombwinner|If there is a winner determined]]".  %0a%3c %0a%3c But if a winner was not determined and there are two with the same amount/severity of errors, then %0a%3c %0a%3c !!!!!!If multiple replicates have the same number/severity of errors: [[#recombmult]]%0a---%0a> %0a> If two replicates from the previous step have the same sum:%0a> %0a> %0a> If all 3 have the same sum:%0a> In this step we pick the one with the least amount of errors (and/or least severe errors; since 3-bit errors are more serious than 2-bit) reported in the [[#v3error|original error correction steps]] to use as the "one correct version" ("winner"). If there is a replicate that has the fewest/least severe errors, then that is the winner.  If there is a detected error in one or more triads in this winner, and if there is a matching triad in another replicate that does not have an error at that location, then the error free triad is substituted into the winner chromaton. Continue to the part below: "[[#recombwinner|If there is a winner determined]]".  %0a> %0a> But if a winner was not determined based on number and severity of errors (there was a tie), then see below.%0a> %0a> !!!!!!If multiple replicates have the same number/severity of errors:%0a
host:1611868671=104.175.54.158
author:1611866180=
diff:1611866180:1611866110:=360,364d359%0a%3c %0a%3c If two replicates from the previous step have the same sum:%0a%3c %0a%3c %0a%3c If all 3 have the same sum:%0a
host:1611866180=104.175.54.158
author:1611866110=
diff:1611866110:1611865541:=354,356c354%0a%3c If 2 or more agree on the sum without performing the "all different" protocol above, then this is great; if the sums equal then the overwhelming chance is the chromaton are in fact the same. However we still have to decide which one to correct it to!  We can't just keep all the chromaton since they are replicates at this level.  One idea would be to choose one randomly.  The reason we won't do this is 2-fold.  Firstly it would take a lot of processing power to run a pseudorandom algorithm every time we needed to make a decision.  Another reason is random algorithms can be cracked and a malicious attacker could know ahead of time which one you will pick and insert a malicious chromaton in the position that he knows will beat the detection.  So we need to use actual intelligent decisions so we are all on the same page.  The following techniques will go from fast and easy to slower and more complicated.  If the fast and simple methods can converge us on an answer then it will save us time and give us soft errors that will tell us how close our data is to perfect, and if not then we go to the more expensive techniques. See history of error correction for more info on the following checks [[https://www.techradar.com/news/computing/how-error-detection-and-correction-works-1080736|#]]. %0a%3c %0a%3c If two or three of the replicates have the same sum, we go to the next step, step 2, with all the chromaton replicates including the one without the same sum if applicable.%0a---%0a> If 2 or more agree on the sum without performing the "all different" protocol above, then this is great; if the sums equal then the overwhelming chance is the chromaton are in fact the same. However we still have to decide which one to correct it to!  We can't just keep all the chromaton since they are replicates at this level.  One idea would be to choose one randomly.  The reason we won't do this is 2-fold.  Firstly it would take a lot of processing power to run a pseudorandom algorithm every time we needed to make a decision.  Another reason is random algorithms can be cracked and a malicious attacker could know ahead of time which one you will pick and insert a malicious chromaton in the position that he knows will beat the detection.  So we need to use actual intelligent decisions so we are all on the same page.  The following techniques will go from fast and easy to slower and more complicated.  If the fast and simple methods can converge us on an answer then it will save us time and give us soft errors that will tell us how close our data is to perfect, and if not then we go to the more expensive techniques. See history of error correction for more info on the following checks [[https://www.techradar.com/news/computing/how-error-detection-and-correction-works-1080736|#]]. If two or three of the replicates have the same sum, keep all of these and go to the next step, step 2.%0a
host:1611866110=104.175.54.158
author:1611865541=
diff:1611865541:1611865465:=360c360%0a%3c But if a winner was not determined based on number and severity of errors (there was a tie), then see below.%0a---%0a> But if a winner was not determined based on number and severity of errors, then see below.%0a
host:1611865541=104.175.54.158
author:1611865465=
diff:1611865465:1611865449:=385c385%0a%3c Favor each triad that has fewest detected errors at the base level and/or the least serious errors.  If there is one best, then choose it as the winner and report a soft error of [#6].  If there is no winner, then carry on the remaining chromaton to step 7.%0a---%0a> Favor each triad that has fewest detected errors at the base level and/or the least serious errors.  Weight 2-bit and 3-bit errors as their ratio of being corrected correctly.  If there is one best, then choose it as the winner and report a soft error of [#6].  If there is no winner, then carry on the remaining chromaton to step 7.%0a
host:1611865465=104.175.54.158
author:1611865449=
diff:1611865449:1611865321:=358c358%0a%3c In this step we pick the one with the least amount of errors (and/or least severe errors; since 3-bit errors are more serious than 2-bit) reported in the [[#v3error|original error correction steps]] to use as the "one correct version" ("winner"). If there is a replicate that has the fewest/least severe errors, then that is the winner.  If there is a detected error in one or more triads in this winner, and if there is a matching triad in another replicate that does not have an error at that location, then the error free triad is substituted into the winner chromaton. Continue to the part below: "[[#recombwinner|If there is a winner determined]]".  %0a---%0a> In this step we pick the one with the least amount of errors (and/or least severe errors; since 3-bit errors are more serious than 2-bit) reported in the [[#v3error|original error correction steps]] to use as the "one correct version" ("winner"). In determining this, weight 2-bit and 3-bit errors as their ratio of being fixed correctly. If there is a detected error in one or more triads in this winner, and if there is a matching triad in another replicate that does not have an error at that location, then the error free triad is substituted into the winner chromaton. Continue to the part below: "[[#recombwinner|If there is a winner determined]]".  %0a
host:1611865449=104.175.54.158
author:1611865321=
diff:1611865321:1611865285:=358c358%0a%3c In this step we pick the one with the least amount of errors (and/or least severe errors; since 3-bit errors are more serious than 2-bit) reported in the [[#v3error|original error correction steps]] to use as the "one correct version" ("winner"). In determining this, weight 2-bit and 3-bit errors as their ratio of being fixed correctly. If there is a detected error in one or more triads in this winner, and if there is a matching triad in another replicate that does not have an error at that location, then the error free triad is substituted into the winner chromaton. Continue to the part below: "[[#recombwinner|If there is a winner determined]]".  %0a---%0a> In this step we pick the one with the least amount of errors (and/or least severe errors; since 3-bit errors are more serious than 2-bit) reported in the [[#v3error|original error correction steps]] to use as the "one correct version" ("winner"). In determining this, weight 2-bit and 3-bit errors as their ratio of being corrected correctly. If there is a detected error in one or more triads in this winner, and if there is a matching triad in another replicate that does not have an error at that location, then the error free triad is substituted into the winner chromaton. Continue to the part below: "[[#recombwinner|If there is a winner determined]]".  %0a
host:1611865321=104.175.54.158
author:1611865285=
diff:1611865285:1611865266:=364c364%0a%3c Keep the replicate(s) that are tied for having the least number and severity of errors.  If any replicates have more errors/severity than the others, these are determined the losers.  At this stage recombine any errors in the winners with each-other if possible, and also with the looser.  Basically what you do is if there was an error detected in a triad of any designated winners, replace them with other winners error free triad if they have one  in that spot.  If you can't come to a consensus with the triads in any winners, then use the looser to provide error free triads for the spot in question.  If you now only have 1 winning version, ie; the recombination makes it so only 1 winning version is left (one version has the fewest and least severe errors), then go to the below part: "If there is a winner determined".  If the recombination leaves you with still multiple versions that all have the same number and severity of errors, but the errors are different, then bring only the tied winners to step 3.%0a---%0a> Keep the replicate(s) that are tied for having the least number and severity of errors.  If any replicates have more errors/severity than the others, these are determined the loosers.  At this stage recombine any errors in the winners with eachother if possible, and also with the looser.  Basically what you do is if there was an error detected in a triad of any designated winners, replace them with other winners error free triad if they have one  in that spot.  If you can't come to a consensus with the triads in any winners, then use the looser to provide error free triads for the spot in question.  If you now only have 1 winning version, ie; the recombination makes it so only 1 winning version is left (one version has the fewest and least severe errors), then go to the below part: "If there is a winner determined".  If the recombination leaves you with still multiple versions that all have the same number and severity of errors, but the errors are different, then bring only the tied winners to step 3.%0a
host:1611865285=104.175.54.158
author:1611865266=
diff:1611865266:1611865155:=364c364%0a%3c Keep the replicate(s) that are tied for having the least number and severity of errors.  If any replicates have more errors/severity than the others, these are determined the loosers.  At this stage recombine any errors in the winners with eachother if possible, and also with the looser.  Basically what you do is if there was an error detected in a triad of any designated winners, replace them with other winners error free triad if they have one  in that spot.  If you can't come to a consensus with the triads in any winners, then use the looser to provide error free triads for the spot in question.  If you now only have 1 winning version, ie; the recombination makes it so only 1 winning version is left (one version has the fewest and least severe errors), then go to the below part: "If there is a winner determined".  If the recombination leaves you with still multiple versions that all have the same number and severity of errors, but the errors are different, then bring only the tied winners to step 3.%0a---%0a> Keep the replicate(s) that are tied for having the least number and severity of errors.  If any replicates have more errors/severity than the others, these are determined the loosers.  At this stage recombine any errors in the winners with eachother if possible, and also with the looser.  Basically what you do is if there was an error detected in a triad of any designated winners, replace them with other winners error free triad if they have one  in that spot.  If you can't come to a consensus with the triads in any winners, then use the looser to provide error free triads for the spot in question.  If you now only have 1 winning version, ie; the recombination makes it so only 1 winning version is left (one version has the fewest and least severe errors), then go to the below part: "If there is a winner determined".  If the recombination leaves you with still multiple versions that all have the same number and severity of errors, but the errors are different, then go to step 3.%0a367c367%0a%3c If a winner is chosen in this step, then report a soft error of [#2].%0a---%0a> If a winner is chosen in this step, then report a soft error of [#2]. If a tie between any of the replicates are found, first recombine any errors between the remaining chromaton, then discard any chromaton that had more errors than the others, then go to step 3.%0a
host:1611865266=104.175.54.158
author:1611865155=
diff:1611865155:1611865027:=364c364%0a%3c Keep the replicate(s) that are tied for having the least number and severity of errors.  If any replicates have more errors/severity than the others, these are determined the loosers.  At this stage recombine any errors in the winners with eachother if possible, and also with the looser.  Basically what you do is if there was an error detected in a triad of any designated winners, replace them with other winners error free triad if they have one  in that spot.  If you can't come to a consensus with the triads in any winners, then use the looser to provide error free triads for the spot in question.  If you now only have 1 winning version, ie; the recombination makes it so only 1 winning version is left (one version has the fewest and least severe errors), then go to the below part: "If there is a winner determined".  If the recombination leaves you with still multiple versions that all have the same number and severity of errors, but the errors are different, then go to step 3.%0a---%0a> Keep the replicate(s) that are tied for having the least number and severity of errors.  If any replicates have more errors/severity than the others, these are determined the loosers.  At this stage recombine any errors in the winners with eachother if possible, and also with the looser.  Basically what you do is if there was an error detected in a triad of any designated winners, replace them with other winners error free triad if they have one  in that spot.  If you can't come to a consensus with the triads in any winners, then use the looser to provide error free triads for the spot in question.  If you now only have 1 winning version, ie; the recombination makes it so only 1 winning version is left (one version has the fewest and least severe errors), then go to the below part: "If there is a winner determined".  If the recombination leaves you with still multiple versions that all have the same number and severity of errors, then go to step 3.%0a
host:1611865155=104.175.54.158
author:1611865027=
diff:1611865027:1611864863:=364c364%0a%3c Keep the replicate(s) that are tied for having the least number and severity of errors.  If any replicates have more errors/severity than the others, these are determined the loosers.  At this stage recombine any errors in the winners with eachother if possible, and also with the looser.  Basically what you do is if there was an error detected in a triad of any designated winners, replace them with other winners error free triad if they have one  in that spot.  If you can't come to a consensus with the triads in any winners, then use the looser to provide error free triads for the spot in question.  If you now only have 1 winning version, ie; the recombination makes it so only 1 winning version is left (one version has the fewest and least severe errors), then go to the below part: "If there is a winner determined".  If the recombination leaves you with still multiple versions that all have the same number and severity of errors, then go to step 3.%0a---%0a> Keep the replicate(s) that are tied for having the least number and severity of errors.  If any replicates have more than the others, these are determined the loosers.  At this stage recombine any errors in the winners with eachother if possible, and also with the looser.  Basically what you do is if there was an error detected in a triad of any designated winners, replace them with other winners error free triad if they have one  in that spot.  If you can't come to a consensus with the triads in any winners, then use the looser to provide error free triads for the spot in question.  If you now only have 1 winning version, ie; the recombination makes it so only 1 winning version is left (one version has the fewest and least severe errors), then go to the below part: "If there is a winner determined".  If the recombination leaves you with still multiple versions that all have the same number and severity of errors, then go to step 3.%0a
host:1611865027=104.175.54.158
author:1611864863=
diff:1611864863:1611864823:=364c364%0a%3c Keep the replicate(s) that are tied for having the least number and severity of errors.  If any replicates have more than the others, these are determined the loosers.  At this stage recombine any errors in the winners with eachother if possible, and also with the looser.  Basically what you do is if there was an error detected in a triad of any designated winners, replace them with other winners error free triad if they have one  in that spot.  If you can't come to a consensus with the triads in any winners, then use the looser to provide error free triads for the spot in question.  If you now only have 1 winning version, ie; the recombination makes it so only 1 winning version is left (one version has the fewest and least severe errors), then go to the below part: "If there is a winner determined".  If the recombination leaves you with still multiple versions that all have the same number and severity of errors, then go to step 3.%0a---%0a> Keep the replicate(s) that have the least number and severity of errors.  If any replicates have more than the others, these are determined the loosers.  At this stage recombine any errors in the winners with eachother if possible, and also with the looser.  Basically what you do is if there was an error detected in a triad of any designated winners, replace them with other winners error free triad if they have one  in that spot.  If you can't come to a consensus with the triads in any winners, then use the looser to provide error free triads for the spot in question.  If you now only have 1 winning version, ie; the recombination makes it so only 1 winning version is left (one version has the fewest and least severe errors), then go to the below part: "If there is a winner determined".  If the recombination leaves you with still multiple versions that all have the same number and severity of errors, then go to step 3.%0a
host:1611864863=104.175.54.158
author:1611864823=
diff:1611864823:1611864625:=358,360c358%0a%3c In this step we pick the one with the least amount of errors (and/or least severe errors; since 3-bit errors are more serious than 2-bit) reported in the [[#v3error|original error correction steps]] to use as the "one correct version" ("winner"). In determining this, weight 2-bit and 3-bit errors as their ratio of being corrected correctly. If there is a detected error in one or more triads in this winner, and if there is a matching triad in another replicate that does not have an error at that location, then the error free triad is substituted into the winner chromaton. Continue to the part below: "[[#recombwinner|If there is a winner determined]]".  %0a%3c %0a%3c But if a winner was not determined based on number and severity of errors, then see below.%0a---%0a> In this step we pick the one with the least amount of errors (and/or least severe errors; since 3-bit errors are more serious than 2-bit) reported in the [[#v3error|original error correction steps]] to use as the "one correct version" ("winner"). In determining this, weight 2-bit and 3-bit errors as their ratio of being corrected correctly. If there is a detected error in one or more triads in this winner, and if there is a matching triad in another replicate that does not have an error at that location, then the error free triad is substituted into the winner chromaton. Continue to the part below: "[[#recombwinner|If there is a winner determined]]".  If not, see below.%0a
host:1611864823=104.175.54.158
author:1611864625=
diff:1611864625:1611864590:=358c358%0a%3c In this step we pick the one with the least amount of errors (and/or least severe errors; since 3-bit errors are more serious than 2-bit) reported in the [[#v3error|original error correction steps]] to use as the "one correct version" ("winner"). In determining this, weight 2-bit and 3-bit errors as their ratio of being corrected correctly. If there is a detected error in one or more triads in this winner, and if there is a matching triad in another replicate that does not have an error at that location, then the error free triad is substituted into the winner chromaton. Continue to the part below: "[[#recombwinner|If there is a winner determined]]".  If not, see below.%0a---%0a> In this step we pick the one with the least amount of errors (and/or least severe errors; since 3-bit errors since these are more serious than 2-bit) reported in the [[#v3error|original error correction steps]] to use as the "one correct version" ("winner"). In determining this, weight 2-bit and 3-bit errors as their ratio of being corrected correctly. If there is a detected error in one or more triads in this winner, and if there is a matching triad in another replicate that does not have an error at that location, then the error free triad is substituted into the winner chromaton. Continue to the part below: "[[#recombwinner|If there is a winner determined]]".  If not, see below.%0a
host:1611864625=104.175.54.158
author:1611864590=
diff:1611864590:1611863939:=358,365c358%0a%3c In this step we pick the one with the least amount of errors (and/or least severe errors; since 3-bit errors since these are more serious than 2-bit) reported in the [[#v3error|original error correction steps]] to use as the "one correct version" ("winner"). In determining this, weight 2-bit and 3-bit errors as their ratio of being corrected correctly. If there is a detected error in one or more triads in this winner, and if there is a matching triad in another replicate that does not have an error at that location, then the error free triad is substituted into the winner chromaton. Continue to the part below: "[[#recombwinner|If there is a winner determined]]".  If not, see below.%0a%3c %0a%3c !!!!!!If multiple replicates have the same number/severity of errors:%0a%3c %0a%3c Keep the replicate(s) that have the least number and severity of errors.  If any replicates have more than the others, these are determined the loosers.  At this stage recombine any errors in the winners with eachother if possible, and also with the looser.  Basically what you do is if there was an error detected in a triad of any designated winners, replace them with other winners error free triad if they have one  in that spot.  If you can't come to a consensus with the triads in any winners, then use the looser to provide error free triads for the spot in question.  If you now only have 1 winning version, ie; the recombination makes it so only 1 winning version is left (one version has the fewest and least severe errors), then go to the below part: "If there is a winner determined".  If the recombination leaves you with still multiple versions that all have the same number and severity of errors, then go to step 3.%0a%3c  %0a%3c !!!!!!If there is a winner determined:[[#recombwinner]]%0a%3c If a winner is chosen in this step, then report a soft error of [#2]. If a tie between any of the replicates are found, first recombine any errors between the remaining chromaton, then discard any chromaton that had more errors than the others, then go to step 3.%0a---%0a> In this step we pick the one with the least amount of errors (and/or least 3-bit errors since these are more serious than 2-bit) reported in the [[#v3error|original error correction steps]] to use as the "one correct version" ("winner"). In determining this, weight 2-bit and 3-bit errors as their ratio of being corrected correctly. If a winner is chosen, and there is a detected error in one or more triads in this winner, and if there is a matching triad in another replicate that does not have an error at that location, then the error free triad is substituted into the winner chromaton.  If a winner is chosen in this step, then report a soft error of [#2]. If a tie between any of the replicates are found, first recombine any errors between the remaining chromaton, then discard any chromaton that had more errors than the others, then go to step 3.%0a
host:1611864590=104.175.54.158
author:1611863939=
diff:1611863939:1611863860:=354c354%0a%3c If 2 or more agree on the sum without performing the "all different" protocol above, then this is great; if the sums equal then the overwhelming chance is the chromaton are in fact the same. However we still have to decide which one to correct it to!  We can't just keep all the chromaton since they are replicates at this level.  One idea would be to choose one randomly.  The reason we won't do this is 2-fold.  Firstly it would take a lot of processing power to run a pseudorandom algorithm every time we needed to make a decision.  Another reason is random algorithms can be cracked and a malicious attacker could know ahead of time which one you will pick and insert a malicious chromaton in the position that he knows will beat the detection.  So we need to use actual intelligent decisions so we are all on the same page.  The following techniques will go from fast and easy to slower and more complicated.  If the fast and simple methods can converge us on an answer then it will save us time and give us soft errors that will tell us how close our data is to perfect, and if not then we go to the more expensive techniques. See history of error correction for more info on the following checks [[https://www.techradar.com/news/computing/how-error-detection-and-correction-works-1080736|#]]. If two or three of the replicates have the same sum, keep all of these and go to the next step, step 2.%0a---%0a> If 2 or more agree on the sum without performing the "all different" protocol above, then this is great; if the sums equal then the overwhelming chance is the chromaton are in fact the same. However we still have to decide which one to correct it to!  We can't just keep all the chromaton since they are replicates at this level.  One idea would be to choose one randomly.  The reason we won't do this is 2-fold.  Firstly it would take a lot of processing power to run a pseudorandom algorithm every time we needed to make a decision.  Another reason is random algorithms can be cracked and a malicious attacker could know ahead of time which one you will pick and insert a malicious chromaton in the position that he knows will beat the detection.  So we need to use actual intelligent decisions so we are all on the same page.  The following techniques will go from fast and easy to slower and more complicated.  If the fast and simple methods can converge us on an answer then it will save us time and give us soft errors that will tell us how close our data is to perfect, and if not then we go to the more expensive techniques. See history of error correction for more info on the following checks [[https://www.techradar.com/news/computing/how-error-detection-and-correction-works-1080736|#]].%0a
host:1611863939=104.175.54.158
author:1611863860=
diff:1611863860:1611863505:=357,358c357,358%0a%3c !!!!!2. Error recombination%0a%3c In this step we pick the one with the least amount of errors (and/or least 3-bit errors since these are more serious than 2-bit) reported in the [[#v3error|original error correction steps]] to use as the "one correct version" ("winner"). In determining this, weight 2-bit and 3-bit errors as their ratio of being corrected correctly. If a winner is chosen, and there is a detected error in one or more triads in this winner, and if there is a matching triad in another replicate that does not have an error at that location, then the error free triad is substituted into the winner chromaton.  If a winner is chosen in this step, then report a soft error of [#2]. If a tie between any of the replicates are found, first recombine any errors between the remaining chromaton, then discard any chromaton that had more errors than the others, then go to step 3.%0a---%0a> !!!!!2. Lowest errors%0a> In the case all 3 have the same sum or two do, pick the one with the least amount of errors (and/or least 3-bit errors since these are more serious than 2-bit) reported in the [[#v3error|original error correction steps]] to use as the "one correct version" ("winner"). Weight 2-bit and 3-bit errors as their ratio of being corrected correctly.  If a winner is chosen here, then report a soft error of [#2].  If a tie between any of the replicates are found, go to step 3.%0a
host:1611863860=104.175.54.158
author:1611863505=
diff:1611863505:1611863455:=351c351%0a%3c If all 3 of the sums are different, what do we do?  Firstly I want to say that all 3 being different will be extremely rare since we already have perfect 1-bit error correction and roughly 98%25 2-bit error detection at the base level. But when it does rarely happen we can do something else so we don't loose all the data in the base chromaton just because of a couple errors.  What we will do is take the 2 chromaton with the fewest detected errors (or the least serious errors, 3-bit error more serious than 2-bit). if there is a 3-way tie, favor chromaton with fewest/less serious errors and most similar sums, if still a 3-way tie favor chromaton with the fewest/less serious errors and most different sums, if still a 3-way tie forget about errors and choose the two with the most different sums) and then compare those two at the base chromaton triad level.  Anything that is different between the 2, we check to see if there were any errors detected previously in those spots.  If in one of the chromaton one triad was detected as an error and the other chromaton does not have an error detected in that triad, then the error triad is replaced with the non-error triad.  This is the PEC technique of error recombination.  After all of this what we will be left with is 2 chromaton that are either now identical or only vary in one of two ways.  The first way they can vary is if both have different errors in the same triad.  The second way is they both have different values in the same triad and neither was detected as an error.  In both of these cases the data from the third chromaton is used to fix these.  Even if the third chromaton is wrong or has a detected error in the spot in question, we need a tie breaker, so the data in the third chromaton is used to settle any remaining disputes between the two chromaton being compared.  Now the 2 chromaton that were being compared are identical and are considered the correct version.  Choose the [[#v3number|first chromaton]], basically the one closest to the upper left of the kilochromaton. If you choose a winner here, report a soft error of [#1].  This is the most serious soft error in the kilochromaton level.%0a---%0a> If all 3 of the sums are different, what do we do?  Firstly I want to say that all 3 being different will be extremely rare since we already have perfect 1-bit error correction and roughly 98%25 2-bit error detection at the base level. But when it does rarely happen we can do something else so we don't loose all the data in the base chromaton just because of a couple errors.  What we will do is take the 2 chromaton with the fewest detected errors (or the least serious errors, 3-bit error more serious than 2-bit). if there is a 3-way tie, favor chromaton with fewest/less serious errors and most similar sums, if still a 3-way tie favor chromaton with the fewest/less serious errors and most different sums, if still a 3-way tie forget about errors and choose the two with the most different sums) and then compare those two at the base chromaton triad level.  Anything that is different between the 2, we check to see if there were any errors detected previously in those spots.  If in one of the chromaton one triad was detected as an error and the other chromaton does not have an error detected in that triad, then the error triad is replaced with the non-error triad.  After all of this what we will be left with is 2 chromaton that are either now identical or only vary in one of two ways.  The first way they can vary is if both have different errors in the same triad.  The second way is they both have different values in the same triad and neither was detected as an error.  In both of these cases the data from the third chromaton is used to fix these.  Even if the third chromaton is wrong or has a detected error in the spot in question, we need a tie breaker, so the data in the third chromaton is used to settle any remaining disputes between the two chromaton being compared.  Now the 2 chromaton that were being compared are identical and are considered the correct version.  Choose the [[#v3number|first chromaton]], basically the one closest to the upper left of the kilochromaton. If you choose a winner here, report a soft error of [#1].  This is the most serious soft error in the kilochromaton level.%0a
host:1611863505=104.175.54.158
author:1611863455=
diff:1611863455:1611863204:=297c297%0a%3c To get rid of the color filters in Cv2, we need to use 3-color triads instead of 2-color pairs.  We will also force orientation in certain ways so there are 12 colors and only base-4.  We are giving up 8 bases (2/3rds) in order to have robust error detection and correction.  This means that each color is only in a set of 3 and must maintain a certain orientation. These methods, like in [[#v2|Cv2]], are part of physical information theory (PIT) or [[physical error correction]] (PEC) which is in contrast to algorithmic error correction (AEC) invented by Hamming.  PEC uses physical properties of data to detect and/or correct and/or prevent errors.  Some of these properties, as also explained in [[#v2|Cv2]], can be replicates, recombination, location, orientation, partnering, tagging, keying, contrast, etc.  [[Physical error correction]] is the methodology most used in nature and can be found in DNA, visual field, neurons (such as memory and recall); and other data storage, transmission, and processing.  If PEC is bieng used exclusively over AEC, then the only algorithms used would be in the reading and decoding, not in the encoding.  Only physical factors are used for encoding in purely PEC.  Of course algorithms can be used to choose or dictate how/when PEC is used based on the data used.%0a---%0a> To get rid of the color filters in Cv2, we need to use 3-color triads instead of 2-color pairs.  We will also force orientation in certain ways so there are 12 colors and only base-4.  We are giving up 8 bases (2/3rds) in order to have robust error detection and correction.  This means that each color is only in a set of 3 and must maintain a certain orientation. These methods, like in [[#v2|Cv2]], are part of physical information theory (PIT) or [[physical error correction]] (PEC) which is in contrast to algorithmic error correction (AEC) invented by Hamming.  PEC uses physical properties of data to detect and/or correct and/or prevent errors.  Some of these properties, as also explained in [[#v2|Cv2]], can be replicates, location, orientation, partnering, tagging, keying, contrast, etc.  [[Physical error correction]] is the methodology most used in nature and can be found in DNA, visual field, neurons (such as memory and recall); and other data storage, transmission, and processing.  If PEC is bieng used exclusively over AEC, then the only algorithms used would be in the reading and decoding, not in the encoding.  Only physical factors are used for encoding in purely PEC.  Of course algorithms can be used to choose or dictate how/when PEC is used based on the data used.%0a
host:1611863455=104.175.54.158
author:1611863204=
diff:1611863204:1611859874:=
host:1611863204=104.175.54.158
author:1611859874=
diff:1611859874:1611859631:=345d344%0a%3c The farther the error correction on this level makes it, the %0a
host:1611859874=104.175.54.158
author:1611859631=
diff:1611859631:1611859461:=350c350%0a%3c If all 3 of the sums are different, what do we do?  Firstly I want to say that all 3 being different will be extremely rare since we already have perfect 1-bit error correction and roughly 98%25 2-bit error detection at the base level. But when it does rarely happen we can do something else so we don't loose all the data in the base chromaton just because of a couple errors.  What we will do is take the 2 chromaton with the fewest detected errors (or the least serious errors, 3-bit error more serious than 2-bit). if there is a 3-way tie, favor chromaton with fewest/less serious errors and most similar sums, if still a 3-way tie favor chromaton with the fewest/less serious errors and most different sums, if still a 3-way tie forget about errors and choose the two with the most different sums) and then compare those two at the base chromaton triad level.  Anything that is different between the 2, we check to see if there were any errors detected previously in those spots.  If in one of the chromaton one triad was detected as an error and the other chromaton does not have an error detected in that triad, then the error triad is replaced with the non-error triad.  After all of this what we will be left with is 2 chromaton that are either now identical or only vary in one of two ways.  The first way they can vary is if both have different errors in the same triad.  The second way is they both have different values in the same triad and neither was detected as an error.  In both of these cases the data from the third chromaton is used to fix these.  Even if the third chromaton is wrong or has a detected error in the spot in question, we need a tie breaker, so the data in the third chromaton is used to settle any remaining disputes between the two chromaton being compared.  Now the 2 chromaton that were being compared are identical and are considered the correct version.  Choose the [[#v3number|first chromaton]], basically the one closest to the upper left of the kilochromaton. If you choose a winner here, report a soft error of [#1].  This is the most serious soft error in the kilochromaton level.%0a---%0a> If all 3 of the sums are different, what do we do?  Firstly I want to say that all 3 being different will be extremely rare since we already have perfect 1-bit error correction and roughly 98%25 2-bit error detection at the base level. But when it does rarely happen we can do something else so we don't loose all the data in the base chromaton just because of a couple errors.  What we will do is take the 2 chromaton with the fewest detected errors (or the least serious errors, 3-bit error more serious than 2-bit). if there is a 3-way tie, favor chromaton with fewest/less serious errors and most similar sums, if still a 3-way tie favor chromaton with the fewest/less serious errors and most different sums, if still a 3-way tie forget about errors and choose the two with the most different sums) and then compare those two at the base chromaton triad level.  Anything that is different between the 2, we check to see if there were any errors detected previously in those spots.  If in one of the chromaton one triad was detected as an error and the other chromaton does not have an error detected in that triad, then the error triad is replaced with the non-error triad.  After all of this what we will be left with is 2 chromaton that are either now identical or only vary in one of two ways.  The first way they can vary is if both have different errors in the same triad.  The second way is they both have different values in the same triad and neither was detected as an error.  In both of these cases the data from the third chromaton is used to fix these.  Even if the third chromaton is wrong or has a detected error in the spot in question, we need a tie breaker, so the data in the third chromaton is used to settle any remaining disputes between the two chromaton being compared.  Now the 2 chromaton that were being compared are identical and are considered the correct version.  Choose the [[#v3number|first chromaton]], basically the one closest to the upper left of the kilochromaton. If you choose a winner here, report a soft error of [#1].%0a
host:1611859631=104.175.54.158
author:1611859461=
diff:1611859461:1611859440:=375c375%0a%3c Favor each triad that has fewest detected errors at the base level and/or the least serious errors.  Weight 2-bit and 3-bit errors as their ratio of being corrected correctly.  If there is one best, then choose it as the winner and report a soft error of [#6].  If there is no winner, then carry on the remaining chromaton to step 7.%0a---%0a> Favor each triad that has fewest detected errors at the base level and/or the least serious errors.  Weight 2-bit errors as "2.1" and 3-bit errors as "70.4".  If there is one best, then choose it as the winner and report a soft error of [#6].  If there is no winner, then carry on the remaining chromaton to step 7.%0a
host:1611859461=104.175.54.158
author:1611859440=
diff:1611859440:1611859430:=357c357%0a%3c In the case all 3 have the same sum or two do, pick the one with the least amount of errors (and/or least 3-bit errors since these are more serious than 2-bit) reported in the [[#v3error|original error correction steps]] to use as the "one correct version" ("winner"). Weight 2-bit and 3-bit errors as their ratio of being corrected correctly.  If a winner is chosen here, then report a soft error of [#2].  If a tie between any of the replicates are found, go to step 3.%0a---%0a> In the case all 3 have the same sum or two do, pick the one with the least amount of errors (and/or least 3-bit errors since these are more serious than 2-bit) reported in the [[#v3error|original error correction steps]] to use as the "one correct version" ("winner"). Weight 2-bit and 3-bit errors as thier ratio of bieng corrected correctly.  If a winner is chosen here, then report a soft error of [#2].  If a tie between any of the replicates are found, go to step 3.%0a
host:1611859440=104.175.54.158
author:1611859430=
diff:1611859430:1611858916:=357c357%0a%3c In the case all 3 have the same sum or two do, pick the one with the least amount of errors (and/or least 3-bit errors since these are more serious than 2-bit) reported in the [[#v3error|original error correction steps]] to use as the "one correct version" ("winner"). Weight 2-bit and 3-bit errors as thier ratio of bieng corrected correctly.  If a winner is chosen here, then report a soft error of [#2].  If a tie between any of the replicates are found, go to step 3.%0a---%0a> In the case all 3 have the same sum or two do, pick the one with the least amount of errors (and/or least 3-bit errors since these are more serious than 2-bit) reported in the [[#v3error|original error correction steps]] to use as the "one correct version" ("winner"). Weight 2-bit errors as 2.1 and 3-bit errors as 70.4.  If a winner is chosen here, then report a soft error of [#2].  If a tie between any of the replicates are found, go to step 3.%0a
host:1611859430=104.175.54.158
author:1611858916=
diff:1611858916:1611858899:=384c384%0a%3c We just put these replicates through the wringer!  We now have an excellent gauge on if we have correct data at the kilochromaton level.  The megachromaton level will look at the data from the kilochromaton level and take into account the reported errors at this level.  The higher the "#" error, the less serious it is considered since the higher the # the more hurdles the data overcame before being left with only 1 replicate remaining.%0a---%0a> We just put these replicates through the wringer!  We now have an excellent guage on if we have correct data at the kilochromaton level.  The megachromaton level will look at the data from the kilochromaton level and take into account the reported errors at this level.  The higher the "#" error, the less serious it is considered since the higher the # the more hurdles the data overcame before bieng left with only 1 replicate remaining.%0a
host:1611858916=104.175.54.158
author:1611858899=
diff:1611858899:1611858755:=381c381%0a%3c If all the remaining have the same number and severity of errors, just pick the first chromaton, basically the chromaton closest to the upper left of the kilochromaton and report a soft error of [#7].%0a---%0a> If all the remaining have the same number and severity of errors, just pick the first chromaton, basically the chromaton closest to the upper left of the kilochromaton and report an error of [#7].%0a
host:1611858899=104.175.54.158
author:1611858755=
diff:1611858755:1611858733:=357c357%0a%3c In the case all 3 have the same sum or two do, pick the one with the least amount of errors (and/or least 3-bit errors since these are more serious than 2-bit) reported in the [[#v3error|original error correction steps]] to use as the "one correct version" ("winner"). Weight 2-bit errors as 2.1 and 3-bit errors as 70.4.  If a winner is chosen here, then report a soft error of [#2].  If a tie between any of the replicates are found, go to step 3.%0a---%0a> In the case all 3 have the same sum or two do, pick the one with the least amount of errors (and/or least 3-bit errors since these are more serious than 2-bit) reported in the [[#v3error|original error correction steps]] to use as the "one correct version" ("winner").  If a winner is chosen here, then report a soft error of [#2].  If a tie between any of the replicates are found, go to step 3.%0a
host:1611858755=104.175.54.158
author:1611858733=
diff:1611858733:1611858652:=375c375%0a%3c Favor each triad that has fewest detected errors at the base level and/or the least serious errors.  Weight 2-bit errors as "2.1" and 3-bit errors as "70.4".  If there is one best, then choose it as the winner and report a soft error of [#6].  If there is no winner, then carry on the remaining chromaton to step 7.%0a---%0a> Favor each triad that has fewest detected errors at the base level and/or the least serious errors.  If there is one best, then choose it as the winner and report a soft error of [#6].  If there is no winner, then carry on the remaining chromaton to step 7.%0a
host:1611858733=104.175.54.158
author:1611858652=
diff:1611858652:1611858600:=381c381%0a%3c If all the remaining have the same number and severity of errors, just pick the first chromaton, basically the chromaton closest to the upper left of the kilochromaton and report an error of [#7].%0a---%0a> If the median and the mean vary by the same amount, just pick the first chromaton, basically the chromaton closest to the upper left of the kilochromaton and report an error of [#7].%0a
host:1611858652=104.175.54.158
author:1611858600=
diff:1611858600:1611858580:=378a379,380%0a> !!!!!8. Mean vs median%0a> In this step we pick the one that has its median value the closest to its mean.  Again, (median-mean)^2 and the chromaton with the lowest value for this test wins.  If a winner is found here report a soft error of [#8].  If no winner is found and the remaining have the same mean and median, go to the next step, 9.%0a
host:1611858600=104.175.54.158
author:1611858580=
diff:1611858580:1611858439:=377a378,379%0a> !!!!!7. Average value%0a> If all or 2 chromaton have the lowest and same amount and severity of errors, then then choose the one with the average value closest to 1.5.  To do this add up all the numbers in the matrix.  Next divide by 16 and call that the "answer".  Then take (1.5-answer)^2 and the one with the lowest number wins.  If this is the case and one wins, then report a soft error of [#7].  If the remaining chromaton have average values that are the same, go to the next step, 8.%0a
host:1611858580=104.175.54.158
author:1611858439=
diff:1611858439:1611858420:=382c382%0a%3c In this step we pick the one that has its median value the closest to its mean.  Again, (median-mean)^2 and the chromaton with the lowest value for this test wins.  If a winner is found here report a soft error of [#8].  If no winner is found and the remaining have the same mean and median, go to the next step, 9.%0a---%0a> In this step we pick the one that has its median value the closest to its mean.  Again, (median-mean)^2 and the chromaton with the lowest value for this test wins.  If a winner is found here report an error of [#8].  If no winner is found and the remaining have the same mean and median, go to the next step, 9.%0a
host:1611858439=104.175.54.158
author:1611858420=
diff:1611858420:1611858379:=382c382%0a%3c In this step we pick the one that has its median value the closest to its mean.  Again, (median-mean)^2 and the chromaton with the lowest value for this test wins.  If a winner is found here report an error of [#8].  If no winner is found and the remaining have the same mean and median, go to the next step, 9.%0a---%0a> In this step we pick the one that has its median value the closest to its mean.  Again, (median-mean)^2 and the chromaton with the lowest value for this test wins.  If a winner is found here report an error of [#6].%0a
host:1611858420=104.175.54.158
author:1611858379=
diff:1611858379:1611858369:=381c381%0a%3c !!!!!8. Mean vs median%0a---%0a> !!!!!6. Mean vs median%0a
host:1611858379=104.175.54.158
author:1611858369=
diff:1611858369:1611858324:=379c379%0a%3c If all or 2 chromaton have the lowest and same amount and severity of errors, then then choose the one with the average value closest to 1.5.  To do this add up all the numbers in the matrix.  Next divide by 16 and call that the "answer".  Then take (1.5-answer)^2 and the one with the lowest number wins.  If this is the case and one wins, then report a soft error of [#7].  If the remaining chromaton have average values that are the same, go to the next step, 8.%0a---%0a> If all or 2 chromaton have the lowest and same amount and severity of errors, then then choose the one with the average value closest to 1.5.  To do this add up all the numbers in the matrix.  Next divide by 16 and call that the "answer".  Then take (1.5-answer)^2 and the one with the lowest number wins.  If this is the case and one wins, then report a soft error of [#7].  If the remaining chromaton have average values that are the same, go to step 6.%0a
host:1611858369=104.175.54.158
author:1611858324=
diff:1611858324:1611858227:=382c382%0a%3c In this step we pick the one that has its median value the closest to its mean.  Again, (median-mean)^2 and the chromaton with the lowest value for this test wins.  If a winner is found here report an error of [#6].%0a---%0a> In this step we pick the one that has the median value the closest to the mean.  Again, (median-mean)^2 and the chromaton with the lowest value for this test wins.  If a winner is found here report an error of [#6].%0a
host:1611858324=104.175.54.158
author:1611858227=
diff:1611858227:1611858193:=382c382%0a%3c In this step we pick the one that has the median value the closest to the mean.  Again, (median-mean)^2 and the chromaton with the lowest value for this test wins.  If a winner is found here report an error of [#6].%0a---%0a> If the averages are the same but the values were different between the 2 or 3 remaining replicates, pick the one that has the median value the closest to the mean.  Again, (median-mean)^2 and the chromaton with the lowest value for this test wins.  If a winner is found here report an error of [#6].%0a
host:1611858227=104.175.54.158
author:1611858193=
diff:1611858193:1611858082:=379c379%0a%3c If all or 2 chromaton have the lowest and same amount and severity of errors, then then choose the one with the average value closest to 1.5.  To do this add up all the numbers in the matrix.  Next divide by 16 and call that the "answer".  Then take (1.5-answer)^2 and the one with the lowest number wins.  If this is the case and one wins, then report a soft error of [#7].  If the remaining chromaton have average values that are the same, go to step 6.%0a---%0a> If all or 2 chromaton have the lowest and same amount and severity of errors, then then choose the one with the average value closest to 1.5.  To do this add up all the numbers in the matrix.  Next divide by 16 and call that the "answer".  Then take (1.5-answer)^2 and the one with the lowest number wins.  If this is the case and one wins, then report a soft error of [#7].  If the remaining chromaton have different values yet the average value is the same, go to step 6.%0a
host:1611858193=104.175.54.158
author:1611858082=
diff:1611858082:1611857650:=372,379c372%0a%3c If you are here, then chances are at least 2 of your 3 replicate chromaton are identical.  Congratulations!  For the final check, each and every value is compared between eachother.  We already have the 4x4 matrix set-up for each chromaton and each of the 16 values are compared between eachother.  If they all/both match, great, select the [[#cv3number|first chromaton in the triad]] as the winner, the replicate closest to the upper left of the chromaton, with no error reported!  Simply report a "0" if all 3 replicates matched, and a "1" if 2 of the replicates matched. If they do not match, we go to the next step, step 6.  %0a%3c %0a%3c !!!!!6. Fewest errors%0a%3c Favor each triad that has fewest detected errors at the base level and/or the least serious errors.  If there is one best, then choose it as the winner and report a soft error of [#6].  If there is no winner, then carry on the remaining chromaton to step 7.%0a%3c %0a%3c %0a%3c !!!!!7. Average value%0a%3c If all or 2 chromaton have the lowest and same amount and severity of errors, then then choose the one with the average value closest to 1.5.  To do this add up all the numbers in the matrix.  Next divide by 16 and call that the "answer".  Then take (1.5-answer)^2 and the one with the lowest number wins.  If this is the case and one wins, then report a soft error of [#7].  If the remaining chromaton have different values yet the average value is the same, go to step 6.%0a---%0a> If you are here, then chances are at least 2 of your 3 replicate chromaton are identical.  Congratulations!  For the final check, each and every value is compared between eachother.  We already have the 4x4 matrix set-up for each chromaton and each of the 16 values are compared between eachother.  If they all/both match, great, select the [[#cv3number|first chromaton in the triad]] as the winner, the replicate closest to the upper left of the chromaton, with no error reported!  Simply report a "0" if all 3 replicates matched, and a "1" if 2 of the replicates matched. If they do not match, we will get 2 to match.  To do this favor each triad that has had no detected errors at the base level and/or the least serious errors.  If they all have the same amount and severity of errors, then then choose the two with the average value closest to 1.5.  To do this add up all the numbers in the matrix.  Next divide by 16 and call that the "answer".  Then take (1.5-answer)^2 and the one with the lowest number wins.  If this is the case, then report a soft error of [#5].  If the remaining chromaton have different values yet the average value is the same, go to step 6.%0a
host:1611858082=104.175.54.158
author:1611857650=
diff:1611857650:1611857166:=372c372%0a%3c If you are here, then chances are at least 2 of your 3 replicate chromaton are identical.  Congratulations!  For the final check, each and every value is compared between eachother.  We already have the 4x4 matrix set-up for each chromaton and each of the 16 values are compared between eachother.  If they all/both match, great, select the [[#cv3number|first chromaton in the triad]] as the winner, the replicate closest to the upper left of the chromaton, with no error reported!  Simply report a "0" if all 3 replicates matched, and a "1" if 2 of the replicates matched. If they do not match, we will get 2 to match.  To do this favor each triad that has had no detected errors at the base level and/or the least serious errors.  If they all have the same amount and severity of errors, then then choose the two with the average value closest to 1.5.  To do this add up all the numbers in the matrix.  Next divide by 16 and call that the "answer".  Then take (1.5-answer)^2 and the one with the lowest number wins.  If this is the case, then report a soft error of [#5].  If the remaining chromaton have different values yet the average value is the same, go to step 6.%0a---%0a> If you are here, then chances are at least 2 of your 3 replicate chromaton are identical.  Congratulations!  For the final check, each and every value is compared between eachother.  We already have the 4x4 matrix set-up for each chromaton and each of the 16 values are compared between eachother.  If they all/both match, great, select the [[#cv3number|first chromaton in the triad]] as the winner, the replicate closest to the upper left of the chromaton, with no error reported!  Simply report a "0" if all 3 replicates matched, and a "1" if 2 of the replicates matched. If they do not match, then choose the one with the average value closest to 1.5.  To do this add up all the numbers in the matrix.  Next divide by 16 and call that the "answer".  Then take (1.5-answer)^2 and the one with the lowest number wins.  If this is the case, then report a soft error of [#5].  If the remaining chromaton have different values yet the average value is the same, go to step 6.%0a
host:1611857650=104.175.54.158
author:1611857166=
diff:1611857166:1611857050:=350c350%0a%3c If all 3 of the sums are different, what do we do?  Firstly I want to say that all 3 being different will be extremely rare since we already have perfect 1-bit error correction and roughly 98%25 2-bit error detection at the base level. But when it does rarely happen we can do something else so we don't loose all the data in the base chromaton just because of a couple errors.  What we will do is take the 2 chromaton with the fewest detected errors (or the least serious errors, 3-bit error more serious than 2-bit). if there is a 3-way tie, favor chromaton with fewest/less serious errors and most similar sums, if still a 3-way tie favor chromaton with the fewest/less serious errors and most different sums, if still a 3-way tie forget about errors and choose the two with the most different sums) and then compare those two at the base chromaton triad level.  Anything that is different between the 2, we check to see if there were any errors detected previously in those spots.  If in one of the chromaton one triad was detected as an error and the other chromaton does not have an error detected in that triad, then the error triad is replaced with the non-error triad.  After all of this what we will be left with is 2 chromaton that are either now identical or only vary in one of two ways.  The first way they can vary is if both have different errors in the same triad.  The second way is they both have different values in the same triad and neither was detected as an error.  In both of these cases the data from the third chromaton is used to fix these.  Even if the third chromaton is wrong or has a detected error in the spot in question, we need a tie breaker, so the data in the third chromaton is used to settle any remaining disputes between the two chromaton being compared.  Now the 2 chromaton that were being compared are identical and are considered the correct version.  Choose the [[#v3number|first chromaton]], basically the one closest to the upper left of the kilochromaton. If you choose a winner here, report a soft error of [#1].%0a---%0a> If all 3 of the sums are different, what do we do?  Firstly I want to say that all 3 being different will be extremely rare since we already have perfect 1-bit error correction and roughly 98%25 2-bit error detection at the base level. But when it does rarely happen we can do something else so we don't loose all the data in the base chromaton just because of a couple errors.  What we will do is take the 2 chromaton with the fewest detected errors (or the least serious errors, 3-bit error more serious than 2-bit). if there is a 3-way tie, favor chromaton with fewest errors and most similar sums, if still a 3-way tie favor chromaton with the fewest errors and most different sums, if still a 3-way tie forget about errors and choose the two with the most different sums) and then compare those two at the base chromaton triad level.  Anything that is different between the 2, we check to see if there were any errors detected previously in those spots.  If in one of the chromaton one triad was detected as an error and the other chromaton does not have an error detected in that triad, then the error triad is replaced with the non-error triad.  After all of this what we will be left with is 2 chromaton that are either now identical or only vary in one of two ways.  The first way they can vary is if both have different errors in the same triad.  The second way is they both have different values in the same triad and neither was detected as an error.  In both of these cases the data from the third chromaton is used to fix these.  Even if the third chromaton is wrong or has a detected error in the spot in question, we need a tie breaker, so the data in the third chromaton is used to settle any remaining disputes between the two chromaton being compared.  Now the 2 chromaton that were being compared are identical and are considered the correct version.  Choose the [[#v3number|first chromaton]], basically the one closest to the upper left of the kilochromaton. If you choose a winner here, report a soft error of [#1].%0a
host:1611857166=104.175.54.158
author:1611857050=
diff:1611857050:1611856710:=350c350%0a%3c If all 3 of the sums are different, what do we do?  Firstly I want to say that all 3 being different will be extremely rare since we already have perfect 1-bit error correction and roughly 98%25 2-bit error detection at the base level. But when it does rarely happen we can do something else so we don't loose all the data in the base chromaton just because of a couple errors.  What we will do is take the 2 chromaton with the fewest detected errors (or the least serious errors, 3-bit error more serious than 2-bit). if there is a 3-way tie, favor chromaton with fewest errors and most similar sums, if still a 3-way tie favor chromaton with the fewest errors and most different sums, if still a 3-way tie forget about errors and choose the two with the most different sums) and then compare those two at the base chromaton triad level.  Anything that is different between the 2, we check to see if there were any errors detected previously in those spots.  If in one of the chromaton one triad was detected as an error and the other chromaton does not have an error detected in that triad, then the error triad is replaced with the non-error triad.  After all of this what we will be left with is 2 chromaton that are either now identical or only vary in one of two ways.  The first way they can vary is if both have different errors in the same triad.  The second way is they both have different values in the same triad and neither was detected as an error.  In both of these cases the data from the third chromaton is used to fix these.  Even if the third chromaton is wrong or has a detected error in the spot in question, we need a tie breaker, so the data in the third chromaton is used to settle any remaining disputes between the two chromaton being compared.  Now the 2 chromaton that were being compared are identical and are considered the correct version.  Choose the [[#v3number|first chromaton]], basically the one closest to the upper left of the kilochromaton. If you choose a winner here, report a soft error of [#1].%0a---%0a> If all 3 of the sums are different, what do we do?  Firstly I want to say that all 3 being different will be extremely rare since we already have perfect 1-bit error correction and roughly 98%25 2-bit error detection at the base level. But when it does rarely happen we can do something else so we don't loose all the data in the base chromaton just because of a couple errors.  What we will do is take the 2 chromaton with the fewest detected errors (or the least serious errors, 3-bit error more serious than 2-bit. if there is a 3-way tie, favor chromaton with fewest errors and most similar sums, if still a 3-way tie favor chromaton with the fewest errors and most different sums, if still a 3-way tie forget about errors and choose the two with the most different sums) and then compare those two at the base chromaton triad level.  Anything that is different between the 2, we check to see if there were any errors detected previously in those spots.  If in one of the chromaton one triad was detected as an error and the other chromaton does not have an error detected in that triad, then the error triad is replaced with the non-error triad.  After all of this what we will be left with is 2 chromaton that are either now identical or only vary in one of two ways.  The first way they can vary is if both have different errors in the same triad.  The second way is they both have different values in the same triad and neither was detected as an error.  In both of these cases the data from the third chromaton is used to fix these.  Even if the third chromaton is wrong or has a detected error in the spot in question, we need a tie breaker, so the data in the third chromaton is used to settle any remaining disputes between the two chromaton being compared.  Now the 2 chromaton that were being compared are identical and are considered the correct version.  Choose the [[#v3number|first chromaton]], basically the one closest to the upper left of the kilochromaton. If you choose a winner here, report a soft error of [#1].%0a
host:1611857050=104.175.54.158
author:1611856710=
diff:1611856710:1611856554:=297c297%0a%3c To get rid of the color filters in Cv2, we need to use 3-color triads instead of 2-color pairs.  We will also force orientation in certain ways so there are 12 colors and only base-4.  We are giving up 8 bases (2/3rds) in order to have robust error detection and correction.  This means that each color is only in a set of 3 and must maintain a certain orientation. These methods, like in [[#v2|Cv2]], are part of physical information theory (PIT) or [[physical error correction]] (PEC) which is in contrast to algorithmic error correction (AEC) invented by Hamming.  PEC uses physical properties of data to detect and/or correct and/or prevent errors.  Some of these properties, as also explained in [[#v2|Cv2]], can be replicates, location, orientation, partnering, tagging, keying, contrast, etc.  [[Physical error correction]] is the methodology most used in nature and can be found in DNA, visual field, neurons (such as memory and recall); and other data storage, transmission, and processing.  If PEC is bieng used exclusively over AEC, then the only algorithms used would be in the reading and decoding, not in the encoding.  Only physical factors are used for encoding in purely PEC.  Of course algorithms can be used to choose or dictate how/when PEC is used based on the data used.%0a---%0a> To get rid of the color filters in Cv2, we need to use 3-color triads instead of 2-color pairs.  We will also force orientation in certain ways so there are 12 colors and only base-4.  We are giving up 8 bases (2/3rds) in order to have robust error detection and correction.  This means that each color is only in a set of 3 and must maintain a certain orientation. These methods, like in [[#v2|Cv2]], are part of physical information theory (PIT) or [[physical error correction]] (PEC) which is in contrast to algorithmic error correction (AEC) invented by Hamming.  PEC uses physical properties of data to detect and/or correct and/or prevent errors.  Some of these properties, as also explained in [[#v2|Cv2]], can be location, orientation, partnering, tagging, keying, contrast, etc.  [[Physical error correction]] is the methodology most used in nature and can be found in DNA, visual field, neurons (such as memory and recall); and other data storage, transmission, and processing.  If PEC is bieng used exclusively over AEC, then the only algorithms used would be in the reading and decoding, not in the encoding.  Only physical factors are used for encoding in purely PEC.  Of course algorithms can be used to choose or dictate how/when PEC is used based on the data used.%0a
host:1611856710=104.175.54.158
author:1611856554=
diff:1611856554:1611856393:=337c337%0a%3c These were figured out using the below color wheel to get colors in the same possible position spaced out as far as possible on the color wheel.  This is an example of the PEC called "contrast".%0a---%0a> These were figured out using the below color wheel to get colors in the same possible position spaced out as far as possible on the color wheel.%0a
host:1611856554=104.175.54.158
author:1611856393=
diff:1611856393:1611856215:=328c328%0a%3c We have a 97.9%25 2-bit error detection and correction rate and 100%25 1-bit error detection and correction rate.  This is excellent, triads of Cv3 when compared to the pairs of Cv2, Cv2 only had 50%25 2-bit error detection (without filters) whereas with Cv3 and 3 bits, we get 97.9%25 2-bit error detection.  This is more than enough especially when using kilochromaton and higher as it will correct even more errors. 2-bit errors are still recorded because of the small chance it was corrected wrongly. %0a---%0a> We have a 97.9%25 2-bit error detection and correction rate and 100%25 1-bit error detection and correction rate.  This is excellent, triads of Cv3 when compared to the pairs of Cv2, Cv2 only had 50%25 2-bit error detection (without filters) whereas with Cv3 and 3 bits, we get 97.9%25 2-bit error detection.  This is more than enough especially when using kilochromaton and higher as it will correct even more errors.%0a
host:1611856393=104.175.54.158
author:1611856215=
diff:1611856215:1611855672:=321c321%0a%3c The chance a 3-bit error is undetected and looks like a 1-bit error or no error is 0.704*(1-(11/12)*(11/12)) = 11.2%25.  This means that there is a 70.4%25 chance of at least one spot having an allowable color and then at least one of the remaining spots having the exact right color, a 1/12 chance.  So 11.2%25 of 3-bit errors look like at least 2 of the colors are in the right spot. Using the below calculation, the chance a 3-bit error looks like a 1-bit error exactly, that 2 of the colors are correct and 1 is wrong is 11.2 - 0.23 = 10.97%25 chance, see the calculation below for how we got the 0.23.%0a---%0a> The chance a 3-bit error is undetected and looks like a 1-bit error or no error is 0.704*(1-(11/12)*(11/12)) = 11.2%25.  This means that there is a 70.4%25 chance of at least one spot having an allowable color and then at least one of the remaining spots having the exact right color, a 1/12 chance.  So 11.2%25 of 3-bit errors look like at least 2 of the colors are in the right spot. Using the below calculation, the chance a 3-bit error looks like a 1-bit error exactly, that 2 of the colors are correct and 1 is wrong is 11.2 - 0.23 = 10.97%25 chance.%0a
host:1611856215=104.175.54.158
author:1611855672=
diff:1611855672:1611855584:=297c297%0a%3c To get rid of the color filters in Cv2, we need to use 3-color triads instead of 2-color pairs.  We will also force orientation in certain ways so there are 12 colors and only base-4.  We are giving up 8 bases (2/3rds) in order to have robust error detection and correction.  This means that each color is only in a set of 3 and must maintain a certain orientation. These methods, like in [[#v2|Cv2]], are part of physical information theory (PIT) or [[physical error correction]] (PEC) which is in contrast to algorithmic error correction (AEC) invented by Hamming.  PEC uses physical properties of data to detect and/or correct and/or prevent errors.  Some of these properties, as also explained in [[#v2|Cv2]], can be location, orientation, partnering, tagging, keying, contrast, etc.  [[Physical error correction]] is the methodology most used in nature and can be found in DNA, visual field, neurons (such as memory and recall); and other data storage, transmission, and processing.  If PEC is bieng used exclusively over AEC, then the only algorithms used would be in the reading and decoding, not in the encoding.  Only physical factors are used for encoding in purely PEC.  Of course algorithms can be used to choose or dictate how/when PEC is used based on the data used.%0a---%0a> To get rid of the color filters in Cv2, we need to use 3-color triads instead of 2-color pairs.  We will also force orientation in certain ways so there are 12 colors and only base-4.  We are giving up 8 bases (2/3rds) in order to have robust error detection and correction.  This means that each color is only in a set of 3 and must maintain a certain orientation. These methods, like in [[#v2|Cv2]], are part of physical information theory (PIT) or [[physical error correction]] (PEC) which is in contrast to algorithmic error correction (AEC) invented by Hamming.  PEC uses physical properties of data to detect and/or correct and/or prevent errors.  Some of these properties, as also explained in [[#v2|Cv2]], can be location, orientation, partnering, tagging, keying, contrast, etc.  [[Physical error correction]] is the methodology most used in nature and can be found in DNA, visual field, neurons (such as memory and recall); and other data storage, transmission, and processing.  If PEC is bieng used exclusively over AEC, then the only algorithms used would be in the reading and decoding, not in the encoding.  Only physical factors are used for encoding in purely PEC.%0a
host:1611855672=104.175.54.158
author:1611855584=
diff:1611855584:1611855519:=297c297%0a%3c To get rid of the color filters in Cv2, we need to use 3-color triads instead of 2-color pairs.  We will also force orientation in certain ways so there are 12 colors and only base-4.  We are giving up 8 bases (2/3rds) in order to have robust error detection and correction.  This means that each color is only in a set of 3 and must maintain a certain orientation. These methods, like in [[#v2|Cv2]], are part of physical information theory (PIT) or [[physical error correction]] (PEC) which is in contrast to algorithmic error correction (AEC) invented by Hamming.  PEC uses physical properties of data to detect and/or correct and/or prevent errors.  Some of these properties, as also explained in [[#v2|Cv2]], can be location, orientation, partnering, tagging, keying, contrast, etc.  [[Physical error correction]] is the methodology most used in nature and can be found in DNA, visual field, neurons (such as memory and recall); and other data storage, transmission, and processing.  If PEC is bieng used exclusively over AEC, then the only algorithms used would be in the reading and decoding, not in the encoding.  Only physical factors are used for encoding in purely PEC.%0a---%0a> To get rid of the color filters in Cv2, we need to use 3-color triads instead of 2-color pairs.  We will also force orientation in certain ways so there are 12 colors and only base-4.  We are giving up 8 bases (2/3rds) in order to have robust error detection and correction.  This means that each color is only in a set of 3 and must maintain a certain orientation. These methods, like in [[#v2|Cv2]], are part of physical information theory (PIT) or [[physical error correction]] (PEC) which is in contrast to algorithmic error correction (AEC) invented by Hamming.  PEC uses physical properties of data to detect and/or correct and/or prevent errors.  Some of these properties, as also explained in [[#v2|Cv2]], can be location, orientation, partnering, tagging, contrast, etc.  [[Physical error correction]] is the methodology most used in nature and can be found in DNA, visual field, neurons (such as memory and recall); and other data storage, transmission, and processing.  If PEC is bieng used exclusively over AEC, then the only algorithms used would be in the reading and decoding, not in the encoding.  Only physical factors are used for encoding in purely PEC.%0a
host:1611855584=79.141.162.81
author:1611855519=
diff:1611855519:1611854476:=297c297%0a%3c To get rid of the color filters in Cv2, we need to use 3-color triads instead of 2-color pairs.  We will also force orientation in certain ways so there are 12 colors and only base-4.  We are giving up 8 bases (2/3rds) in order to have robust error detection and correction.  This means that each color is only in a set of 3 and must maintain a certain orientation. These methods, like in [[#v2|Cv2]], are part of physical information theory (PIT) or [[physical error correction]] (PEC) which is in contrast to algorithmic error correction (AEC) invented by Hamming.  PEC uses physical properties of data to detect and/or correct and/or prevent errors.  Some of these properties, as also explained in [[#v2|Cv2]], can be location, orientation, partnering, tagging, contrast, etc.  [[Physical error correction]] is the methodology most used in nature and can be found in DNA, visual field, neurons (such as memory and recall); and other data storage, transmission, and processing.  If PEC is bieng used exclusively over AEC, then the only algorithms used would be in the reading and decoding, not in the encoding.  Only physical factors are used for encoding in purely PEC.%0a---%0a> To get rid of the color filters in Cv2, we need to use 3-color triads instead of 2-color pairs.  We will also force orientation in certain ways so there are 12 colors and only base-4.  We are giving up 8 bases (2/3rds) in order to have robust error detection and correction.  This means that each color is only in a set of 3 and must maintain a certain orientation. These methods, like in [[#v2|Cv2]], are part of physical information theory (PIT) or [[physical error correction]] (PEC) which is in contrast to algorithmic error correction (AEC) invented by Hamming.  PEC uses physical properties of data to detect and/or correct and/or prevent errors.  Some of these properties, as also explained in [[#v2|Cv2]], can be location, orientation, partnering, tagging, contrast, etc.  [[Physical error correction]] is the methodology most used in nature and can be found in DNA, visual field, neurons (such as memory and recall); and other data storage, transmission, and processing.%0a
host:1611855519=79.141.162.81
author:1611854476=
diff:1611854476:1611854352:=10c10%0a%3c (:Archive:[[https://archive.vn/oMUtN|Archive.is]], [[https://web.archive.org/web/20210128172139/http://www.naturewiki.org/wiki/pmwiki.php/NatureWiki/Chromaton|Archive.org]]:)%0a---%0a> (:Archive:[[https://archive.vn/oMUtN|Archive.is]], [[https://web.archive.org/web/20210123060721/http://www.naturewiki.org/wiki/pmwiki.php/NatureWiki/Chromaton|Archive.org]]:)%0a
host:1611854476=79.141.162.81
author:1611854352=
diff:1611854352:1611851724:=10c10%0a%3c (:Archive:[[https://archive.vn/oMUtN|Archive.is]], [[https://web.archive.org/web/20210123060721/http://www.naturewiki.org/wiki/pmwiki.php/NatureWiki/Chromaton|Archive.org]]:)%0a---%0a> (:Archive:[[https://archive.is/W0na9|Archive.is]], [[https://web.archive.org/web/20210123060721/http://www.naturewiki.org/wiki/pmwiki.php/NatureWiki/Chromaton|Archive.org]]:)%0a
host:1611854352=79.141.162.81
author:1611851724=
diff:1611851724:1611848858:=6c6%0a%3c (:Update:1/28/2021:)%0a---%0a> (:Update:1/24/2021:)%0a
host:1611851724=104.175.54.158
author:1611848858=
diff:1611848858:1611848783:=353c353%0a%3c If 2 or more agree on the sum without performing the "all different" protocol above, then this is great; if the sums equal then the overwhelming chance is the chromaton are in fact the same. However we still have to decide which one to correct it to!  We can't just keep all the chromaton since they are replicates at this level.  One idea would be to choose one randomly.  The reason we won't do this is 2-fold.  Firstly it would take a lot of processing power to run a pseudorandom algorithm every time we needed to make a decision.  Another reason is random algorithms can be cracked and a malicious attacker could know ahead of time which one you will pick and insert a malicious chromaton in the position that he knows will beat the detection.  So we need to use actual intelligent decisions so we are all on the same page.  The following techniques will go from fast and easy to slower and more complicated.  If the fast and simple methods can converge us on an answer then it will save us time and give us soft errors that will tell us how close our data is to perfect, and if not then we go to the more expensive techniques. See history of error correction for more info on the following checks [[https://www.techradar.com/news/computing/how-error-detection-and-correction-works-1080736|#]].%0a---%0a> If 2 or more agree on the sum without performing the "all different" protocol above, then this is great; if the sums equal then the overwhelming chance is the chromaton are in fact the same. However we still have to decide which one to correct it to!  We can't just keep all the chromaton since they are replicates at this level.  One idea would be to choose one randomly.  The reason we won't do this is 2-fold.  Firstly it would take a lot of processing power to run a pseudorandom algorithm every time we needed to make a decision.  Another reason is random algorithms can be cracked and a malicious attacker could know ahead of time which one you will pick and insert a malicious chromaton in the position that he knows will beat the detection.  So we need to use actual intelligent decisions so we are all on the same page.  The following techniques will go from fast and easy to slower and more complicated.  If the fast and simple methods can converge us on an answer then it will save us time, and if not then we go to the more expensive techniques. See history of error correction for more info on the following checks [[https://www.techradar.com/news/computing/how-error-detection-and-correction-works-1080736|#]].%0a
host:1611848858=104.175.54.158
author:1611848783=
diff:1611848783:1611848727:=370c370%0a%3c !!!!!5. Compare each value%0a---%0a> !!!!!5. Final comparison%0a
host:1611848783=104.175.54.158
author:1611848727=
diff:1611848727:1611848483:=374,378c374,375%0a%3c !!!!!6. Mean vs median%0a%3c If the averages are the same but the values were different between the 2 or 3 remaining replicates, pick the one that has the median value the closest to the mean.  Again, (median-mean)^2 and the chromaton with the lowest value for this test wins.  If a winner is found here report an error of [#6].%0a%3c %0a%3c !!!!!7. All else%0a%3c If the median and the mean vary by the same amount, just pick the first chromaton, basically the chromaton closest to the upper left of the kilochromaton and report an error of [#7].%0a---%0a> !!!!!6. All else%0a> If the averages are the same but the values were different between the 2 or 3 remaining replicates, pick the first chromaton, basically the chromaton closest to the upper left of the kilochromaton and report an error of [#6].%0a
host:1611848727=104.175.54.158
author:1611848483=
diff:1611848483:1611848411:=372c372%0a%3c If you are here, then chances are at least 2 of your 3 replicate chromaton are identical.  Congratulations!  For the final check, each and every value is compared between eachother.  We already have the 4x4 matrix set-up for each chromaton and each of the 16 values are compared between eachother.  If they all/both match, great, select the [[#cv3number|first chromaton in the triad]] as the winner, the replicate closest to the upper left of the chromaton, with no error reported!  Simply report a "0" if all 3 replicates matched, and a "1" if 2 of the replicates matched. If they do not match, then choose the one with the average value closest to 1.5.  To do this add up all the numbers in the matrix.  Next divide by 16 and call that the "answer".  Then take (1.5-answer)^2 and the one with the lowest number wins.  If this is the case, then report a soft error of [#5].  If the remaining chromaton have different values yet the average value is the same, go to step 6.%0a---%0a> If you are here, then chances are at least 2 of your 3 replicate chromaton are identical.  Congratulations!  For the final check, each and every value is compared between eachother.  We already have the 4x4 matrix set-up for each chromaton and each of the 16 values are compared between eachother.  If they all/both match, great, select the [[#cv3number|first chromaton in the triad]] as the winner, the replicate closest to the upper left of the chromaton, with no error reported!  Simply report a "0" if all 3 replicates matched, and a "1" if 2 of the replicates matched. If they do not match, then choose the one with the average value closest to 1.5.  To do this add up all the numbers in the matrix.  Next divide by 16 and call that the "answer".  Then take (1.5-answer)^2 and the one with the lowest number wins.  If this is the case, then report a soft error of [#5].  %0a
host:1611848483=104.175.54.158
author:1611848411=
diff:1611848411:1611848156:=372c372%0a%3c If you are here, then chances are at least 2 of your 3 replicate chromaton are identical.  Congratulations!  For the final check, each and every value is compared between eachother.  We already have the 4x4 matrix set-up for each chromaton and each of the 16 values are compared between eachother.  If they all/both match, great, select the [[#cv3number|first chromaton in the triad]] as the winner, the replicate closest to the upper left of the chromaton, with no error reported!  Simply report a "0" if all 3 replicates matched, and a "1" if 2 of the replicates matched. If they do not match, then choose the one with the average value closest to 1.5.  To do this add up all the numbers in the matrix.  Next divide by 16 and call that the "answer".  Then take (1.5-answer)^2 and the one with the lowest number wins.  If this is the case, then report a soft error of [#5].  %0a---%0a> If you are here, then chances are at least 2 of your 3 replicate chromaton are identical.  Congratulations!  For the final check, each and every value is compared between eachother.  A 4x4 matrix is set-up for each chromaton and each of the 16 values are compared between eachother.  If they all/both match, great, select the [[#cv3number|first chromaton in the triad]] as the winner, the replicate closest to the upper left of the chromaton, with no error reported!  Simply report a "0" if all 3 replicates matched, and a "1" if 2 of the replicates matched. If they do not match, then choose the one with the average value closest to 1.5.  To do this add up all the numbers in the matrix.  Next divide by 16 and call that the "answer".  Then take (1.5-answer)^2 and the one with the lowest number wins.  If this is the case, then report a soft error of [#5].  %0a
host:1611848411=104.175.54.158
author:1611848156=
diff:1611848156:1611847911:=361c361%0a%3c A parity check is a count of how many times a certain value showed up in our chromaton. Add up the number of each type of triad, our base-4 numbers. So add up the number of each "0"s, the "1"s, the "2"s, and the "3"s. And compare the results across the remaining chromaton.  This would be something like chromaton1 contains 5x "0", 10x "1", 1x "2", 0x "3".  Now if chromaton2 matches chromaton1 parity check but chromaton3 has a different parity check, then we can exclude chromaton3.  If all remaining replicate chromaton have different parity checks, then choose the one with the most even distribution of numbers. We can use a sort of "r^2 method". In our case there are 16 numbers so an even distribution would be 4x of each 0,1,2,3. Our r^2 method would subtract our actual number by 4 and then square the value.  So for our sample set it would be (5-4)^2 + (10-4)^2 + (1-4)^2 + (0-4)^2.  Now choose the one with the lowest value of this test.  After this test the only errors that would be matching is if all the right values were included in both chromaton, but the location of the values were different.  If a winner is chosen here report a soft error of [#3].  If 2 or 3 of the replicate chromaton have the same parity check go to step 4.%0a---%0a> A parity check is a count of how many times a certain value showed up in our chromaton. Add up the number of each type of triad, our base-4 numbers. So add up the number of each "0"s, the "1"s, the "2"s, and the "3"s. And compare the results across the remaining chromaton.  This would be something like chromaton1 contains 5x "0", 10x "1", 1x "2", 0x "3".  Now if chromaton2 matches chromaton1 parity check but chromaton3 has a different parity check, then we can exclude chromaton3.  If only 2 replicate chromaton of the three remain and have different parity checks, then choose the one with the most even distribution of numbers. We can use a sort of "r^2 method". In our case there are 16 numbers so an even distribution would be 4x of each 0,1,2,3. Our r^2 method would subtract our actual number by 4 and then square the value.  So for our sample set it would be (5-4)^2 + (10-4)^2 + (1-4)^2 + (0-4)^2.  Now choose the one with the lowest value of this test.  After this test the only errors that would be matching is if all the right values were included in both chromaton, but the location of the values were different.  If a winner is chosen here report a soft error of [#3].  If 2 or 3 of the replicate chromaton have the same parity check go to step 4.%0a
host:1611848156=104.175.54.158
author:1611847911=
diff:1611847911:1611847755:=353c353%0a%3c If 2 or more agree on the sum without performing the "all different" protocol above, then this is great; if the sums equal then the overwhelming chance is the chromaton are in fact the same. However we still have to decide which one to correct it to!  We can't just keep all the chromaton since they are replicates at this level.  One idea would be to choose one randomly.  The reason we won't do this is 2-fold.  Firstly it would take a lot of processing power to run a pseudorandom algorithm every time we needed to make a decision.  Another reason is random algorithms can be cracked and a malicious attacker could know ahead of time which one you will pick and insert a malicious chromaton in the position that he knows will beat the detection.  So we need to use actual intelligent decisions so we are all on the same page.  The following techniques will go from fast and easy to slower and more complicated.  If the fast and simple methods can converge us on an answer then it will save us time, and if not then we go to the more expensive techniques. See history of error correction for more info on the following checks [[https://www.techradar.com/news/computing/how-error-detection-and-correction-works-1080736|#]].%0a---%0a> If 2 or more agree on the sum without performing the "all different" protocol above, then this is great; if the sums equal then the overwhelming chance is the chromaton are in fact the same. However we still have to decide which one to correct it to!  We can't just keep all the chromaton since they are replicates at this level.  One idea would be to choose one randomly.  The reason we won't do this is 2-fold.  Firstly it would take a lot of processing power to run a pseudorandom algorithm every time we needed to make a decision.  Another reason is random algorithms can be cracked and a malicious attacker could know ahead of time which one you will pick and insert a malicious chromaton in the position that he knows will beat the detection.  So we need to use actual intelligent decisions so we are all on the same page.  The following techniques will go from fast and easy to slower and more complicated.  We hope the fast and simple methods can converge us on an answer, and if not then we go to the more expensive techniques. See history of error correction for more info on the following checks [[https://www.techradar.com/news/computing/how-error-detection-and-correction-works-1080736|#]].%0a
host:1611847911=104.175.54.158
author:1611847755=
diff:1611847755:1611847704:=346,347c346,347%0a%3c Kilochromaton (and higher) gives us another check of the lower chromaton we are reading.  At this level we use "sum" of the lower level.  So first we decode and [[#v3error|error correct all base level]] chromaton.  Then we sum up all the numbers contained in each chromaton and this is the sum, one for each chromaton.  In kilochromaton level we compare the three sums for each replicate chromaton.  If all 3 are the same then we verified that everything is perfect (we have 16 base-4 numbers so the chance that we randomly got the sums to equal yet actually be wrong is 1/64 × 1/64 × 1/64 = 3.8×10^(-6) or 4 times in 1 million).  But for 2 of them to randomly give the same sum wrongly is 1/64 * (1-(63/64)*(63/64)) = 0.049%25 or 484 times in a million.  So since we will accept if 2 of them add to the same sum, we will have a 99.95%25 correct - error correction rate.  This not only corrects 1-bit errors at this level, this corrects up to 48-bit errors!  An entire base chromaton could be wrong and it could be fixed at this level. If 2 or 3 replicates have the same sum, go to [[#samesum|this step]] next. If not, go to the below step.%0a%3c %0a---%0a> Kilochromaton (and higher) gives us another check of the lower chromaton we are reading.  At this level we use "sum" of the lower level.  So first we decode and [[#v3error|error correct all base level]] chromaton.  Then we sum up all the numbers contained in each chromaton and this is the sum, one for each chromaton.  In kilochromaton level we compare the three sums for each replicate chromaton.  If all 3 are the same then we verified that everything is perfect (we have 16 base-4 numbers so the chance that we randomly got the sums to equal yet actually be wrong is 1/64 × 1/64 × 1/64 = 3.8×10^(-6) or 4 times in 1 million).  But for 2 of them to randomly give the same sum wrongly is 1/64 * (1-(63/64)*(63/64)) = 0.049%25 or 484 times in a million.  So since we will accept if 2 of them add to the same sum, we will have a 99.95%25 correct - error correction rate.  This not only corrects 1-bit errors at this level, this corrects up to 48-bit errors!  An entire base chromaton could be wrong and it could be fixed at this level. If 2 or 3 replicates have the same sum, go to [[#samesum|this step]] next.%0a> %0a352c352%0a%3c !!!!!!Two or three same [[#samesum]]%0a---%0a> !!!!!!Two or three same%0a
host:1611847755=104.175.54.158
author:1611847704=
diff:1611847704:1611847542:=346c346%0a%3c Kilochromaton (and higher) gives us another check of the lower chromaton we are reading.  At this level we use "sum" of the lower level.  So first we decode and [[#v3error|error correct all base level]] chromaton.  Then we sum up all the numbers contained in each chromaton and this is the sum, one for each chromaton.  In kilochromaton level we compare the three sums for each replicate chromaton.  If all 3 are the same then we verified that everything is perfect (we have 16 base-4 numbers so the chance that we randomly got the sums to equal yet actually be wrong is 1/64 × 1/64 × 1/64 = 3.8×10^(-6) or 4 times in 1 million).  But for 2 of them to randomly give the same sum wrongly is 1/64 * (1-(63/64)*(63/64)) = 0.049%25 or 484 times in a million.  So since we will accept if 2 of them add to the same sum, we will have a 99.95%25 correct - error correction rate.  This not only corrects 1-bit errors at this level, this corrects up to 48-bit errors!  An entire base chromaton could be wrong and it could be fixed at this level. If 2 or 3 replicates have the same sum, go to [[#samesum|this step]] next.%0a---%0a> Kilochromaton (and higher) gives us another check of the lower chromaton we are reading.  At this level we use "sum" of the lower level.  So first we decode and [[#v3error|error correct all base level]] chromaton.  Then we sum up all the numbers contained in each chromaton and this is the sum, one for each chromaton.  In kilochromaton level we compare the three sums for each replicate chromaton.  If all 3 are the same then we verified that everything is perfect (we have 16 base-4 numbers so the chance that we randomly got the sums to equal yet actually be wrong is 1/64 × 1/64 × 1/64 = 3.8×10^(-6) or 4 times in 1 million).  But for 2 of them to randomly give the same sum wrongly is 1/64 * (1-(63/64)*(63/64)) = 0.049%25 or 484 times in a million.  So since we will accept if 2 of them add to the same sum, we will have a 99.95%25 correct - error correction rate.  This not only corrects 1-bit errors at this level, this corrects up to 48-bit errors!  An entire base chromaton could be wrong and it could be fixed at this level. %0a
host:1611847704=104.175.54.158
author:1611847542=
diff:1611847542:1611847486:=381c381%0a%3c %0a---%0a> !!!!!All else%0a
host:1611847542=104.175.54.158
author:1611847486=
diff:1611847486:1611847466:=378c378%0a%3c We just put these replicates through the wringer!  We now have an excellent guage on if we have correct data at the kilochromaton level.  The megachromaton level will look at the data from the kilochromaton level and take into account the reported errors at this level.  The higher the "#" error, the less serious it is considered since the higher the # the more hurdles the data overcame before bieng left with only 1 replicate remaining.%0a---%0a> We just put these replicates through the ringer!  We now have an excellent guage on if we have correct data at the kilochromaton level.  The megachromaton level will look at the data from the kilochromaton level and take into account the reported errors at this level.  The higher the "#" error, the less serious it is considered since the higher the # the more hurdles the data overcame before bieng left with only 1 replicate remaining.%0a
host:1611847486=104.175.54.158
author:1611847466=
diff:1611847466:1611847420:=374c374%0a%3c !!!!!6. All else%0a---%0a> !!!!!All else%0a
host:1611847466=104.175.54.158
author:1611847420=
diff:1611847420:1611847133:=372,379c372,373%0a%3c If you are here, then chances are at least 2 of your 3 replicate chromaton are identical.  Congratulations!  For the final check, each and every value is compared between eachother.  A 4x4 matrix is set-up for each chromaton and each of the 16 values are compared between eachother.  If they all/both match, great, select the [[#cv3number|first chromaton in the triad]] as the winner, the replicate closest to the upper left of the chromaton, with no error reported!  Simply report a "0" if all 3 replicates matched, and a "1" if 2 of the replicates matched. If they do not match, then choose the one with the average value closest to 1.5.  To do this add up all the numbers in the matrix.  Next divide by 16 and call that the "answer".  Then take (1.5-answer)^2 and the one with the lowest number wins.  If this is the case, then report a soft error of [#5].  %0a%3c %0a%3c !!!!!All else%0a%3c If the averages are the same but the values were different between the 2 or 3 remaining replicates, pick the first chromaton, basically the chromaton closest to the upper left of the kilochromaton and report an error of [#6].%0a%3c %0a%3c !!!!!Conclusion%0a%3c We just put these replicates through the ringer!  We now have an excellent guage on if we have correct data at the kilochromaton level.  The megachromaton level will look at the data from the kilochromaton level and take into account the reported errors at this level.  The higher the "#" error, the less serious it is considered since the higher the # the more hurdles the data overcame before bieng left with only 1 replicate remaining.%0a%3c %0a---%0a> If you are here, then chances are at least 2 of your 3 replicate chromaton are identical.  Congratulations!  For the final check, each and every value is compared between eachother.  A 4x4 matrix is set-up for each chromaton and each of the 16 values are compared between eachother.  If they all/both match, great, select the [[#cv3number|first chromaton in the triad]] as the winner, the replicate closest to the upper left of the chromaton, with no error reported!  Simply report a "0" if all 3 replicates matched, and a "1" if 2 of the replicates matched. If they do not match, then choose the one with the average value closest to 1.5.  To do this add up all the numbers in the matrix.  Next divide by 16 and call that the "answer".  Then take (1.5-answer)^2 and the one with the lowest number wins.  If this is the case, then report a soft error of [#5].  If the averages are the same but the values are different, pick the first chromaton, basically the chromaton closest to the upper left of the kilochromaton and report an error pf [#6].%0a> %0a
host:1611847420=104.175.54.158
author:1611847133=
diff:1611847133:1611846901:=372c372%0a%3c If you are here, then chances are at least 2 of your 3 replicate chromaton are identical.  Congratulations!  For the final check, each and every value is compared between eachother.  A 4x4 matrix is set-up for each chromaton and each of the 16 values are compared between eachother.  If they all/both match, great, select the [[#cv3number|first chromaton in the triad]] as the winner, the replicate closest to the upper left of the chromaton, with no error reported!  Simply report a "0" if all 3 replicates matched, and a "1" if 2 of the replicates matched. If they do not match, then choose the one with the average value closest to 1.5.  To do this add up all the numbers in the matrix.  Next divide by 16 and call that the "answer".  Then take (1.5-answer)^2 and the one with the lowest number wins.  If this is the case, then report a soft error of [#5].  If the averages are the same but the values are different, pick the first chromaton, basically the chromaton closest to the upper left of the kilochromaton and report an error pf [#6].%0a---%0a> If you are here, then chances are at least 2 of your 3 replicate chromaton are identical.  Congratulations!  For the final check, each and every value is compared between eachother.  A 4x4 matrix is set-up for each chromaton and each of the 16 values are compared between eachother.  If they all/both match, great, select the [[#cv3number|first chromaton in the triad]] as the winner, the replicate closest to the upper left of the chromaton, with no error reported!  Aimply report a "0" if all 3 replicates matched, and a "1" if 2 of the replicates matched. If they do not match, then choose the one with the average value closest to 1.5.  To do this add up all the numbers in the matrix.  Next divide by 16 and call that the "answer".  Then take (1.5-answer)^2 and the one with the lowest number wins.  If this is the case, then report a soft error of [#5].%0a
host:1611847133=104.175.54.158
author:1611846901=
diff:1611846901:1611846880:=368c368%0a%3c Next the rows are added and the columns added.  Mod 4 means that the sum is then divided by 4 and the remainder is reported.  Now these remainders are compared between the 2 (or 3) replicate chromaton.  If there are 3 chromaton left and 2 match and one doesn't, then discard the non-matching.  If 2 are remaining and they agree then great, go to next step.  If they do not agree, choose the one with the average checksum closest to 1.5.  To determine this you take all 8 checksums, add them together, divide by 8, and call that "answer".  Then take (1.5-answer)^2 and compare this value to the other chromaton's value.  The smaller number wins.  If they are the same, go to next step.  If there is only one winner at this step, report a soft error of [#4].%0a---%0a> Next the rows are added and the columns added.  Mod 4 means that the sum is then divided by 4 and the remainder is reported.  Now these remainders are compared between the 2 (or 3) replicate chromaton.  If there are 3 chromaton left and 2 match and one doesn't, then discard the non-matching.  If 2 are remaining and they agree then great, go to next step.  If they do not agree, choose the one with the average checksum closest to 1.5.  To determine this you take all 8 checksums, add them together, divide by 8, and call that "answer".  Then take (1.5-answer)^2 and compare this value to the other chromaton's value.  The smaller number wins.  If they are the same, go to next step.  If there is one winner at this step, report a soft error of [#4].%0a
host:1611846901=104.175.54.158
author:1611846880=
diff:1611846880:1611846778:=368c368%0a%3c Next the rows are added and the columns added.  Mod 4 means that the sum is then divided by 4 and the remainder is reported.  Now these remainders are compared between the 2 (or 3) replicate chromaton.  If there are 3 chromaton left and 2 match and one doesn't, then discard the non-matching.  If 2 are remaining and they agree then great, go to next step.  If they do not agree, choose the one with the average checksum closest to 1.5.  To determine this you take all 8 checksums, add them together, divide by 8, and call that "answer".  Then take (1.5-answer)^2 and compare this value to the other chromaton's value.  The smaller number wins.  If they are the same, go to next step.  If there is one winner at this step, report a soft error of [#4].%0a---%0a> Next the rows are added and the columns added.  Mod 4 means that the sum is then divided by 4 and the remainder is reported.  Now these remainders are compared between the 2 (or 3) replicate chromaton.  If there are 3 and 2 match and one doesn't, then discard the non-matching.  If 2 are remaining and they agree great, go to next step.  If they do not agree, choose the one with the average checksum closest to 1.5.  To determine this you take all 8 checksums, add them together, divide by 8, and call that "answer".  Then take (1.5-answer)^2 and compare this value to the other chromaton's value.  The smaller number wins.  If they are the same, go to next step.  If there is one winner at this step, report a soft error of [#4].%0a
host:1611846880=104.175.54.158
author:1611846778=
diff:1611846778:1611846714:=365c365%0a%3c To check for possible locational error we will use a checksum which is a little more computationally intensive since it requires a 2D matrix.%0a---%0a> To check the location we will use a checksum which is a little more computationally intensive since it requires a 2D matrix.%0a
host:1611846778=104.175.54.158
author:1611846714=
diff:1611846714:1611846516:=361c361%0a%3c A parity check is a count of how many times a certain value showed up in our chromaton. Add up the number of each type of triad, our base-4 numbers. So add up the number of each "0"s, the "1"s, the "2"s, and the "3"s. And compare the results across the remaining chromaton.  This would be something like chromaton1 contains 5x "0", 10x "1", 1x "2", 0x "3".  Now if chromaton2 matches chromaton1 parity check but chromaton3 has a different parity check, then we can exclude chromaton3.  If only 2 replicate chromaton of the three remain and have different parity checks, then choose the one with the most even distribution of numbers. We can use a sort of "r^2 method". In our case there are 16 numbers so an even distribution would be 4x of each 0,1,2,3. Our r^2 method would subtract our actual number by 4 and then square the value.  So for our sample set it would be (5-4)^2 + (10-4)^2 + (1-4)^2 + (0-4)^2.  Now choose the one with the lowest value of this test.  After this test the only errors that would be matching is if all the right values were included in both chromaton, but the location of the values were different.  If a winner is chosen here report a soft error of [#3].  If 2 or 3 of the replicate chromaton have the same parity check go to step 4.%0a---%0a> A parity check is a count of how many times a certain value showed up in our chromaton. Add up the number of each type of triad, our base-4 numbers. So add up the number of each "0"s, the "1"s, the "2"s, and the "3"s. And compare the results across the remaining chromaton.  This would be something like chromaton1 contains 5x "0", 10x "1", 1x "2", 0x "3".  Now if chromaton2 matches chromaton1 parity check but chromaton3 has a different parity check, then we can exclude chromaton3.  If only 2 replicate chromaton of the three remain and have different parity checks, then choose the one with the most even distribution of numbers. We can use a sort of "r^2 method". In our case there are 16 numbers so an even distribution would be 4x of each 0,1,2,3. Our r^2 method would subtract our actual number by 4 and then square the value.  So for our sample set it would be (5-4)^2 + (10-4)^2 + (1-4)^2 + (0-4)^2.  Now choose the one with the lowest value of this test.  After this test the only errors that would be matching is if all the right values were included in both chromaton, but the location of the values were different.  If a winner is chosen here report a soft error of [#3].%0a
host:1611846714=104.175.54.158
author:1611846516=
diff:1611846516:1611846287:=361c361%0a%3c A parity check is a count of how many times a certain value showed up in our chromaton. Add up the number of each type of triad, our base-4 numbers. So add up the number of each "0"s, the "1"s, the "2"s, and the "3"s. And compare the results across the remaining chromaton.  This would be something like chromaton1 contains 5x "0", 10x "1", 1x "2", 0x "3".  Now if chromaton2 matches chromaton1 parity check but chromaton3 has a different parity check, then we can exclude chromaton3.  If only 2 replicate chromaton of the three remain and have different parity checks, then choose the one with the most even distribution of numbers. We can use a sort of "r^2 method". In our case there are 16 numbers so an even distribution would be 4x of each 0,1,2,3. Our r^2 method would subtract our actual number by 4 and then square the value.  So for our sample set it would be (5-4)^2 + (10-4)^2 + (1-4)^2 + (0-4)^2.  Now choose the one with the lowest value of this test.  After this test the only errors that would be matching is if all the right values were included in both chromaton, but the location of the values were different.  If a winner is chosen here report a soft error of [#3].%0a---%0a> A parity check is a count of how many times a certain value showed up in our chromaton. Add up the number of each type of triad, our base-4 numbers. So add up the number of each "0"s, the "1"s, the "2"s, and the "3"s. And compare the results across the remaining chromaton.  This would be something like chromaton1 contains 5x "0", 10x "1", 1x "2", 0x "3".  Now if chromaton2 matches chromaton1 parity check but chromaton3 has a different parity check, then we can exclude chromaton3.  If there were only 2 remaining before the parity check calculation and both have different parity checks, then choose the one with the most even distribution of numbers. We can use a sort of "r^2 method". In our case there are 16 numbers so an even distribution would be 4x of each 0,1,2,3. Our r^2 method would subtract our actual number by 4 and then square the value.  So for our sample set it would be (5-4)^2 + (10-4)^2 + (1-4)^2 + (0-4)^2.  Now choose the one with the lowest value of this test.  After this test the only errors that would be matching is if all the right values were included in both chromaton, but the location of the values were different.  If a winner is chosen here report a soft error of [#3].%0a
host:1611846516=104.175.54.158
author:1611846287=
diff:1611846287:1611846239:=359c359%0a%3c If they all have the same amount of errors or 2 have the same amount, then we need something more than a sum, we can use a "parity check".  %0a---%0a> If they all have the same amount of errors or 2 have the same amount, then we need something more than a sum, a "parity check".  %0a
host:1611846287=104.175.54.158
author:1611846239=
diff:1611846239:1611846083:=357c357%0a%3c In the case all 3 have the same sum or two do, pick the one with the least amount of errors (and/or least 3-bit errors since these are more serious than 2-bit) reported in the [[#v3error|original error correction steps]] to use as the "one correct version" ("winner").  If a winner is chosen here, then report a soft error of [#2].  If a tie between any of the replicates are found, go to step 3.%0a---%0a> In the case all 3 have the same sum or two do, pick the one with the least amount of errors reported in the [[#v3error|original error correction steps]] to use as the "one correct version" ("winner").  If a winner is chosen here, then report a soft error of [#2].  If a tie between any of the replicates are found, go to step 3.%0a
host:1611846239=104.175.54.158
author:1611846083=
diff:1611846083:1611846024:=353c353%0a%3c If 2 or more agree on the sum without performing the "all different" protocol above, then this is great; if the sums equal then the overwhelming chance is the chromaton are in fact the same. However we still have to decide which one to correct it to!  We can't just keep all the chromaton since they are replicates at this level.  One idea would be to choose one randomly.  The reason we won't do this is 2-fold.  Firstly it would take a lot of processing power to run a pseudorandom algorithm every time we needed to make a decision.  Another reason is random algorithms can be cracked and a malicious attacker could know ahead of time which one you will pick and insert a malicious chromaton in the position that he knows will beat the detection.  So we need to use actual intelligent decisions so we are all on the same page.  The following techniques will go from fast and easy to slower and more complicated.  We hope the fast and simple methods can converge us on an answer, and if not then we go to the more expensive techniques. See history of error correction for more info on the following checks [[https://www.techradar.com/news/computing/how-error-detection-and-correction-works-1080736|#]].%0a---%0a> If 2 or more agree on the sum then this is great, if the sums equal then the overwhelming chance is the chromaton are in fact the same. However we still have to decide which one to correct it to!  We can't just keep all the chromaton since they are replicates at this level.  One idea would be to choose one randomly.  The reason we won't do this is 2-fold.  Firstly it would take a lot of processing power to run a pseudorandom algorithm every time we needed to make a decision.  Another reason is random algorithms can be cracked and a malicious attacker could know ahead of time which one you will pick and insert a malicious chromaton in the position that he knows will beat the detection.  So we need to use actual intelligent decisions so we are all on the same page.  The following techniques will go from fast and easy to slower and more complicated.  We hope the fast and simple methods can converge us on an answer, and if not then we go to the more expensive techniques. See history of error correction for more info on the following checks [[https://www.techradar.com/news/computing/how-error-detection-and-correction-works-1080736|#]].%0a
host:1611846083=104.175.54.158
author:1611846024=
diff:1611846024:1611845741:=350c350%0a%3c If all 3 of the sums are different, what do we do?  Firstly I want to say that all 3 being different will be extremely rare since we already have perfect 1-bit error correction and roughly 98%25 2-bit error detection at the base level. But when it does rarely happen we can do something else so we don't loose all the data in the base chromaton just because of a couple errors.  What we will do is take the 2 chromaton with the fewest detected errors (or the least serious errors, 3-bit error more serious than 2-bit. if there is a 3-way tie, favor chromaton with fewest errors and most similar sums, if still a 3-way tie favor chromaton with the fewest errors and most different sums, if still a 3-way tie forget about errors and choose the two with the most different sums) and then compare those two at the base chromaton triad level.  Anything that is different between the 2, we check to see if there were any errors detected previously in those spots.  If in one of the chromaton one triad was detected as an error and the other chromaton does not have an error detected in that triad, then the error triad is replaced with the non-error triad.  After all of this what we will be left with is 2 chromaton that are either now identical or only vary in one of two ways.  The first way they can vary is if both have different errors in the same triad.  The second way is they both have different values in the same triad and neither was detected as an error.  In both of these cases the data from the third chromaton is used to fix these.  Even if the third chromaton is wrong or has a detected error in the spot in question, we need a tie breaker, so the data in the third chromaton is used to settle any remaining disputes between the two chromaton being compared.  Now the 2 chromaton that were being compared are identical and are considered the correct version.  Choose the [[#v3number|first chromaton]], basically the one closest to the upper left of the kilochromaton. If you choose a winner here, report a soft error of [#1].%0a---%0a> If all 3 of the sums are different, what do we do?  Firstly I want to say that all 3 being different will be extremely rare since we already have perfect 1-bit error correction and roughly 98%25 2-bit error detection at the base level. But when it does rarely happen we can do something else so we don't loose all the data in the base chromaton just because of a couple errors.  What we will do is take the 2 chromaton with the fewest detected errors (or the least serious errors, 3-bit error more serious than 2-bit. if there is a 3-way tie, favor chromaton with fewest errors and most similar sums, if still a 3-way tie favor chromaton with the fewest errors and most different sums, if still a 3-way tie forget about errors and choose the two with the most different sums) and then compare those two at the base chromaton triad level.  Anything that is different between the 2, we check to see if there were any errors detected previously in those spots.  If in one of the chromaton one triad was detected as an error and the other chromaton does not have an error detected in that triad, then the error triad is replaced with the non-error triad.  After all of this what we will be left with is 2 chromaton that are either now identical or only vary in one of two ways.  The first way they can vary is if both have different errors in the same triad.  The second way is they both have different values in the same triad and neither was detected as an error.  In both of these cases the data from the third chromaton is used to fix these.  Even if the third chromaton is wrong or has a detected error in the spot in question, we need a tie breaker, so the data in the third chromaton is used to settle any remaining disputes between the two chromaton being compared.  Now the 2 chromaton that were being compared are identical and are considered the correct version.  If you choose a winner here, report a soft error of [#1].%0a
host:1611846024=104.175.54.158
author:1611845741=
diff:1611845741:1611845626:=350c350%0a%3c If all 3 of the sums are different, what do we do?  Firstly I want to say that all 3 being different will be extremely rare since we already have perfect 1-bit error correction and roughly 98%25 2-bit error detection at the base level. But when it does rarely happen we can do something else so we don't loose all the data in the base chromaton just because of a couple errors.  What we will do is take the 2 chromaton with the fewest detected errors (or the least serious errors, 3-bit error more serious than 2-bit. if there is a 3-way tie, favor chromaton with fewest errors and most similar sums, if still a 3-way tie favor chromaton with the fewest errors and most different sums, if still a 3-way tie forget about errors and choose the two with the most different sums) and then compare those two at the base chromaton triad level.  Anything that is different between the 2, we check to see if there were any errors detected previously in those spots.  If in one of the chromaton one triad was detected as an error and the other chromaton does not have an error detected in that triad, then the error triad is replaced with the non-error triad.  After all of this what we will be left with is 2 chromaton that are either now identical or only vary in one of two ways.  The first way they can vary is if both have different errors in the same triad.  The second way is they both have different values in the same triad and neither was detected as an error.  In both of these cases the data from the third chromaton is used to fix these.  Even if the third chromaton is wrong or has a detected error in the spot in question, we need a tie breaker, so the data in the third chromaton is used to settle any remaining disputes between the two chromaton being compared.  Now the 2 chromaton that were being compared are identical and are considered the correct version.  If you choose a winner here, report a soft error of [#1].%0a---%0a> If all 3 of the sums are different, what do we do?  Firstly I want to say that all 3 being different will be extremely rare since we already have perfect 1-bit error correction and roughly 98%25 2-bit error detection at the base level. But when it does rarely happen we can do something else so we don't loose all the data in the base chromaton just because of a couple errors.  What we will do is take the 2 chromaton with the fewest detected errors (or the least serious errors, 3-bit error more serious than 2-bit. if there is a tie, favor chromaton with fewest errors and most similar sums, if still a tie favor chromaton with the fewest errors and most different sums, if still a tie forget about errors and choose the two with the most different sums) and then compare those two at the base chromaton level.  Anything that is different between the 2, we check to see if there were any errors detected previously in those spots.  If in one of the chromaton one triad was detected as an error and the other chromaton does not have an error detected in that triad, then the error triad is replaced with the non-error triad.  After all of this what we will be left with is 2 chromaton that are either now identical or only vary in one of two ways.  The first way they can vary is if both have different errors in the same triad.  The second way is they both have different values in the same triad and neither was detected as an error.  In both of these cases the data from the third chromaton is used to fix these.  Even if the third chromaton is wrong or has a detected error in the spot in question, we need a tie breaker, so the data in the third chromaton is used to settle any remaining disputes between the two chromaton being compared.  Now the 2 chromaton that were being compared are identical and are considered the correct version.  If you choose a winner here, report a soft error of [#1].%0a
host:1611845741=104.175.54.158
author:1611845626=
diff:1611845626:1611845468:=350c350%0a%3c If all 3 of the sums are different, what do we do?  Firstly I want to say that all 3 being different will be extremely rare since we already have perfect 1-bit error correction and roughly 98%25 2-bit error detection at the base level. But when it does rarely happen we can do something else so we don't loose all the data in the base chromaton just because of a couple errors.  What we will do is take the 2 chromaton with the fewest detected errors (or the least serious errors, 3-bit error more serious than 2-bit. if there is a tie, favor chromaton with fewest errors and most similar sums, if still a tie favor chromaton with the fewest errors and most different sums, if still a tie forget about errors and choose the two with the most different sums) and then compare those two at the base chromaton level.  Anything that is different between the 2, we check to see if there were any errors detected previously in those spots.  If in one of the chromaton one triad was detected as an error and the other chromaton does not have an error detected in that triad, then the error triad is replaced with the non-error triad.  After all of this what we will be left with is 2 chromaton that are either now identical or only vary in one of two ways.  The first way they can vary is if both have different errors in the same triad.  The second way is they both have different values in the same triad and neither was detected as an error.  In both of these cases the data from the third chromaton is used to fix these.  Even if the third chromaton is wrong or has a detected error in the spot in question, we need a tie breaker, so the data in the third chromaton is used to settle any remaining disputes between the two chromaton being compared.  Now the 2 chromaton that were being compared are identical and are considered the correct version.  If you choose a winner here, report a soft error of [#1].%0a---%0a> If all 3 of the sums are different, what do we do?  Firstly I want to say that all 3 being different will be extremely rare since we already have perfect 1-bit error correction and roughly 98%25 2-bit error detection at the base level. But when it does rarely happen we can do something else so we don't loose all the data in the base chromaton just because of a couple errors.  What we will do is take the 2 chromaton with the fewest detected errors (if there is a tie, favor chromaton with fewest errors and most similar sums, if still a tie favor chromaton with the fewest errors and most different sums, if still a tie forget about errors and choose the two with the most different sums) and then compare those two at the base chromaton level.  Anything that is different between the 2, we check to see if there were any errors detected previously in those spots.  If in one of the chromaton one triad was detected as an error and the other chromaton does not have an error detected in that triad, then the error triad is replaced with the non-error triad.  After all of this what we will be left with is 2 chromaton that are either now identical or only vary in one of two ways.  The first way they can vary is if both have different errors in the same triad.  The second way is they both have different values in the same triad and neither was detected as an error.  In both of these cases the data from the third chromaton is used to fix these.  Even if the third chromaton is wrong or has a detected error in the spot in question, we need a tie breaker, so the data in the third chromaton is used to settle any remaining disputes between the two chromaton being compared.  Now the 2 chromaton that were being compared are identical and are considered the correct version.  If you choose a winner here, report a soft error of [#1].%0a
host:1611845626=104.175.54.158
author:1611845468=
diff:1611845468:1611844855:=275c275%0a%3c A private key is 256 bits.  In the [[digital collectible network]], private keys might be valued around $0.50 in 2021 dollars.%0a---%0a> A private key is 256 bits.  In the [[digital collectible network]], private keys might be valued around $0.50%0a
host:1611845468=104.175.54.158
author:1611844855=
diff:1611844855:1611844617:=281c281%0a%3c Gigachromaton: 2,762 private keys, $1381.00.  Somewhat practical, this will probably be within the range of consumer displays and cameras in 10-20 years as it requires around 450 megapixel or 30k resolution.  This is well within the range of CD-like resolution so gigachromaton disks could be practical today.%0a---%0a> Gigachromaton: 2,762 private keys, $1381.00.  Somewhat practical, this is in the range of bieng photographed by a good digital camera around 20 megapixel.%0a
host:1611844855=104.175.54.158
author:1611844617=
diff:1611844617:1611844387:=269c269%0a%3c Assuming an 11cm chromaton disk chromaton would have 1cm wide hexagons.  Kilochromaton would have 0.0909cm. Megachromaton is 0.008cm, or 80 microns which is larger than a pixel of a 4k screen of the size of the megachromaton  since 4k is 8 megapixel, it should fit on any wqhd screen.  Gigachromaton is 0.00075cm which is 7.5 micron, which would require a 30k screen or roughly 450 megapixels.  Terachromaton is 680nm (size of a DVD pit [[https://electronics.howstuffworks.com/dvd2.htm|#]]). Petachromaton is 62nm.  Exachromaton is 5.6nm.  So a CD size chromaton could potentially hold up to a couple gigabytes of data.  Not bad.  Especially when you consider data stored as chromaton is perfect data.%0a---%0a> Assuming an 11cm chromaton disk chromaton would have 1cm wide hexagons.  Kilochromaton would have 0.0909cm. Megachromaton is 0.008cm, or 80 microns which is larger than a pixel of a 4k screen of the size of the megachromaton  since 4k is 8 megapixel, it should fit on any wqhd screen.  Gigachromaton is 0.00075cm which is 7.5 micron, which would require a 30k screen or roughly or 450 megapixels.  Terachromaton is 680nm (size of a DVD pit [[https://electronics.howstuffworks.com/dvd2.htm|#]]). Petachromaton is 62nm.  Exachromaton is 5.6nm.  So a CD size chromaton could potentially hold up to a couple gigabytes of data.  Not bad.  Especially when you consider data stored as chromaton is perfect data.%0a
host:1611844617=104.175.54.158
author:1611844387=
diff:1611844387:1611843801:=269c269%0a%3c Assuming an 11cm chromaton disk chromaton would have 1cm wide hexagons.  Kilochromaton would have 0.0909cm. Megachromaton is 0.008cm, or 80 microns which is larger than a pixel of a 4k screen of the size of the megachromaton  since 4k is 8 megapixel, it should fit on any wqhd screen.  Gigachromaton is 0.00075cm which is 7.5 micron, which would require a 30k screen or roughly or 450 megapixels.  Terachromaton is 680nm (size of a DVD pit [[https://electronics.howstuffworks.com/dvd2.htm|#]]). Petachromaton is 62nm.  Exachromaton is 5.6nm.  So a CD size chromaton could potentially hold up to a couple gigabytes of data.  Not bad.  Especially when you consider data stored as chromaton is perfect data.%0a---%0a> Assuming an 11cm chromaton disk chromaton would have 1cm wide hexagons.  Kilochromaton would have 0.0909cm. Megachromaton is 0.008cm, or 80 microns which is larger than a pixel of a 4k screen of the size of the megachromaton  since 4k is 8 megapixel, it should fit on any wqhd screen.  Gigachromaton is 0.00075cm which is 7.5 micron, which is 15.4 megapixel.  Terachromaton is 680nm (size of a DVD pit [[https://electronics.howstuffworks.com/dvd2.htm|#]]). Petachromaton is 62nm.  Exachromaton is 5.6nm.  So a CD size chromaton could potentially hold up to a couple gigabytes of data.  Not bad.  Especially when you consider data stored as chromaton is perfect data.%0a
host:1611844387=104.175.54.158
author:1611843801=
diff:1611843801:1611843562:=269c269%0a%3c Assuming an 11cm chromaton disk chromaton would have 1cm wide hexagons.  Kilochromaton would have 0.0909cm. Megachromaton is 0.008cm, or 80 microns which is larger than a pixel of a 4k screen of the size of the megachromaton  since 4k is 8 megapixel, it should fit on any wqhd screen.  Gigachromaton is 0.00075cm which is 7.5 micron, which is 15.4 megapixel.  Terachromaton is 680nm (size of a DVD pit [[https://electronics.howstuffworks.com/dvd2.htm|#]]). Petachromaton is 62nm.  Exachromaton is 5.6nm.  So a CD size chromaton could potentially hold up to a couple gigabytes of data.  Not bad.  Especially when you consider data stored as chromaton is perfect data.%0a---%0a> Assuming an 11cm chromaton disk chromaton would have 1cm wide hexagons.  Kilochromaton would have 0.0909cm. Megachromaton is 0.008cm, or 80 microns which is larger than a pixel of a 4k screen of the size of the megachromaton  since 4k is 8 megapixel.  Gigachromaton is 0.00075cm which is 7.5 micron, which is 15.4 megapixel.  Terachromaton is 680nm (size of a DVD pit [[https://electronics.howstuffworks.com/dvd2.htm|#]]). Petachromaton is 62nm.  Exachromaton is 5.6nm.  So a CD size chromaton could potentially hold up to a couple gigabytes of data.  Not bad.  Especially when you consider data stored as chromaton is perfect data.%0a
host:1611843801=104.175.54.158
author:1611843562=
diff:1611843562:1611842867:=269c269%0a%3c Assuming an 11cm chromaton disk chromaton would have 1cm wide hexagons.  Kilochromaton would have 0.0909cm. Megachromaton is 0.008cm, or 80 microns which is larger than a pixel of a 4k screen of the size of the megachromaton  since 4k is 8 megapixel.  Gigachromaton is 0.00075cm which is 7.5 micron, which is 15.4 megapixel.  Terachromaton is 680nm (size of a DVD pit [[https://electronics.howstuffworks.com/dvd2.htm|#]]). Petachromaton is 62nm.  Exachromaton is 5.6nm.  So a CD size chromaton could potentially hold up to a couple gigabytes of data.  Not bad.  Especially when you consider data stored as chromaton is perfect data.%0a---%0a> Assuming an 11cm chromaton disk chromaton would have 1cm wide hexagons.  Kilochromaton would have 0.0909cm. Megachromaton is 0.008cm, or 80 microns which is larger than a pixel of a small 4k screen.  Gigachromaton is 0.00075cm which is 7.5 micron, which is 15.4 megapixel.  Terachromaton is 680nm (size of a DVD pit [[https://electronics.howstuffworks.com/dvd2.htm|#]]). Petachromaton is 62nm.  Exachromaton is 5.6nm.  So a CD size chromaton could potentially hold up to a couple gigabytes of data.  Not bad.  Especially when you consider data stored as chromaton is perfect data.%0a
host:1611843562=104.175.54.158
author:1611842867=
diff:1611842867:1611842735:=281,284c281,283%0a%3c Gigachromaton: 2,762 private keys, $1381.00.  Somewhat practical, this is in the range of bieng photographed by a good digital camera around 20 megapixel.%0a%3c %0a%3c Terachromaton: 80,121 private keys, $40,060.50.  Possibly practical, this is in the realm of chromaton on specialized disks with color centers about the size of a DVD pit.%0a%3c %0a---%0a> Gigachromaton: 2,762 private keys, $1381.00%0a> %0a> Terachromaton: 80,121 private keys, $40,060.50%0a
host:1611842867=104.175.54.158
author:1611842735=
diff:1611842735:1611842642:=269c269%0a%3c Assuming an 11cm chromaton disk chromaton would have 1cm wide hexagons.  Kilochromaton would have 0.0909cm. Megachromaton is 0.008cm, or 80 microns which is larger than a pixel of a small 4k screen.  Gigachromaton is 0.00075cm which is 7.5 micron, which is 15.4 megapixel.  Terachromaton is 680nm (size of a DVD pit [[https://electronics.howstuffworks.com/dvd2.htm|#]]). Petachromaton is 62nm.  Exachromaton is 5.6nm.  So a CD size chromaton could potentially hold up to a couple gigabytes of data.  Not bad.  Especially when you consider data stored as chromaton is perfect data.%0a---%0a> Assuming an 11cm chromaton disk chromaton would have 1cm wide hexagons.  Kilochromaton would have 0.0909cm. Megachromaton is 0.008cm, or 80 microns which is larger than a pixel of a small 4k screen.  Gigachromaton is 0.00075cm which is 7.5 micron.  Terachromaton is 680nm (size of a DVD pit [[https://electronics.howstuffworks.com/dvd2.htm|#]]). Petachromaton is 62nm.  Exachromaton is 5.6nm.  So a CD size chromaton could potentially hold up to a couple gigabytes of data.  Not bad.  Especially when you consider data stored as chromaton is perfect data.%0a
host:1611842735=104.175.54.158
author:1611842642=
diff:1611842642:1611842573:=277,279c277,279%0a%3c Kilochromaton: 3 private keys, $1.50. Very practical.%0a%3c %0a%3c Megachromaton: 95 private keys, $47.50. Quite practical with 4k screen display of the chromaton.%0a---%0a> Kilochromaton: 3 private keys, $1.50.%0a> %0a> Megachromaton: 95 private keys, $47.50%0a
host:1611842642=104.175.54.158
author:1611842573=
diff:1611842573:1611842143:=269c269%0a%3c Assuming an 11cm chromaton disk chromaton would have 1cm wide hexagons.  Kilochromaton would have 0.0909cm. Megachromaton is 0.008cm, or 80 microns which is larger than a pixel of a small 4k screen.  Gigachromaton is 0.00075cm which is 7.5 micron.  Terachromaton is 680nm (size of a DVD pit [[https://electronics.howstuffworks.com/dvd2.htm|#]]). Petachromaton is 62nm.  Exachromaton is 5.6nm.  So a CD size chromaton could potentially hold up to a couple gigabytes of data.  Not bad.  Especially when you consider data stored as chromaton is perfect data.%0a---%0a> Assuming an 11cm chromaton disk chromaton would have 1cm wide hexagons.  Kilochromaton would have 0.0909cm. Megachromaton is 0.008cm.  Gigachromaton is 0.00075cm which is 7.5 micron.  Terachromaton is 680nm (size of a DVD pit [[https://electronics.howstuffworks.com/dvd2.htm|#]]). Petachromaton is 62nm.  Exachromaton is 5.6nm.  So a CD size chromaton could potentially hold up to a couple gigabytes of data.  Not bad.  Especially when you consider data stored as chromaton is perfect data.%0a
host:1611842573=104.175.54.158
author:1611842143=
diff:1611842143:1611817530:=349c349%0a%3c If all 3 of the sums are different, what do we do?  Firstly I want to say that all 3 being different will be extremely rare since we already have perfect 1-bit error correction and roughly 98%25 2-bit error detection at the base level. But when it does rarely happen we can do something else so we don't loose all the data in the base chromaton just because of a couple errors.  What we will do is take the 2 chromaton with the fewest detected errors (if there is a tie, favor chromaton with fewest errors and most similar sums, if still a tie favor chromaton with the fewest errors and most different sums, if still a tie forget about errors and choose the two with the most different sums) and then compare those two at the base chromaton level.  Anything that is different between the 2, we check to see if there were any errors detected previously in those spots.  If in one of the chromaton one triad was detected as an error and the other chromaton does not have an error detected in that triad, then the error triad is replaced with the non-error triad.  After all of this what we will be left with is 2 chromaton that are either now identical or only vary in one of two ways.  The first way they can vary is if both have different errors in the same triad.  The second way is they both have different values in the same triad and neither was detected as an error.  In both of these cases the data from the third chromaton is used to fix these.  Even if the third chromaton is wrong or has a detected error in the spot in question, we need a tie breaker, so the data in the third chromaton is used to settle any remaining disputes between the two chromaton being compared.  Now the 2 chromaton that were being compared are identical and are considered the correct version.  If you choose a winner here, report a soft error of [#1].%0a---%0a> If all 3 of the checksums are different, what do we do?  Firstly I want to say that all 3 being different will be extremely rare since we already have perfect 1-bit error correction and roughly 98%25 2-bit error detection at the base level. But when it does rarely happen we can do something else so we don't loose all the data in the base chromaton just because of a couple errors.  What we will do is take the 2 chromaton with the fewest detected errors (if there is a tie, favor chromaton with fewest errors and most similar checksums, if still a tie favor chromaton with the fewest errors and most different checksums, if still a tie forget about errors and choose the two with the most different checksums) and then compare those two at the base chromaton level.  Anything that is different between the 2, we check to see if there were any errors detected previously in those spots.  If in one of the chromaton one triad was detected as an error and the other chromaton does not have an error detected in that triad, then the error triad is replaced with the non-error triad.  After all of this what we will be left with is 2 chromaton that are either now identical or only vary in one of two ways.  The first way they can vary is if both have different errors in the same triad.  The second way is they both have different values in the same triad and neither was detected as an error.  In both of these cases the data from the third chromaton is used to fix these.  Even if the third chromaton is wrong or has a detected error in the spot in question, we need a tie breaker, so the data in the third chromaton is used to settle any remaining disputes between the two chromaton being compared.  Now the 2 chromaton that were being compared are identical and are considered the correct version.  If you choose a winner here, report a soft error of [#1].%0a
host:1611842143=104.175.54.158
author:1611817530=
diff:1611817530:1611817165:=371c371%0a%3c If you are here, then chances are at least 2 of your 3 replicate chromaton are identical.  Congratulations!  For the final check, each and every value is compared between eachother.  A 4x4 matrix is set-up for each chromaton and each of the 16 values are compared between eachother.  If they all/both match, great, select the [[#cv3number|first chromaton in the triad]] as the winner, the replicate closest to the upper left of the chromaton, with no error reported!  Aimply report a "0" if all 3 replicates matched, and a "1" if 2 of the replicates matched. If they do not match, then choose the one with the average value closest to 1.5.  To do this add up all the numbers in the matrix.  Next divide by 16 and call that the "answer".  Then take (1.5-answer)^2 and the one with the lowest number wins.  If this is the case, then report a soft error of [#5].%0a---%0a> If you are here, then chances are at least 2 of your 3 replicate chromaton are identical.  Congratulations!  For the final check, each and every value is compared between eachother.  A 4x4 matrix is set-up for each chromaton and each of the 16 values are compared between eachother.  If they all/both match, great, select the [[#cv3number|first chromaton in the triad]] as the winner, the replicate closest to the upper left of the chromaton, with no error reported!  If they do not match, then choose the one with the average value closest to 1.5.  To do this add up all the numbers in the matrix.  Next divide by 16 and call that the "answer".  Then take (1.5-answer)^2 and the one with the lowest number wins.  If this is the case, then report a soft error of [#5].%0a
host:1611817530=104.175.54.158
author:1611817165=
diff:1611817165:1611817080:=349c349%0a%3c If all 3 of the checksums are different, what do we do?  Firstly I want to say that all 3 being different will be extremely rare since we already have perfect 1-bit error correction and roughly 98%25 2-bit error detection at the base level. But when it does rarely happen we can do something else so we don't loose all the data in the base chromaton just because of a couple errors.  What we will do is take the 2 chromaton with the fewest detected errors (if there is a tie, favor chromaton with fewest errors and most similar checksums, if still a tie favor chromaton with the fewest errors and most different checksums, if still a tie forget about errors and choose the two with the most different checksums) and then compare those two at the base chromaton level.  Anything that is different between the 2, we check to see if there were any errors detected previously in those spots.  If in one of the chromaton one triad was detected as an error and the other chromaton does not have an error detected in that triad, then the error triad is replaced with the non-error triad.  After all of this what we will be left with is 2 chromaton that are either now identical or only vary in one of two ways.  The first way they can vary is if both have different errors in the same triad.  The second way is they both have different values in the same triad and neither was detected as an error.  In both of these cases the data from the third chromaton is used to fix these.  Even if the third chromaton is wrong or has a detected error in the spot in question, we need a tie breaker, so the data in the third chromaton is used to settle any remaining disputes between the two chromaton being compared.  Now the 2 chromaton that were being compared are identical and are considered the correct version.  If you choose a winner here, report a soft error of [#1].%0a---%0a> If all 3 of the checksums are different, what do we do?  Firstly I want to say that all 3 being different will be extremely rare since we already have perfect 1-bit error correction and roughly 95%25 2-bit error detection at the base level. But when it does rarely happen we can do something else so we don't loose all the data in the base chromaton just because of a couple errors.  What we will do is take the 2 chromaton with the fewest detected errors (if there is a tie, favor chromaton with fewest errors and most similar checksums, if still a tie favor chromaton with the fewest errors and most different checksums, if still a tie forget about errors and choose the two with the most different checksums) and then compare those two at the base chromaton level.  Anything that is different between the 2, we check to see if there were any errors detected previously in those spots.  If in one of the chromaton one triad was detected as an error and the other chromaton does not have an error detected in that triad, then the error triad is replaced with the non-error triad.  After all of this what we will be left with is 2 chromaton that are either now identical or only vary in one of two ways.  The first way they can vary is if both have different errors in the same triad.  The second way is they both have different values in the same triad and neither was detected as an error.  In both of these cases the data from the third chromaton is used to fix these.  Even if the third chromaton is wrong or has a detected error in the spot in question, we need a tie breaker, so the data in the third chromaton is used to settle any remaining disputes between the two chromaton being compared.  Now the 2 chromaton that were being compared are identical and are considered the correct version.  If you choose a winner here, report a soft error of [#1].%0a
host:1611817165=104.175.54.158
author:1611817080=
diff:1611817080:1611816283:=347,348c347,348%0a%3c !!!!!!All different%0a%3c %0a---%0a> Or if 2 or more agree on the sum then this is great, and if the sums equal then the overwhelming chance is the chromaton are in fact the same. However we still have to decide which one to correct it to!  We can't just keep all the chromaton since they are replicates at this level.  One idea would be to choose one randomly.  The reason we won't do this is 2-fold.  Firstly it would take a lot of processing power to run a pseudorandom algorithm every time we needed to make a decision.  Another reason is random algorithms can be cracked and a malicious attacker could know ahead of time which one you will pick and insert a malicious chromaton in the position that he knows will beat the detection.  So we need to use actual intelligent decisions so we are all on the same page.  The following techniques will go from fast and easy to slower and more complicated.  We hope the fast and simple methods can converge us on an answer, and if not then we go to the more expensive techniques. See history of error correction for more info on the following checks [[https://www.techradar.com/news/computing/how-error-detection-and-correction-works-1080736|#]].%0a> %0a350,354d349%0a%3c %0a%3c !!!!!!Two or three same%0a%3c If 2 or more agree on the sum then this is great, if the sums equal then the overwhelming chance is the chromaton are in fact the same. However we still have to decide which one to correct it to!  We can't just keep all the chromaton since they are replicates at this level.  One idea would be to choose one randomly.  The reason we won't do this is 2-fold.  Firstly it would take a lot of processing power to run a pseudorandom algorithm every time we needed to make a decision.  Another reason is random algorithms can be cracked and a malicious attacker could know ahead of time which one you will pick and insert a malicious chromaton in the position that he knows will beat the detection.  So we need to use actual intelligent decisions so we are all on the same page.  The following techniques will go from fast and easy to slower and more complicated.  We hope the fast and simple methods can converge us on an answer, and if not then we go to the more expensive techniques. See history of error correction for more info on the following checks [[https://www.techradar.com/news/computing/how-error-detection-and-correction-works-1080736|#]].%0a%3c %0a%3c %0a
host:1611817080=104.175.54.158
author:1611816283=
diff:1611816283:1611816189:=345c345%0a%3c Kilochromaton (and higher) gives us another check of the lower chromaton we are reading.  At this level we use "sum" of the lower level.  So first we decode and [[#v3error|error correct all base level]] chromaton.  Then we sum up all the numbers contained in each chromaton and this is the sum, one for each chromaton.  In kilochromaton level we compare the three sums for each replicate chromaton.  If all 3 are the same then we verified that everything is perfect (we have 16 base-4 numbers so the chance that we randomly got the sums to equal yet actually be wrong is 1/64 × 1/64 × 1/64 = 3.8×10^(-6) or 4 times in 1 million).  But for 2 of them to randomly give the same sum wrongly is 1/64 * (1-(63/64)*(63/64)) = 0.049%25 or 484 times in a million.  So since we will accept if 2 of them add to the same sum, we will have a 99.95%25 correct - error correction rate.  This not only corrects 1-bit errors at this level, this corrects up to 48-bit errors!  An entire base chromaton could be wrong and it could be fixed at this level. %0a---%0a> Kilochromaton (and higher) gives us another check of the lower chromaton we are reading.  At this level we use "sum" of the lower level.  So first we decode and error correct all base level chromaton.  Then we sum up all the numbers contained in each chromaton and this is the sum, one for each chromaton.  In kilochromaton level we compare the three sums for each replicate chromaton.  If all 3 are the same then we verified that everything is perfect (we have 16 base-4 numbers so the chance that we randomly got the sums to equal yet actually be wrong is 1/64 × 1/64 × 1/64 = 3.8×10^(-6) or 4 times in 1 million).  But for 2 of them to randomly give the same sum wrongly is 1/64 * (1-(63/64)*(63/64)) = 0.049%25 or 484 times in a million.  So since we will accept if 2 of them add to the same sum, we will have a 99.95%25 correct - error correction rate.  This not only corrects 1-bit errors at this level, this corrects up to 48-bit errors!  An entire base chromaton could be wrong and it could be fixed at this level. %0a
host:1611816283=104.175.54.158
author:1611816189=
diff:1611816189:1611815605:=346a347,348%0a> If all three are different, we choose the one with the sum closest to 24.  Take (24-sum)^2 and the one closest to zero wins.  If you choose a winner here, report a soft error of [#1].%0a> %0a349c351%0a%3c If all 3 of the checksums are different, what do we do?  Firstly I want to say that all 3 being different will be extremely rare since we already have perfect 1-bit error correction and roughly 95%25 2-bit error detection at the base level. But when it does rarely happen we can do something else so we don't loose all the data in the base chromaton just because of a couple errors.  What we will do is take the 2 chromaton with the fewest detected errors (if there is a tie, favor chromaton with fewest errors and most similar checksums, if still a tie favor chromaton with the fewest errors and most different checksums, if still a tie forget about errors and choose the two with the most different checksums) and then compare those two at the base chromaton level.  Anything that is different between the 2, we check to see if there were any errors detected previously in those spots.  If in one of the chromaton one triad was detected as an error and the other chromaton does not have an error detected in that triad, then the error triad is replaced with the non-error triad.  After all of this what we will be left with is 2 chromaton that are either now identical or only vary in one of two ways.  The first way they can vary is if both have different errors in the same triad.  The second way is they both have different values in the same triad and neither was detected as an error.  In both of these cases the data from the third chromaton is used to fix these.  Even if the third chromaton is wrong or has a detected error in the spot in question, we need a tie breaker, so the data in the third chromaton is used to settle any remaining disputes between the two chromaton being compared.  Now the 2 chromaton that were being compared are identical and are considered the correct version.  If you choose a winner here, report a soft error of [#1].%0a---%0a> If all 3 of the checksums are different, what do we do?  Firstly I want to say that all 3 being different will be extremely rare since we already have perfect 1-bit error correction and roughly 95%25 2-bit error detection at the base level. But when it does rarely happen we can do something else so we don't loose all the data in the base chromaton just because of a couple errors.  What we will do is take the 2 chromaton with the fewest detected errors (if there is a tie, favor chromaton with fewest errors and most similar checksums, if still a tie favor chromaton with the fewest errors and most different checksums, if still a tie forget about errors and choose the two with the most different checksums) and then compare those two at the base chromaton level.  Anything that is different between the 2, we check to see if there were any errors detected previously in those spots.  If in one of the chromaton one triad was detected as an error and the other chromaton does not have an error detected in that triad, then the error triad is replaced with the non-error triad.  After all of this what we will be left with is 2 chromaton that are either now identical or only vary in one of two ways.  The first way they can vary is if both have different errors in the same triad.  The second way is they both have different values in the same triad and neither was detected as an error.  In both of these cases the data from the third chromaton is used to fix these.  Even if the third chromaton is wrong or has a detected error in the spot in question, we need a tie breaker, so the data in the third chromaton is used to settle any remaining disputes between the two chromaton being compared.  Now the 2 chromaton that were being compared are identical and are considered the correct version.%0a
host:1611816189=104.175.54.158
author:1611815605=
diff:1611815605:1611815592:=350,351d349%0a%3c %0a%3c If all 3 of the checksums are different, what do we do?  Firstly I want to say that all 3 being different will be extremely rare since we already have perfect 1-bit error correction and roughly 95%25 2-bit error detection at the base level. But when it does rarely happen we can do something else so we don't loose all the data in the base chromaton just because of a couple errors.  What we will do is take the 2 chromaton with the fewest detected errors (if there is a tie, favor chromaton with fewest errors and most similar checksums, if still a tie favor chromaton with the fewest errors and most different checksums, if still a tie forget about errors and choose the two with the most different checksums) and then compare those two at the base chromaton level.  Anything that is different between the 2, we check to see if there were any errors detected previously in those spots.  If in one of the chromaton one triad was detected as an error and the other chromaton does not have an error detected in that triad, then the error triad is replaced with the non-error triad.  After all of this what we will be left with is 2 chromaton that are either now identical or only vary in one of two ways.  The first way they can vary is if both have different errors in the same triad.  The second way is they both have different values in the same triad and neither was detected as an error.  In both of these cases the data from the third chromaton is used to fix these.  Even if the third chromaton is wrong or has a detected error in the spot in question, we need a tie breaker, so the data in the third chromaton is used to settle any remaining disputes between the two chromaton being compared.  Now the 2 chromaton that were being compared are identical and are considered the correct version.%0a
host:1611815605=104.175.54.158
author:1611815592=
diff:1611815592:1611815528:=369,370c369,371%0a%3c %0a%3c %0a---%0a> If they give the same value to this test, then the data-set is exactly the same, and just pick the [[#cv3number|first chromaton in the triad]], which will basically be the member of the triad closest to the upper left side of the chromaton.%0a> %0a> If all 3 of the checksums are different, what do we do?  Firstly I want to say that all 3 being different will be extremely rare since we already have perfect 1-bit error correction and roughly 95%25 2-bit error detection at the base level. But when it does rarely happen we can do something else so we don't loose all the data in the base chromaton just because of a couple errors.  What we will do is take the 2 chromaton with the fewest detected errors (if there is a tie, favor chromaton with fewest errors and most similar checksums, if still a tie favor chromaton with the fewest errors and most different checksums, if still a tie forget about errors and choose the two with the most different checksums) and then compare those two at the base chromaton level.  Anything that is different between the 2, we check to see if there were any errors detected previously in those spots.  If in one of the chromaton one triad was detected as an error and the other chromaton does not have an error detected in that triad, then the error triad is replaced with the non-error triad.  After all of this what we will be left with is 2 chromaton that are either now identical or only vary in one of two ways.  The first way they can vary is if both have different errors in the same triad.  The second way is they both have different values in the same triad and neither was detected as an error.  In both of these cases the data from the third chromaton is used to fix these.  Even if the third chromaton is wrong or has a detected error in the spot in question, we need a tie breaker, so the data in the third chromaton is used to settle any remaining disputes between the two chromaton being compared.  Now the 2 chromaton that were being compared are identical and are considered the correct version.%0a
host:1611815592=104.175.54.158
author:1611815528=
diff:1611815528:1611815483:=366c366%0a%3c If you are here, then chances are at least 2 of your 3 replicate chromaton are identical.  Congratulations!  For the final check, each and every value is compared between eachother.  A 4x4 matrix is set-up for each chromaton and each of the 16 values are compared between eachother.  If they all/both match, great, select the [[#cv3number|first chromaton in the triad]] as the winner, the replicate closest to the upper left of the chromaton, with no error reported!  If they do not match, then choose the one with the average value closest to 1.5.  To do this add up all the numbers in the matrix.  Next divide by 16 and call that the "answer".  Then take (1.5-answer)^2 and the one with the lowest number wins.  If this is the case, then report a soft error of [#5].%0a---%0a> If you are here, then chances are at least 2 of your 3 replicate chromaton are identical.  Congratulations!  For the final check, each and every value is compared between eachother.  A 4x4 matrix is set-up for each chromaton and each of the 16 values are compared between eachother.  If they all/both match, great, select the first one as the winner, the replicate closest to the upper left of the chromaton, with no error reported!  If they do not match, then choose the one with the average value closest to 1.5.  To do this add up all the numbers in the matrix.  Next divide by 16 and call that the "answer".  Then take (1.5-answer)^2 and the one with the lowest number wins.  If this is the case, then report a soft error of [#5].%0a
host:1611815528=104.175.54.158
author:1611815483=
diff:1611815483:1611815405:=366c366%0a%3c If you are here, then chances are at least 2 of your 3 replicate chromaton are identical.  Congratulations!  For the final check, each and every value is compared between eachother.  A 4x4 matrix is set-up for each chromaton and each of the 16 values are compared between eachother.  If they all/both match, great, select the first one as the winner, the replicate closest to the upper left of the chromaton, with no error reported!  If they do not match, then choose the one with the average value closest to 1.5.  To do this add up all the numbers in the matrix.  Next divide by 16 and call that the "answer".  Then take (1.5-answer)^2 and the one with the lowest number wins.  If this is the case, then report a soft error of [#5].%0a---%0a> If you are here, then chances are at least 2 of your 3 replicate chromaton are identical.  Congratulations!  For the final check, each and every value is compared between eachother.  A 4x4 matrix is set-up for each chromaton and each of the 16 values are compared between eachother.  If they all/both match, great, select the first one as the winner, the replicate closest to the upper left of the chromaton.  If they do not match, then choose the one with the average value closest to 1.5.  To do this add up all the numbers in the matrix.  Next divide by 16 and call that the "answer".  Then take (1.5-answer)^2 and the one with the lowest number wins.%0a
host:1611815483=104.175.54.158
author:1611815405=
diff:1611815405:1611815386:=366c366%0a%3c If you are here, then chances are at least 2 of your 3 replicate chromaton are identical.  Congratulations!  For the final check, each and every value is compared between eachother.  A 4x4 matrix is set-up for each chromaton and each of the 16 values are compared between eachother.  If they all/both match, great, select the first one as the winner, the replicate closest to the upper left of the chromaton.  If they do not match, then choose the one with the average value closest to 1.5.  To do this add up all the numbers in the matrix.  Next divide by 16 and call that the "answer".  Then take (1.5-answer)^2 and the one with the lowest number wins.%0a---%0a> If you are here, then chances are at least 2 of your 3 replicate chromaton are identical.  congratulations!  For the final check, each and every value is compared between eachother.  A 4x4 matrix is set-up for each chromaton and each of the 16 values are compared between eachother.  If they all/both match, great, select the first one as the winner, the replicate closest to the upper left of the chromaton.  If they do not match, then choose the one with the average value closest to 1.5.  To do this add up all the numbers in the matrix.  Next divide by 16 and call that the "answer".  Then take (1.5-answer)^2 and the one with the lowest number wins.%0a
host:1611815405=104.175.54.158
author:1611815386=
diff:1611815386:1611815313:=362c362%0a%3c Next the rows are added and the columns added.  Mod 4 means that the sum is then divided by 4 and the remainder is reported.  Now these remainders are compared between the 2 (or 3) replicate chromaton.  If there are 3 and 2 match and one doesn't, then discard the non-matching.  If 2 are remaining and they agree great, go to next step.  If they do not agree, choose the one with the average checksum closest to 1.5.  To determine this you take all 8 checksums, add them together, divide by 8, and call that "answer".  Then take (1.5-answer)^2 and compare this value to the other chromaton's value.  The smaller number wins.  If they are the same, go to next step.  If there is one winner at this step, report a soft error of [#4].%0a---%0a> Next the rows are added and the columns added.  Mod 4 means that the sum is then divided by 4 and the remainder is reported.  Now these remainders are compared between the 2 (or 3) replicate chromaton.  If there are 3 and 2 match and one doesn't, then discard the non-matching.  If 2 are remaining and they agree great, go to next step.  If they do not agree, choose the one with the average checksum closest to 1.5.  To determine this you take all 8 checksums, add them together, divide by 8, and call that "answer".  Then take (1.5-answer)^2 and compare this value to the other chromaton's value.  The smaller number wins.  If they are the same, go to next step.%0a
host:1611815386=104.175.54.158
author:1611815313=
diff:1611815313:1611815218:=355c355%0a%3c A parity check is a count of how many times a certain value showed up in our chromaton. Add up the number of each type of triad, our base-4 numbers. So add up the number of each "0"s, the "1"s, the "2"s, and the "3"s. And compare the results across the remaining chromaton.  This would be something like chromaton1 contains 5x "0", 10x "1", 1x "2", 0x "3".  Now if chromaton2 matches chromaton1 parity check but chromaton3 has a different parity check, then we can exclude chromaton3.  If there were only 2 remaining before the parity check calculation and both have different parity checks, then choose the one with the most even distribution of numbers. We can use a sort of "r^2 method". In our case there are 16 numbers so an even distribution would be 4x of each 0,1,2,3. Our r^2 method would subtract our actual number by 4 and then square the value.  So for our sample set it would be (5-4)^2 + (10-4)^2 + (1-4)^2 + (0-4)^2.  Now choose the one with the lowest value of this test.  After this test the only errors that would be matching is if all the right values were included in both chromaton, but the location of the values were different.  If a winner is chosen here report a soft error of [#3].%0a---%0a> A parity check is a count of how many times a certain value showed up in our chromaton. Add up the number of each type of triad, our base-4 numbers. So add up the number of each "0"s, the "1"s, the "2"s, and the "3"s. And compare the results across the remaining chromaton.  This would be something like chromaton1 contains 5x "0", 10x "1", 1x "2", 0x "3".  Now if chromaton2 matches chromaton1 parity check but chromaton3 has a different parity check, then we can exclude chromaton3.  If there were only 2 remaining before the parity check calculation and both have different parity checks, then choose the one with the most even distribution of numbers. We can use a sort of "r^2 method". In our case there are 16 numbers so an even distribution would be 4x of each 0,1,2,3. Our r^2 method would subtract our actual number by 4 and then square the value.  So for our sample set it would be (5-4)^2 + (10-4)^2 + (1-4)^2 + (0-4)^2.  Now choose the one with the lowest value of this test.  After this test the only errors that would be matching is if all the right values were included in both chromaton, but the location of the values were different.  %0a
host:1611815313=104.175.54.158
author:1611815218=
diff:1611815218:1611815205:=364c364%0a%3c !!!!!5. Final comparison%0a---%0a> !!!!!Final comparison%0a
host:1611815218=104.175.54.158
author:1611815205=
diff:1611815205:1611815194:=357c357%0a%3c !!!!!4. Checksum%0a---%0a> !!!!!Checksum%0a
host:1611815205=104.175.54.158
author:1611815194=
diff:1611815194:1611815115:=352c352%0a%3c !!!!!3. Parity check%0a---%0a> !!!!!Parity check%0a
host:1611815194=104.175.54.158
author:1611815115=
diff:1611815115:1611814998:=350,351c350,351%0a%3c !!!!!2. Lowest errors%0a%3c In the case all 3 have the same sum or two do, pick the one with the least amount of errors reported in the [[#v3error|original error correction steps]] to use as the "one correct version" ("winner").  If a winner is chosen here, then report a soft error of [#2].  If a tie between any of the replicates are found, go to step 3.%0a---%0a> !!!!!Lowest errors%0a> In the case all 3 have the same sum or two do, pick the one with the least amount of errors to use as the "one correct version" ("winner").  %0a
host:1611815115=104.175.54.158
author:1611814998=
diff:1611814998:1611814921:=293c293%0a%3c !!!!Error correction [[#v3error]]%0a---%0a> !!!!Error correction%0a
host:1611814998=104.175.54.158
author:1611814921=
diff:1611814921:1611814697:=344c344%0a%3c !!!!!1. Sum%0a---%0a> !!!!!# Sum%0a347,349c347%0a%3c If all three are different, we choose the one with the sum closest to 24.  Take (24-sum)^2 and the one closest to zero wins.  If you choose a winner here, report a soft error of [#1].%0a%3c %0a%3c Or if 2 or more agree on the sum then this is great, and if the sums equal then the overwhelming chance is the chromaton are in fact the same. However we still have to decide which one to correct it to!  We can't just keep all the chromaton since they are replicates at this level.  One idea would be to choose one randomly.  The reason we won't do this is 2-fold.  Firstly it would take a lot of processing power to run a pseudorandom algorithm every time we needed to make a decision.  Another reason is random algorithms can be cracked and a malicious attacker could know ahead of time which one you will pick and insert a malicious chromaton in the position that he knows will beat the detection.  So we need to use actual intelligent decisions so we are all on the same page.  The following techniques will go from fast and easy to slower and more complicated.  We hope the fast and simple methods can converge us on an answer, and if not then we go to the more expensive techniques. See history of error correction for more info on the following checks [[https://www.techradar.com/news/computing/how-error-detection-and-correction-works-1080736|#]].%0a---%0a> This is great, and if the sums equal then the overwhelming chance is the chromaton are in fact the same. However we still have to decide which one to correct it to!  We can't just keep all the chromaton since they are replicates at this level.  One idea would be to choose one randomly.  The reason we won't do this is 2-fold.  Firstly it would take a lot of processing power to run a pseudorandom algorithm every time we needed to make a decision.  Another reason is random algorithms can be cracked and a malicious attacker could know ahead of time which one you will pick and insert a malicious chromaton in the position that he knows will beat the detection.  So we need to use actual intelligent decisions so we are all on the same page.  The following techniques will go from fast and easy to slower and more complicated.  We hope the fast and simple methods can converge us on an answer, and if not then we go to the more expensive techniques. See history of error correction for more info on the following checks [[https://www.techradar.com/news/computing/how-error-detection-and-correction-works-1080736|#]].%0a
host:1611814921=79.141.162.81
author:1611814697=
diff:1611814697:1611814639:=344c344%0a%3c !!!!!# Sum%0a---%0a> !!!!!Sum%0a
host:1611814697=79.141.162.81
author:1611814639=
diff:1611814639:1611813954:=358c358%0a%3c Basically each of the 16 values in the chromaton, 0-3, is placed in a 4x4 matrix.%0a---%0a> Basically each of the 16 values in the chromaton, 0-3, is placed in a 4x4 matrix.  Next the %0a360,364c360%0a%3c Next the rows are added and the columns added.  Mod 4 means that the sum is then divided by 4 and the remainder is reported.  Now these remainders are compared between the 2 (or 3) replicate chromaton.  If there are 3 and 2 match and one doesn't, then discard the non-matching.  If 2 are remaining and they agree great, go to next step.  If they do not agree, choose the one with the average checksum closest to 1.5.  To determine this you take all 8 checksums, add them together, divide by 8, and call that "answer".  Then take (1.5-answer)^2 and compare this value to the other chromaton's value.  The smaller number wins.  If they are the same, go to next step.%0a%3c %0a%3c !!!!!Final comparison%0a%3c %0a%3c If you are here, then chances are at least 2 of your 3 replicate chromaton are identical.  congratulations!  For the final check, each and every value is compared between eachother.  A 4x4 matrix is set-up for each chromaton and each of the 16 values are compared between eachother.  If they all/both match, great, select the first one as the winner, the replicate closest to the upper left of the chromaton.  If they do not match, then choose the one with the average value closest to 1.5.  To do this add up all the numbers in the matrix.  Next divide by 16 and call that the "answer".  Then take (1.5-answer)^2 and the one with the lowest number wins.%0a---%0a> %0a
host:1611814639=79.141.162.81
author:1611813954=
diff:1611813954:1611811076:=357,365c357,362%0a%3c To check the location we will use a checksum which is a little more computationally intensive since it requires a 2D matrix.%0a%3c Basically each of the 16 values in the chromaton, 0-3, is placed in a 4x4 matrix.  Next the %0a%3c Attach:checksum.png%0a%3c %0a%3c %0a%3c !!!!!All else%0a%3c If they give the same value to this test, then the data-set is exactly the same, and just pick the [[#cv3number|first chromaton in the triad]], which will basically be the member of the triad closest to the upper left side of the chromaton.%0a%3c %0a%3c If all 3 of the checksums are different, what do we do?  Firstly I want to say that all 3 being different will be extremely rare since we already have perfect 1-bit error correction and roughly 95%25 2-bit error detection at the base level. But when it does rarely happen we can do something else so we don't loose all the data in the base chromaton just because of a couple errors.  What we will do is take the 2 chromaton with the fewest detected errors (if there is a tie, favor chromaton with fewest errors and most similar checksums, if still a tie favor chromaton with the fewest errors and most different checksums, if still a tie forget about errors and choose the two with the most different checksums) and then compare those two at the base chromaton level.  Anything that is different between the 2, we check to see if there were any errors detected previously in those spots.  If in one of the chromaton one triad was detected as an error and the other chromaton does not have an error detected in that triad, then the error triad is replaced with the non-error triad.  After all of this what we will be left with is 2 chromaton that are either now identical or only vary in one of two ways.  The first way they can vary is if both have different errors in the same triad.  The second way is they both have different values in the same triad and neither was detected as an error.  In both of these cases the data from the third chromaton is used to fix these.  Even if the third chromaton is wrong or has a detected error in the spot in question, we need a tie breaker, so the data in the third chromaton is used to settle any remaining disputes between the two chromaton being compared.  Now the 2 chromaton that were being compared are identical and are considered the correct version.%0a---%0a> To check the location we will use one or more "checksum(s)" which is a little more computationally intensive since it requires a 2D matrix.%0a> Basically each value , 0-3, is placed in a 4x4 matrix for each chromaton.%0a> %0a> If they give the same value to this test, we are going to assume that the dataset is exactly the same, and just pick the [[#cv3number|first chromaton in the triad]], which will basically be the member of the triad closest to the upper left side of the chromaton.%0a> %0a> If all 3 of the checksums are different, what do we do?  Firstly I want to say that all 3 bieng different will be extremely rare since we already have perfect 1-bit error correction and roughly 95%25 2-bit error detection at the base level. But when it does rarely happen we can do something else so we don't loose all the data in the base chromaton just because of a couple errors.  What we will do is take the 2 chromaton with the fewest detected errors (if there is a tie, favor chromaton with fewest errors and most similar checksums, if still a tie favor chromaton with the fewest errors and most different checksums, if still a tie forget about errors and choose the two with the most different checksums) and then compare those two at the base chromaton level.  Anything that is different between the 2, we check to see if there were any errors detected previously in those spots.  If in one of the chromaton one triad was detected as an error and the other chromaton does not have an error detected in that triad, then the error triad is replaced with the non-error triad.  After all of this what we will be left with is 2 chromaton that are either now identical or only vary in one of two ways.  The first way they can vary is if both have different errors in the same triad.  The second way is they both have different values in the same triad and neither was detected as an error.  In both of these cases the data from the third chromaton is used to fix these.  Even if the third chromaton is wrong or has a detected error in the spot in question, we need a tie breaker, so the data in the third chromaton is used to settle any remaining disputes between the two chromaton bieng compared.  Now the 2 chromaton that were bieng compared are identical and are considered the correct version.%0a
host:1611813954=79.141.162.81
author:1611811076=
diff:1611811076:1611808147:=275c275%0a%3c A private key is 256 bits.  In the [[digital collectible network]], private keys might be valued around $0.50%0a---%0a> A private key is 256 bits.%0a
host:1611811076=79.141.162.81
author:1611808147=
diff:1611808147:1611808122:=349c349%0a%3c In the case all 3 have the same sum or two do, pick the one with the least amount of errors to use as the "one correct version" ("winner").  %0a---%0a> In the case all 3 have the same sum, pick the one with the least amount of errors to use as the "one correct version" ("winner").  %0a
host:1611808147=104.175.54.158
author:1611808122=
diff:1611808122:1611807912:=348c348%0a%3c !!!!!Lowest errors%0a---%0a> %0a349a350%0a> %0a
host:1611808122=104.175.54.158
author:1611807912=
diff:1611807912:1611807774:=347c347%0a%3c This is great, and if the sums equal then the overwhelming chance is the chromaton are in fact the same. However we still have to decide which one to correct it to!  We can't just keep all the chromaton since they are replicates at this level.  One idea would be to choose one randomly.  The reason we won't do this is 2-fold.  Firstly it would take a lot of processing power to run a pseudorandom algorithm every time we needed to make a decision.  Another reason is random algorithms can be cracked and a malicious attacker could know ahead of time which one you will pick and insert a malicious chromaton in the position that he knows will beat the detection.  So we need to use actual intelligent decisions so we are all on the same page.  The following techniques will go from fast and easy to slower and more complicated.  We hope the fast and simple methods can converge us on an answer, and if not then we go to the more expensive techniques. See history of error correction for more info on the following checks [[https://www.techradar.com/news/computing/how-error-detection-and-correction-works-1080736|#]].%0a---%0a> This is great, and if the sums equal the overwhelming chance is the chromaton are in fact the same. However we still have to decide which one to correct it to!  We can't just keep all the chromaton since they are replicates at this level.  One idea would be to choose one randomly.  The reason we won't do this is 2-fold.  Firstly it would take a lot of processing power to run a pseudorandom algorithm every time we needed to make a decision.  Another reason is random algorithms can be cracked and a malicious attacker could know ahead of time which one you will pick and insert a malicious chromaton in the position that he knows will beat the detection.  So we need to use actual intelligent decisions so we are all on the same page.  The following techniques will go from fast and easy to slower and more complicated.  We hope the fast and simple methods can converge us on an answer, and if not then we go to the more expensive techniques. See history of error correction for more info on the following checks [[https://www.techradar.com/news/computing/how-error-detection-and-correction-works-1080736|#]].%0a
host:1611807912=104.175.54.158
author:1611807774=
diff:1611807774:1611803526:=345c345%0a%3c Kilochromaton (and higher) gives us another check of the lower chromaton we are reading.  At this level we use "sum" of the lower level.  So first we decode and error correct all base level chromaton.  Then we sum up all the numbers contained in each chromaton and this is the sum, one for each chromaton.  In kilochromaton level we compare the three sums for each replicate chromaton.  If all 3 are the same then we verified that everything is perfect (we have 16 base-4 numbers so the chance that we randomly got the sums to equal yet actually be wrong is 1/64 × 1/64 × 1/64 = 3.8×10^(-6) or 4 times in 1 million).  But for 2 of them to randomly give the same sum wrongly is 1/64 * (1-(63/64)*(63/64)) = 0.049%25 or 484 times in a million.  So since we will accept if 2 of them add to the same sum, we will have a 99.95%25 correct - error correction rate.  This not only corrects 1-bit errors at this level, this corrects up to 48-bit errors!  An entire base chromaton could be wrong and it could be fixed at this level. %0a---%0a> Kilochromaton (and higher) gives us another check of the lower chromaton we are reading.  At this level we use "sum" of the lower level.  So first we decode and error correct all base level chromaton.  Then we sum up all the numbers in each chromaton and this is the sum, one for each chromaton.  In kilochromaton level we compare the three sums for each replicate chromaton.  If all 3 are the same then we verified that everything is perfect (we have 16 base-4 numbers so the chance that we randomly got the sums to equal yet actually be wrong is 1/64 × 1/64 × 1/64 = 3.8×10^(-6) or 4 times in 1 million).  But for 2 of them to randomly give the same sum wrongly is 1/64 * (1-(63/64)*(63/64)) = 0.049%25 or 484 times in a million.  So since we will accept if 2 of them add to the same sum, we will have a 99.95%25 correct - error correction rate.  This not only corrects 1-bit errors at this level, this corrects up to 48-bit errors!  An entire base chromaton could be wrong and it could be fixed at this level. %0a
host:1611807774=104.175.54.158
author:1611803526=
diff:1611803526:1611803512:=343a344%0a> %0a
host:1611803526=104.175.54.158
author:1611803512=
diff:1611803512:1611802615:=345d344%0a%3c !!!!!Sum%0a352,357c351,353%0a%3c !!!!!Parity check%0a%3c If they all have the same amount of errors or 2 have the same amount, then we need something more than a sum, a "parity check".  %0a%3c %0a%3c A parity check is a count of how many times a certain value showed up in our chromaton. Add up the number of each type of triad, our base-4 numbers. So add up the number of each "0"s, the "1"s, the "2"s, and the "3"s. And compare the results across the remaining chromaton.  This would be something like chromaton1 contains 5x "0", 10x "1", 1x "2", 0x "3".  Now if chromaton2 matches chromaton1 parity check but chromaton3 has a different parity check, then we can exclude chromaton3.  If there were only 2 remaining before the parity check calculation and both have different parity checks, then choose the one with the most even distribution of numbers. We can use a sort of "r^2 method". In our case there are 16 numbers so an even distribution would be 4x of each 0,1,2,3. Our r^2 method would subtract our actual number by 4 and then square the value.  So for our sample set it would be (5-4)^2 + (10-4)^2 + (1-4)^2 + (0-4)^2.  Now choose the one with the lowest value of this test.  After this test the only errors that would be matching is if all the right values were included in both chromaton, but the location of the values were different.  %0a%3c %0a%3c !!!!!Checksum%0a---%0a> If they all have the same amount of errors or 2 have the same amount, then we need something more than a sum, a "parity bit".  %0a> %0a> A parity bit is a count of how many times a certain value showed up in our chromaton. Add up the number of each type of triad, our base-4 numbers. So add up the number of each "0"s, the "1"s, the "2"s, and the "3"s. And compare the results across the remaining chromaton.  This would be something like chromaton1 contains 5x "0", 10x "1", 1x "2", 0x "3".  Now if chromaton2 matches chromaton1 parity bit but chromaton3 has a different parity bit, then we can exclude chromaton3.  If there were only 2 remaining before the parity bit calculation and both have different parity bits, then choose the one with the most even distribution of numbers. We can use a sort of "r^2 method". In our case there are 16 numbers so an even distribution would be 4x of each 0,1,2,3. Our r^2 method would subtract our actual number by 4 and then square the value.  So for our sample set it would be (5-4)^2 + (10-4)^2 + (1-4)^2 + (0-4)^2.  Now choose the one with the lowest value of this test.  After this test the only errors that would be matching is if all the right values were included in both chromaton, but the location of the values were different.  %0a
host:1611803512=104.175.54.158
author:1611802615=
diff:1611802615:1611802067:=344,348c344,347%0a%3c %0a%3c Kilochromaton (and higher) gives us another check of the lower chromaton we are reading.  At this level we use "sum" of the lower level.  So first we decode and error correct all base level chromaton.  Then we sum up all the numbers in each chromaton and this is the sum, one for each chromaton.  In kilochromaton level we compare the three sums for each replicate chromaton.  If all 3 are the same then we verified that everything is perfect (we have 16 base-4 numbers so the chance that we randomly got the sums to equal yet actually be wrong is 1/64 × 1/64 × 1/64 = 3.8×10^(-6) or 4 times in 1 million).  But for 2 of them to randomly give the same sum wrongly is 1/64 * (1-(63/64)*(63/64)) = 0.049%25 or 484 times in a million.  So since we will accept if 2 of them add to the same sum, we will have a 99.95%25 correct - error correction rate.  This not only corrects 1-bit errors at this level, this corrects up to 48-bit errors!  An entire base chromaton could be wrong and it could be fixed at this level. %0a%3c %0a%3c This is great, and if the sums equal the overwhelming chance is the chromaton are in fact the same. However we still have to decide which one to correct it to!  We can't just keep all the chromaton since they are replicates at this level.  One idea would be to choose one randomly.  The reason we won't do this is 2-fold.  Firstly it would take a lot of processing power to run a pseudorandom algorithm every time we needed to make a decision.  Another reason is random algorithms can be cracked and a malicious attacker could know ahead of time which one you will pick and insert a malicious chromaton in the position that he knows will beat the detection.  So we need to use actual intelligent decisions so we are all on the same page.  The following techniques will go from fast and easy to slower and more complicated.  We hope the fast and simple methods can converge us on an answer, and if not then we go to the more expensive techniques. See history of error correction for more info on the following checks [[https://www.techradar.com/news/computing/how-error-detection-and-correction-works-1080736|#]].%0a%3c %0a---%0a> This gives us another check of the lower chromaton we are reading.  At this level we use "sum" of the lower level.  So first we decode and error correct all base level chromaton.  Then we sum up all the numbers in each chromaton and this is the sum, one for each chromaton.  In kilochromaton level we compare the three sums for each replicate chromaton.  If all 3 are the same then we verified that everything is perfect (we have 16 base-4 numbers so the chance that we randomly got the sums to equal yet actually be wrong is 1/64 × 1/64 × 1/64 = 3.8×10^(-6) or 4 times in 1 million).  But for 2 of them to randomly give the same sum wrongly is 1/64 * (1-(63/64)*(63/64)) = 0.049%25 or 484 times in a million.  So since we will accept if 2 of them add to the same sum, we will have a 99.95%25 correct - error correction rate.  This not only corrects 1-bit errors at this level, this corrects up to 48-bit errors!  An entire base chromaton could be wrong and it could be fixed at this level.%0a> %0a> This is great, and if the sums equal the overwhelming chance is the chromaton are in fact the same. However we still have to decide which one to correct it to!  We can't just keep all the chromaton since they are replicates at this level.  One idea would be to choose one randomly.  The reason we won't do this is 2-fold.  Firstly it would take a lot of processing power to run a pseudorandom algorithm every time we needed to make a decision.  Another reason is random algorithms can be cracked and a malicious attacker could know ahead of time which one you will pick and insert a malicious chromaton in the position that he knows will beat the real chromaton.  So we need to use actual intelligent decisions so we are all on the same page.%0a> %0a351,356c350,353%0a%3c If they all have the same amount of errors or 2 have the same amount, then we need something more than a sum, a "parity bit".  %0a%3c %0a%3c A parity bit is a count of how many times a certain value showed up in our chromaton. Add up the number of each type of triad, our base-4 numbers. So add up the number of each "0"s, the "1"s, the "2"s, and the "3"s. And compare the results across the remaining chromaton.  This would be something like chromaton1 contains 5x "0", 10x "1", 1x "2", 0x "3".  Now if chromaton2 matches chromaton1 parity bit but chromaton3 has a different parity bit, then we can exclude chromaton3.  If there were only 2 remaining before the parity bit calculation and both have different parity bits, then choose the one with the most even distribution of numbers. We can use a sort of "r^2 method". In our case there are 16 numbers so an even distribution would be 4x of each 0,1,2,3. Our r^2 method would subtract our actual number by 4 and then square the value.  So for our sample set it would be (5-4)^2 + (10-4)^2 + (1-4)^2 + (0-4)^2.  Now choose the one with the lowest value of this test.  After this test the only errors that would be matching is if all the right values were included in both chromaton, but the location of the values were different.  %0a%3c %0a%3c To check the location we will use one or more "checksum(s)" which is a little more computationally intensive since it requires a 2D matrix.%0a%3c Basically each value , 0-3, is placed in a 4x4 matrix for each chromaton.%0a---%0a> If they all have the same amount of errors or 2 have the same amount, then we need something more than a sum, a "checksum".  %0a> %0a> %0a> A parity bit is a count of how many times a certain value showed up in our chromaton. Add up the number of each type of triad, our base-4 numbers. So add up the number of each "0"s, the "1"s, the "2"s, and the "3"s. And compare the results across the remaining chromaton.  This would be something like chromaton1 contains 5x "0", 10x "1", 1x "2", 0x "3".  Now if chromaton2 matches chromaton1 parity bit but chromaton3 has a different parity bit, then we can exclude chromaton3.  If there were only 2 remaining before the parity bit calculation and both have different parity bits, then choose the one with the most even distribution of numbers. We can use a sort of "r^2 method". In our case there are 16 numbers so an even distribution would be 4x of each 0,1,2,3. Our r^2 method would subtract our actual number by 4 and then square the value.  So for our sample set it would be (5-4)^2 + (10-4)^2 + (1-4)^2 + (0-4)^2.  Now choose the one with the lowest value of this test.  After this test the only errors that would be matching is if all the right values were included in both chromaton, but the location of the values were different.%0a
host:1611802615=104.175.54.158
author:1611802067=
diff:1611802067:1611801719:=344,353c344,348%0a%3c This gives us another check of the lower chromaton we are reading.  At this level we use "sum" of the lower level.  So first we decode and error correct all base level chromaton.  Then we sum up all the numbers in each chromaton and this is the sum, one for each chromaton.  In kilochromaton level we compare the three sums for each replicate chromaton.  If all 3 are the same then we verified that everything is perfect (we have 16 base-4 numbers so the chance that we randomly got the sums to equal yet actually be wrong is 1/64 × 1/64 × 1/64 = 3.8×10^(-6) or 4 times in 1 million).  But for 2 of them to randomly give the same sum wrongly is 1/64 * (1-(63/64)*(63/64)) = 0.049%25 or 484 times in a million.  So since we will accept if 2 of them add to the same sum, we will have a 99.95%25 correct - error correction rate.  This not only corrects 1-bit errors at this level, this corrects up to 48-bit errors!  An entire base chromaton could be wrong and it could be fixed at this level.%0a%3c %0a%3c This is great, and if the sums equal the overwhelming chance is the chromaton are in fact the same. However we still have to decide which one to correct it to!  We can't just keep all the chromaton since they are replicates at this level.  One idea would be to choose one randomly.  The reason we won't do this is 2-fold.  Firstly it would take a lot of processing power to run a pseudorandom algorithm every time we needed to make a decision.  Another reason is random algorithms can be cracked and a malicious attacker could know ahead of time which one you will pick and insert a malicious chromaton in the position that he knows will beat the real chromaton.  So we need to use actual intelligent decisions so we are all on the same page.%0a%3c %0a%3c In the case all 3 have the same sum, pick the one with the least amount of errors to use as the "one correct version" ("winner").  %0a%3c %0a%3c If they all have the same amount of errors or 2 have the same amount, then we need something more than a sum, a "checksum".  %0a%3c %0a%3c %0a%3c A parity bit is a count of how many times a certain value showed up in our chromaton. Add up the number of each type of triad, our base-4 numbers. So add up the number of each "0"s, the "1"s, the "2"s, and the "3"s. And compare the results across the remaining chromaton.  This would be something like chromaton1 contains 5x "0", 10x "1", 1x "2", 0x "3".  Now if chromaton2 matches chromaton1 parity bit but chromaton3 has a different parity bit, then we can exclude chromaton3.  If there were only 2 remaining before the parity bit calculation and both have different parity bits, then choose the one with the most even distribution of numbers. We can use a sort of "r^2 method". In our case there are 16 numbers so an even distribution would be 4x of each 0,1,2,3. Our r^2 method would subtract our actual number by 4 and then square the value.  So for our sample set it would be (5-4)^2 + (10-4)^2 + (1-4)^2 + (0-4)^2.  Now choose the one with the lowest value of this test.  After this test the only errors that would be matching is if all the right values were included in both chromaton, but the location of the values were different.%0a---%0a> This gives us another check of the lower chromaton we are reading.  At this level we use "checksum" of the lower level.  So first we decode and error correct all base level chromaton.  Then we sum up all the numbers in each chromaton and this is the checksum, one for each chromaton.  In kilochromaton level we compare the three checksums for each replicate chromaton.  If all 3 are the same then we verified that everything is perfect (we have 16 base-4 numbers so the chance that we randomly got the checksums to equal yet actually be wrong is 1/64 × 1/64 × 1/64 = 3.8×10^(-6) or 4 times in 1 million).  But for 2 of them to randomly give the same checksum wrongly is 1/64 * (1-(63/64)*(63/64)) = 0.049%25 or 484 times in a million.  So since we will accept if 2 of them add to the same checksum, we will have a 99.95%25 correct - error correction rate.  This not only corrects 1-bit errors at this level, this corrects up to 48-bit errors!  An entire base chromaton could be wrong and it could be fixed at this level.%0a> %0a> This is great, and if the checksums equal the overwhelming chance is the chromaton are in fact the same. However we still have to decide which one to correct it to!  We can't just keep all the chromaton since they are replicates at this level.  One idea would be to choose one randomly.  The reason we won't do this is 2 fold.  Firstly it would take a lot of processing power to run a pseudorandom algorithm every time we needed to make a decision.  Another reason is random algorithms can be cracked and a malicious attacker could know ahead of time which one you will pick and insert a malicious chromaton in the position that he knows will beat the random algorithm.  So we need to use actual decisions so we are all on the same page.%0a> %0a> In the case all 3 have the same checksum, pick the one with the least amount of errors to use as the "one correct version" ("winner").  If they all have the same amount of errors or 2 have the same amount, then we need something more than a checksum, a "parity bit".  A parity bit is a count of how many times a certain value showed up in our chromaton. Add up the number of each type of triad, our base-4 numbers. So add up the number of each "0"s, the "1"s, the "2"s, and the "3"s. And compare the results across the remaining chromaton.  This would be something like chromaton1 contains 5x "0", 10x "1", 1x "2", 0x "3".  Now if chromaton2 matches chromaton1 parity bit but chromaton3 has a different parity bit, then we can exclude chromaton3.  If there were only 2 remaining before the parity bit calculation and both have different parity bits, then choose the one with the most even distribution of numbers. We can use a sort of "r^2 method". In our case there are 16 numbers so an even distribution would be 4x of each 0,1,2,3. Our r^2 method would subtract our actual number by 4 and then square the value.  So for our sample set it would be (5-4)^2 + (10-4)^2 + (1-4)^2 + (0-4)^2.  Now choose the one with the lowest value of this test.  After this test the only errors that would be matching is if all the right values were included in both chromaton, but the location of the values were different.%0a
host:1611802067=104.175.54.158
author:1611801719=
diff:1611801719:1611801298:=348,350c348%0a%3c In the case all 3 have the same checksum, pick the one with the least amount of errors to use as the "one correct version" ("winner").  If they all have the same amount of errors or 2 have the same amount, then we need something more than a checksum, a "parity bit".  A parity bit is a count of how many times a certain value showed up in our chromaton. Add up the number of each type of triad, our base-4 numbers. So add up the number of each "0"s, the "1"s, the "2"s, and the "3"s. And compare the results across the remaining chromaton.  This would be something like chromaton1 contains 5x "0", 10x "1", 1x "2", 0x "3".  Now if chromaton2 matches chromaton1 parity bit but chromaton3 has a different parity bit, then we can exclude chromaton3.  If there were only 2 remaining before the parity bit calculation and both have different parity bits, then choose the one with the most even distribution of numbers. We can use a sort of "r^2 method". In our case there are 16 numbers so an even distribution would be 4x of each 0,1,2,3. Our r^2 method would subtract our actual number by 4 and then square the value.  So for our sample set it would be (5-4)^2 + (10-4)^2 + (1-4)^2 + (0-4)^2.  Now choose the one with the lowest value of this test.  After this test the only errors that would be matching is if all the right values were included in both chromaton, but the location of the values were different.%0a%3c %0a%3c If they give the same value to this test, we are going to assume that the dataset is exactly the same, and just pick the [[#cv3number|first chromaton in the triad]], which will basically be the member of the triad closest to the upper left side of the chromaton.%0a---%0a> In the case all 3 have the same checksum, pick the one with the least amount of errors to use as the "one correct version" ("winner").  If they all have the same amount of errors or 2 have the same amount, then we need something more than a checksum, a "parity bit".  Add up the number of each type of triad, our base-4 numbers. So add up the number of the "0"s, the "1"s, the "2"s, and the "3"s. And compare the results across the remaining chromaton.  This would be something like chromaton1 contains 5x "0", 10x "1", 1x "2", 0x "3".  Now if chromaton2 matches chromaton1 parity bit but chromaton3 has a different parity bit, then we can exclude chromaton3.  If there were only 2 remaining before the parity bit calculation and both have different parity bits, then choose the one with the most even distribution of numbers. We can use a sort of "r^2 method". In our case there are 16 numbers so an even distribution would be 4x of each 0,1,2,3. Our r^2 method would subtract our actual number by 4 and then square the value.  So for our sample set it would be (5-4)^2 + (10-4)^2 + (1-4)^2 + (0-4)^2.  Now choose the one with the lowest value of this test.  If they give the same value to this test, we are going to assume that the dataset is exactly the same, and just pick the [[#cv3number|first chromaton in the triad]].%0a
host:1611801719=104.175.54.158
author:1611801298=
diff:1611801298:1611801253:=348c348%0a%3c In the case all 3 have the same checksum, pick the one with the least amount of errors to use as the "one correct version" ("winner").  If they all have the same amount of errors or 2 have the same amount, then we need something more than a checksum, a "parity bit".  Add up the number of each type of triad, our base-4 numbers. So add up the number of the "0"s, the "1"s, the "2"s, and the "3"s. And compare the results across the remaining chromaton.  This would be something like chromaton1 contains 5x "0", 10x "1", 1x "2", 0x "3".  Now if chromaton2 matches chromaton1 parity bit but chromaton3 has a different parity bit, then we can exclude chromaton3.  If there were only 2 remaining before the parity bit calculation and both have different parity bits, then choose the one with the most even distribution of numbers. We can use a sort of "r^2 method". In our case there are 16 numbers so an even distribution would be 4x of each 0,1,2,3. Our r^2 method would subtract our actual number by 4 and then square the value.  So for our sample set it would be (5-4)^2 + (10-4)^2 + (1-4)^2 + (0-4)^2.  Now choose the one with the lowest value of this test.  If they give the same value to this test, we are going to assume that the dataset is exactly the same, and just pick the [[#cv3number|first chromaton in the triad]].%0a---%0a> In the case all 3 have the same checksum, pick the one with the least amount of errors to use as the "one correct version" ("winner").  If they all have the same amount of errors or 2 have the same amount, then we need something more than a checksum, a "parity bit".  Add up the number of each type of triad, our base-4 numbers. So add up the number of the "0"s, the "1"s, the "2"s, and the "3"s. And compare the results across the remaining chromaton.  This would be something like chromaton1 contains 5x "0", 10x "1", 1x "2", 0x "3".  Now if chromaton2 matches chromaton1 parity bit but chromaton3 has a different parity bit, then we can exclude chromaton3.  If there were only 2 remaining before the parity bit calculation and both have different parity bits, then choose the one with the most even distribution of numbers. We can use a sort of "r^2 method". In our case there are 16 numbers so an even distribution would be 4x of each 0,1,2,3. Our r^2 method would subtract our actual number by 4 and then square the value.  So for our sample set it would be (5-4)^2 + (10-4)^2 + (1-4)^2 + (0-4)^2.  Now choose the one with the lowest value of this test.  If they give the same value to this test, we are going to assume that the dataset is exactly the same, and just pick the [[#v3number|first chromaton in the triad]].%0a
host:1611801298=104.175.54.158
author:1611801253=
diff:1611801253:1611800035:=348c348%0a%3c In the case all 3 have the same checksum, pick the one with the least amount of errors to use as the "one correct version" ("winner").  If they all have the same amount of errors or 2 have the same amount, then we need something more than a checksum, a "parity bit".  Add up the number of each type of triad, our base-4 numbers. So add up the number of the "0"s, the "1"s, the "2"s, and the "3"s. And compare the results across the remaining chromaton.  This would be something like chromaton1 contains 5x "0", 10x "1", 1x "2", 0x "3".  Now if chromaton2 matches chromaton1 parity bit but chromaton3 has a different parity bit, then we can exclude chromaton3.  If there were only 2 remaining before the parity bit calculation and both have different parity bits, then choose the one with the most even distribution of numbers. We can use a sort of "r^2 method". In our case there are 16 numbers so an even distribution would be 4x of each 0,1,2,3. Our r^2 method would subtract our actual number by 4 and then square the value.  So for our sample set it would be (5-4)^2 + (10-4)^2 + (1-4)^2 + (0-4)^2.  Now choose the one with the lowest value of this test.  If they give the same value to this test, we are going to assume that the dataset is exactly the same, and just pick the [[#v3number|first chromaton in the triad]].%0a---%0a> In the case all 3 have the same checksum, pick the one with the least amount of errors to use as the "one correct version" ("winner").  If they all have the same amount of errors or 2 have the same amount, then pick the one %0a
host:1611801253=104.175.54.158
author:1611800035=
diff:1611800035:1611799358:=345,348d344%0a%3c %0a%3c This is great, and if the checksums equal the overwhelming chance is the chromaton are in fact the same. However we still have to decide which one to correct it to!  We can't just keep all the chromaton since they are replicates at this level.  One idea would be to choose one randomly.  The reason we won't do this is 2 fold.  Firstly it would take a lot of processing power to run a pseudorandom algorithm every time we needed to make a decision.  Another reason is random algorithms can be cracked and a malicious attacker could know ahead of time which one you will pick and insert a malicious chromaton in the position that he knows will beat the random algorithm.  So we need to use actual decisions so we are all on the same page.%0a%3c %0a%3c In the case all 3 have the same checksum, pick the one with the least amount of errors to use as the "one correct version" ("winner").  If they all have the same amount of errors or 2 have the same amount, then pick the one %0a
host:1611800035=104.175.54.158
author:1611799358=
diff:1611799358:1611799167:=344c344%0a%3c This gives us another check of the lower chromaton we are reading.  At this level we use "checksum" of the lower level.  So first we decode and error correct all base level chromaton.  Then we sum up all the numbers in each chromaton and this is the checksum, one for each chromaton.  In kilochromaton level we compare the three checksums for each replicate chromaton.  If all 3 are the same then we verified that everything is perfect (we have 16 base-4 numbers so the chance that we randomly got the checksums to equal yet actually be wrong is 1/64 × 1/64 × 1/64 = 3.8×10^(-6) or 4 times in 1 million).  But for 2 of them to randomly give the same checksum wrongly is 1/64 * (1-(63/64)*(63/64)) = 0.049%25 or 484 times in a million.  So since we will accept if 2 of them add to the same checksum, we will have a 99.95%25 correct - error correction rate.  This not only corrects 1-bit errors at this level, this corrects up to 48-bit errors!  An entire base chromaton could be wrong and it could be fixed at this level.%0a---%0a> This gives us another check of the lower chromaton we are reading.  At this level we use "checksum" of the lower level.  So first we decode and error correct all base level chromaton.  Then we sum up all the numbers in each chromaton and this is the checksum, one for each chromaton.  In kilochromaton level we compare the three checksums for each replicate chromaton.  If all 3 are the same then we verified that everything is perfect (we have 16 base-4 numbers so the chance that we randomly got the checksums to equal yet actually be wrong is 1/64 × 1/64 × 1/64 = 3.8×10^(-6) or 4 times in 1 million).  But for 2 of them to randomly give the same checksum wrongly is 1/64 * (1-(63/64)*(63/64)) = 0.049%25 which is the same calculation as 1/64 * ((1/64)+(1/64)) or 488 times in a million.  So since we will accept if 2 of them add to the same checksum, we will have a 99.95%25 correct - error correction rate.  This not only corrects 1-bit errors at this level, this corrects up to 48-bit errors!  An entire base chromaton could be wrong and it could be fixed at this level.%0a
host:1611799358=104.175.54.158
author:1611799167=
diff:1611799167:1611798349:=344c344%0a%3c This gives us another check of the lower chromaton we are reading.  At this level we use "checksum" of the lower level.  So first we decode and error correct all base level chromaton.  Then we sum up all the numbers in each chromaton and this is the checksum, one for each chromaton.  In kilochromaton level we compare the three checksums for each replicate chromaton.  If all 3 are the same then we verified that everything is perfect (we have 16 base-4 numbers so the chance that we randomly got the checksums to equal yet actually be wrong is 1/64 × 1/64 × 1/64 = 3.8×10^(-6) or 4 times in 1 million).  But for 2 of them to randomly give the same checksum wrongly is 1/64 * (1-(63/64)*(63/64)) = 0.049%25 which is the same calculation as 1/64 * ((1/64)+(1/64)) or 488 times in a million.  So since we will accept if 2 of them add to the same checksum, we will have a 99.95%25 correct - error correction rate.  This not only corrects 1-bit errors at this level, this corrects up to 48-bit errors!  An entire base chromaton could be wrong and it could be fixed at this level.%0a---%0a> This gives us another check of the lower chromaton we are reading.  At this level we use "checksum" of the lower level.  So first we decode and error correct all base level chromaton.  Then we sum up all the numbers in each chromaton and this is the checksum, one for each chromaton.  In kilochromaton level we compare the three checksums for each replicate chromaton.  If all 3 are the same then we verified that everything is perfect (we have 16 base-4 numbers so the chance that we randomly got the checksums to equal yet actually be wrong is 1/64 × 1/64 × 1/64 = 3.8×10^(-6) or 4 times in 1 million).  But for 2 of them to randomly give the same checksum wrongly is 1/64 × (1/64+1/64) = 0.049%25 or 488 times in a million.  So since we will accept if 2 of them add to the same checksum, we will have a 99.95%25 correct - error correction rate.  This not only corrects 1-bit errors at this level, this corrects up to 48-bit errors!  An entire base chromaton could be wrong and it could be fixed at this level.%0a
host:1611799167=104.175.54.158
author:1611798349=
diff:1611798349:1611797514:=320c320%0a%3c The chance a 3-bit error is undetected and looks like a 1-bit error or no error is 0.704*(1-(11/12)*(11/12)) = 11.2%25.  This means that there is a 70.4%25 chance of at least one spot having an allowable color and then at least one of the remaining spots having the exact right color, a 1/12 chance.  So 11.2%25 of 3-bit errors look like at least 2 of the colors are in the right spot. Using the below calculation, the chance a 3-bit error looks like a 1-bit error exactly, that 2 of the colors are correct and 1 is wrong is 11.2 - 0.23 = 10.97%25 chance.%0a---%0a> The chance a 3-bit error is undetected and looks like a 1-bit error or no error is 0.704*(1-(11/12)*(11/12)) = 11.2%25.  This means that there is a 70.4%25 chance of at least one spot having an allowable color and then at least one of the remaining spots having the exact right color, a 1/12 chance.  So 11.2%25 of 3-bit errors look like at least 2 of the colors are in the right spot. Using the below calculqtion, the chance a 3-bit error looks like a 1-bit error exactly, that 2 of the colors are correct and 1 is wrong is 11.2 - 0.23 = 10.97%25 chance.%0a
host:1611798349=104.175.54.158
author:1611797514=
diff:1611797514:1611789598:=299a300%0a> The following calculations are estimates and are not perfect.  They assume an infinite sample size of colors and since we only have 12 to choose from the percentages of correct diagnosis seen below would be higher than I have recorded.%0a
host:1611797514=104.175.54.158
author:1611789598=
diff:1611789598:1611789386:=279,283c279,283%0a%3c Megachromaton: 95 private keys, $47.50%0a%3c %0a%3c Gigachromaton: 2,762 private keys, $1381.00%0a%3c %0a%3c Terachromaton: 80,121 private keys, $40,060.50%0a---%0a> Megachromaton: 95 private keys, %0a> %0a> Gigachromaton: 2,762 private keys,%0a> %0a> Terachromaton:%0a
host:1611789598=104.175.54.158
author:1611789386=
diff:1611789386:1611789321:=281c281%0a%3c Gigachromaton: 2,762 private keys,%0a---%0a> Gigachromaton:%0a
host:1611789386=104.175.54.158
author:1611789321=
diff:1611789321:1611789259:=279c279%0a%3c Megachromaton: 95 private keys, %0a---%0a> Megachromaton:%0a
host:1611789321=104.175.54.158
author:1611789259=
diff:1611789259:1611789038:=276,284d275%0a%3c %0a%3c Kilochromaton: 3 private keys, $1.50.%0a%3c %0a%3c Megachromaton:%0a%3c %0a%3c Gigachromaton:%0a%3c %0a%3c Terachromaton:%0a%3c %0a
host:1611789259=104.175.54.158
author:1611789038=
diff:1611789038:1611785339:=274,275d273%0a%3c %0a%3c A private key is 256 bits.%0a
host:1611789038=104.175.54.158
author:1611785339=
diff:1611785339:1611783960:=267,268d266%0a%3c !!!!Byte calculations%0a%3c %0a273d270%0a%3c !!!!Private key calculations%0a
host:1611785339=104.175.54.158
author:1611783960=
diff:1611783960:1611783933:=314c314%0a%3c We have a 97.9%25 2-bit error detection and correction rate and 100%25 1-bit error detection and correction rate.  This is excellent, triads of Cv3 when compared to the pairs of Cv2, Cv2 only had 50%25 2-bit error detection (without filters) whereas with Cv3 and 3 bits, we get 97.9%25 2-bit error detection.  This is more than enough especially when using kilochromaton and higher as it will correct even more errors.%0a---%0a> We have a 97.9%25 2-bit error detection and correction rate and 100%25 1-bit error detection and correction rate.  This is excellent, triads of Cv3 compared to the pairs of Cv2, Cv2 only had 50%25 2-bit error detection (without filters) whereas with Cv3 and 3 bits, we get 97.9%25 2-bit error detection.  This is more than enough especially when using kilochromaton and higher as it will correct even more errors.%0a
host:1611783960=104.175.54.158
author:1611783933=
diff:1611783933:1611767636:=314c314%0a%3c We have a 97.9%25 2-bit error detection and correction rate and 100%25 1-bit error detection and correction rate.  This is excellent, triads of Cv3 compared to the pairs of Cv2, Cv2 only had 50%25 2-bit error detection (without filters) whereas with Cv3 and 3 bits, we get 97.9%25 2-bit error detection.  This is more than enough especially when using kilochromaton and higher as it will correct even more errors.%0a---%0a> We have a 97.9%25 2-bit error detection rate and 100%25 1-bit error correction rate.  This is excellent, triads of Cv3 compared to the pairs of Cv2, Cv2 only had 50%25 2-bit error detection (without filters) whereas with Cv3 and 3 bits, we get 97.9%25 2-bit error detection.  This is more than enough especially when using kilochromaton and higher as it will correct even more errors.%0a
host:1611783933=104.175.54.158
author:1611767636=
diff:1611767636:1611767490:=363,364d362%0a%3c %0a%3c Human DNA shed in stool [[https://pubmed.ncbi.nlm.nih.gov/10683738/|#]].%0a
host:1611767636=104.175.54.158
author:1611767490=
diff:1611767490:1611767465:=267c267%0a%3c Assuming an 11cm chromaton disk chromaton would have 1cm wide hexagons.  Kilochromaton would have 0.0909cm. Megachromaton is 0.008cm.  Gigachromaton is 0.00075cm which is 7.5 micron.  Terachromaton is 680nm (size of a DVD pit [[https://electronics.howstuffworks.com/dvd2.htm|#]]). Petachromaton is 62nm.  Exachromaton is 5.6nm.  So a CD size chromaton could potentially hold up to a couple gigabytes of data.  Not bad.  Especially when you consider data stored as chromaton is perfect data.%0a---%0a> Assuming an 11cm chromaton disk chromaton would have 1cm wide hexagons.  Kilochromaton would have 0.0909cm. Megachromaton is 0.008cm.  Gigachromaton is 0.00075cm which is 7.5 micron.  Terachromaton is 680nm (size of a DVD pit [[https://electronics.howstuffworks.com/dvd2.htm|#]]. Petachromaton is 62nm.  Exachromaton is 5.6nm.  So a CD size chromaton could potentially hold up to a couple gigabytes of data.  Not bad.  Especially when you consider data stored as chromaton is perfect data.%0a
host:1611767490=104.175.54.158
author:1611767465=
diff:1611767465:1611767152:=267c267%0a%3c Assuming an 11cm chromaton disk chromaton would have 1cm wide hexagons.  Kilochromaton would have 0.0909cm. Megachromaton is 0.008cm.  Gigachromaton is 0.00075cm which is 7.5 micron.  Terachromaton is 680nm (size of a DVD pit [[https://electronics.howstuffworks.com/dvd2.htm|#]]. Petachromaton is 62nm.  Exachromaton is 5.6nm.  So a CD size chromaton could potentially hold up to a couple gigabytes of data.  Not bad.  Especially when you consider data stored as chromaton is perfect data.%0a---%0a> Assuming an 11cm chromaton disk chromaton would have 1cm wide hexagons.  Kilochromaton would have 0.0909cm. Megachromaton is 0.008cm.  Gigachromaton is 0.00075cm which is 7.5 micron.  Terachromaton is 680nm. Petachromaton is 62nm.  Exachromaton is 5.6nm.  So a CD size chromaton could potentially hold up to a couple gigabytes of data.  Not bad.  Especially when you consider data stored as chromaton is perfect data.%0a
host:1611767465=104.175.54.158
author:1611767152=
diff:1611767152:1611766810:=362c362%0a%3c DNA from shed skin cells on airbag containing 5.87 ng of extracted DNA [[https://pubmed.ncbi.nlm.nih.gov/25434092/|#]] which gives us (9.13*10^11)*(5.87) = 5359310000000 base pairs.  Each base pair is a bit of data so that gives us 669.9 gigabytes of data.  Therefore if we assume about 1 TB of data is shed in skin cells and hair and other things, 19.6 petabytes are shed over 80 years.  With 7.8 billion people about 1.86 yottabytes of data per year from the human species.%0a---%0a> DNA from shed skin cells on airbag containing 5.87 ng of extracted DNA [[https://pubmed.ncbi.nlm.nih.gov/25434092/|#]] which gives us (9.13*10^11)*(5.87) = 5359310000000 base pairs.  Each base pair is a bit of data so that gives us 669.9 gigabytes of data.  Therefore if we assume about 1 TB of data is shed in skin cells and hair and other things, 19.6 petabytes are shed over 80 years.  Per year with 7.8 billion people about 1.86 yottabytes of data per year from the human species.%0a
host:1611767152=104.175.54.158
author:1611766810=
diff:1611766810:1611766527:=362c362%0a%3c DNA from shed skin cells on airbag containing 5.87 ng of extracted DNA [[https://pubmed.ncbi.nlm.nih.gov/25434092/|#]] which gives us (9.13*10^11)*(5.87) = 5359310000000 base pairs.  Each base pair is a bit of data so that gives us 669.9 gigabytes of data.  Therefore if we assume about 1 TB of data is shed in skin cells and hair and other things, 19.6 petabytes are shed over 80 years.  Per year with 7.8 billion people about 1.86 yottabytes of data per year from the human species.%0a---%0a> DNA from shed skin cells on airbag containing 5.87 ng of extracted DNA [[https://pubmed.ncbi.nlm.nih.gov/25434092/|#]] which gives us (9.13*10^11)*(5.87) = 5359310000000 base pairs.  Each base pair is a bit of data so that gives us 669.9 gigabytes of data.  Therefore if we assume about 1 TB of data is shed in skin cells and hair and other things, 19.6 petabytes are shed over 80 years.%0a
host:1611766810=104.175.54.158
author:1611766527=
diff:1611766527:1611766172:=360,363c360,362%0a%3c Base pairs per ng of DNA is 9.13x10^11 [[https://answers.yahoo.com/question/index?qid=20061107080441AA23nhV|#]].%0a%3c %0a%3c DNA from shed skin cells on airbag containing 5.87 ng of extracted DNA [[https://pubmed.ncbi.nlm.nih.gov/25434092/|#]] which gives us (9.13*10^11)*(5.87) = 5359310000000 base pairs.  Each base pair is a bit of data so that gives us 669.9 gigabytes of data.  Therefore if we assume about 1 TB of data is shed in skin cells and hair and other things, 19.6 petabytes are shed over 80 years.%0a%3c %0a---%0a> DNA from shed skin cells on airbag containing 5.87 ng of extracted DNA [[https://pubmed.ncbi.nlm.nih.gov/25434092/|#]] which gives us (9.13*10^11)*(5.87) = 5359310000000 base pairs.  Each base pair is a bit of data so that gives us 669.9 gigabytes of data.%0a> %0a> Base pairs per ng of DNA is 9.13x10^11 [[https://answers.yahoo.com/question/index?qid=20061107080441AA23nhV|#]].%0a\ No newline at end of file%0a
host:1611766527=104.175.54.158
author:1611766172=
diff:1611766172:1611755496:=358,362c358%0a%3c Human genome under a gigabyte [[https://simplyted.blogspot.com/2005/12/how-to-visualize-data.html?m=1|#]]%0a%3c %0a%3c DNA from shed skin cells on airbag containing 5.87 ng of extracted DNA [[https://pubmed.ncbi.nlm.nih.gov/25434092/|#]] which gives us (9.13*10^11)*(5.87) = 5359310000000 base pairs.  Each base pair is a bit of data so that gives us 669.9 gigabytes of data.%0a%3c %0a%3c Base pairs per ng of DNA is 9.13x10^11 [[https://answers.yahoo.com/question/index?qid=20061107080441AA23nhV|#]].%0a\ No newline at end of file%0a---%0a> Human genome under a gigabyte [[https://simplyted.blogspot.com/2005/12/how-to-visualize-data.html?m=1|#]]%0a\ No newline at end of file%0a
host:1611766172=104.175.54.158
author:1611755496=
diff:1611755496:1611753692:=355,358c355%0a%3c A complete history of error detection and correction [[https://www.techradar.com/news/computing/how-error-detection-and-correction-works-1080736|#]].%0a%3c %0a%3c Visualizing data sizes, bible is 4.5 megabytes,%0a%3c Human genome under a gigabyte [[https://simplyted.blogspot.com/2005/12/how-to-visualize-data.html?m=1|#]]%0a\ No newline at end of file%0a---%0a> A complete history of error detection and correction [[https://www.techradar.com/news/computing/how-error-detection-and-correction-works-1080736|#]].%0a\ No newline at end of file%0a
host:1611755496=104.175.54.158
author:1611753692=
diff:1611753692:1611751112:=353,355c353%0a%3c Femto laser creates color centers down to 3x10-3 um^3 which is around 100nm wide [[https://europepmc.org/article/PMC/PMC7823324|#]].%0a%3c %0a%3c A complete history of error detection and correction [[https://www.techradar.com/news/computing/how-error-detection-and-correction-works-1080736|#]].%0a\ No newline at end of file%0a---%0a> Femto laser creates color centers down to 3x10-3 um^3 which is around 100nm wide [[https://europepmc.org/article/PMC/PMC7823324|#]].%0a\ No newline at end of file%0a
host:1611753692=104.175.54.158
author:1611751112=
diff:1611751112:1611728431:=267c267%0a%3c Assuming an 11cm chromaton disk chromaton would have 1cm wide hexagons.  Kilochromaton would have 0.0909cm. Megachromaton is 0.008cm.  Gigachromaton is 0.00075cm which is 7.5 micron.  Terachromaton is 680nm. Petachromaton is 62nm.  Exachromaton is 5.6nm.  So a CD size chromaton could potentially hold up to a couple gigabytes of data.  Not bad.  Especially when you consider data stored as chromaton is perfect data.%0a---%0a> Assuming an 11cm chromaton disk chromaton would have 1cm wide hexagons.  Kilochromaton would have 0.0909cm. Megachromaton is 0.008cm.  Gigachromaton is 0.00075cm.  Terachromaton is 680nm. Petachromaton is 62nm.  Exachromaton is 5.6nm.  So a CD size chromaton could potentially hold up to a couple gigabytes of data.  Not bad.  Esepcially when you consider data stored as chromaton is perfect data.%0a
host:1611751112=104.175.54.158
author:1611728431=
diff:1611728431:1611728282:=314,316c314,316%0a%3c We have a 97.9%25 2-bit error detection rate and 100%25 1-bit error correction rate.  This is excellent, triads of Cv3 compared to the pairs of Cv2, Cv2 only had 50%25 2-bit error detection (without filters) whereas with Cv3 and 3 bits, we get 97.9%25 2-bit error detection.  This is more than enough especially when using kilochromaton and higher as it will correct even more errors.%0a%3c %0a%3c That 30%25 chance when we diagnose a 3-bit error correctly, we will still "correct" it wrongly but we will make a note that it is a 3-bit error [[https://electronics.stackexchange.com/questions/71410/single-bit-error-correction-double-bit-error-detection|#]].  This is because we do not know what the correct value is supposed to be so we have to make it something.  It would be nice if we could keep it and compare each color of each triad with the other replicate chromaton at the kilo- level, but unfortunatly we don't record a value for each color, only for each triad.  So if we can't get consensus within the triad, we have to correct it to a wrong value and record it as an error.  The good news is at the kilo- level, if the other 2 chromaton don't have an error recorded here, their data will take precedence over our erroneous data. Also see [[#kerror|kilochromaton error correction]].%0a---%0a> We have a 97.9%25 2-bit error detection rate and 100%25 1-bit error correction rate.  This is excellent, triads of Cv3 compared to the pairs of Cv2, Cv2 only had 50%25 2-bit error detection (without filters) whereas with Cv3 and 3 bits, we get 97.9%25 2-bit error detection.  This is more than enough especially when using kilochromaton and higher as it will correct even more errors.  Even though the 3-bit error is now "corrected" (probably wrongly) the good news is we detected the error so that will help us sort this out in [[#kerror|kilochromaton error correction]].%0a> %0a> That 30%25 chance when we diagnose a 3-bit error correctly, we will still "correct" it wrongly but we will make a note that it is a 3-bit error [[https://electronics.stackexchange.com/questions/71410/single-bit-error-correction-double-bit-error-detection|#]].  This is because we do not know what the correct value is supposed to be so we have to make it something.  It would be nice if we could keep it and compare each color of each triad with the other replicate chromaton at the kilo- level, but unfortunatly we don't record a value for each color, only for each triad.  So if we can't get consensus within the triad, we have to correct it to a wrong value and record it as an error.  The good news is at the kilo- level, if the other 2 chromaton don't have an error recorded here, their data will take precedence over our erroneous data.%0a
host:1611728431=104.175.54.158
author:1611728282=
diff:1611728282:1611728162:=314c314%0a%3c We have a 97.9%25 2-bit error detection rate and 100%25 1-bit error correction rate.  This is excellent, triads of Cv3 compared to the pairs of Cv2, Cv2 only had 50%25 2-bit error detection (without filters) whereas with Cv3 and 3 bits, we get 97.9%25 2-bit error detection.  This is more than enough especially when using kilochromaton and higher as it will correct even more errors.  Even though the 3-bit error is now "corrected" (probably wrongly) the good news is we detected the error so that will help us sort this out in [[#kerror|kilochromaton error correction]].%0a---%0a> We have a 94.4%25 2-bit error detection rate and 100%25 1-bit error correction rate.  This is excellent, triads of Cv3 compared to the pairs of Cv2, Cv2 only had 50%25 2-bit error detection (without filters) whereas with Cv3 and 3 bits, we get 94.4%25 2-bit error detection.  This is more than enough especially when using kilochromaton and higher as it will correct even more errors.  Even though the 3-bit error is now "corrected" (probably wrongly) the good news is we detected the error so that will help us sort this out in [[#kerror|kilochromaton error correction]].%0a
host:1611728282=104.175.54.158
author:1611728162=
diff:1611728162:1611727670:=307c307%0a%3c The chance a 3-bit error is undetected and looks like a 1-bit error or no error is 0.704*(1-(11/12)*(11/12)) = 11.2%25.  This means that there is a 70.4%25 chance of at least one spot having an allowable color and then at least one of the remaining spots having the exact right color, a 1/12 chance.  So 11.2%25 of 3-bit errors look like at least 2 of the colors are in the right spot. Using the below calculqtion, the chance a 3-bit error looks like a 1-bit error exactly, that 2 of the colors are correct and 1 is wrong is 11.2 - 0.23 = 10.97%25 chance.%0a---%0a> The chance a 3-bit error is undetected and looks like a 1-bit error or no error is 0.704*(1-(11/12)*(11/12)) = 11.2%25.  This means that there is a 70.4%25 chance of at least one spot having an allowable color and then at least one of the remaining spots having the exact right color, a 1/12 chance.  So 11.2%25 of 3-bit errors look like at least 2 of the colors are in the right spot. Using the below calculqtion, the chance a 3-bit error looks like a 1-bit error exactly, that 2 of the collorz are correct and 1 is wrong is 11.2 - 0.23 = 10.97%25 chance.%0a
host:1611728162=104.175.54.158
author:1611727670=
diff:1611727670:1611727391:=255,256d254%0a%3c Chromaton v3 means data perfection.%0a%3c %0a267,269c265,267%0a%3c Assuming an 11cm chromaton disk chromaton would have 1cm wide hexagons.  Kilochromaton would have 0.0909cm. Megachromaton is 0.008cm.  Gigachromaton is 0.00075cm.  Terachromaton is 680nm. Petachromaton is 62nm.  Exachromaton is 5.6nm.  So a CD size chromaton could potentially hold up to a couple gigabytes of data.  Not bad.  Esepcially when you consider data stored as chromaton is perfect data.%0a%3c %0a%3c If we started with 110cm chromaton sort of the size of very large book pages or posters a chromaton would have 10 cm pixels. Kilochromaton 0.909cm. Megachromaton 0.083cm.  Gigachromaton 0.0075cm. Terachromaton 0.00068cm. Pentachromaton 620nm (size of a dvd pit). Exachromaton 62nm. Zettachromaton is 5.6nm which is probably the limit for the near future. This means you could have a (very expensive) book that holds 62.5 gigabytes of data per page and have flawless error correction.%0a---%0a> Assuming an 11cm chromaton disk chromaton would have 1cm wide hexagons.  Kilochromaton would have 0.0909cm. Megachromaton is 0.008cm.  Gigachromaton is 0.00075cm.  Terachromaton is 680nm. Petachromaton is 62nm.  Exachromaton is 5.6nm.  So a CD size chromaton could potentially hold up to a couple gigabytes of data.  Not bad.%0a> %0a> If we started with 110cm chromaton sort of the size of very large book pages or posters a chromaton would have 10 cm pixels. Kilochromaton 0.909cm. Megachromaton 0.083cm.  Gigachromaton 0.0075cm. Terachromaton 0.00068cm. Pentachromaton 620nm (size of a dvd pit). Exachromaton 62nm. Zettachromaton is 5.6nm which is probably the limit for the near future. This means you could have a (very expensive) book that holds 62.5 gigabytes of data per page with flawless error correction.%0a
host:1611727670=104.175.54.158
author:1611727391=
diff:1611727391:1611727285:=292c292%0a%3c For that 97.9%25 of 2-bit errors we were able to detect, we can also correct them all!  Just as long as one bit was in an allowable spot and the other 2 were not, then we correct the ones that were not, with the other colors in the triad of the one color that was allowable.  We still record this as a 2-bit error though, because the chance we corrected it wrongly is quite high, since as seen below, the chance that a 3-bit error goes undetected is over 70%25.  Many of these undetected 3-bit errors will look like 2-bit errors.  It turns out 59.2%25 of 3-bit errors actually look like 2-bit errors and get wrongly diagnosed and corrected, see below for calculations.%0a---%0a> For that 97.9%25 of 2-bit errors we were able to detect, we can also correct them all!  Just as long as one bit was in an allowable spot and the other 2 were not, then we correct the ones that were not, with the other colors in the triad of the one color that was allowable.  We still record this as a 2-bit error though, because the chance we corrected it wrongly is quite high, since as seen below, the chance that a 3-bit error goes undetected is over 70%25.  Many of these undetected 3-bit errors will look like 2-bit errors (59.2%25 actually - see below for calculations).%0a
host:1611727391=104.175.54.158
author:1611727285=
diff:1611727285:1611727123:=292c292%0a%3c For that 97.9%25 of 2-bit errors we were able to detect, we can also correct them all!  Just as long as one bit was in an allowable spot and the other 2 were not, then we correct the ones that were not, with the other colors in the triad of the one color that was allowable.  We still record this as a 2-bit error though, because the chance we corrected it wrongly is quite high, since as seen below, the chance that a 3-bit error goes undetected is over 70%25.  Many of these undetected 3-bit errors will look like 2-bit errors (59.2%25 actually - see below for calculations).%0a---%0a> For that 97.9%25 of 2-bit errors we were able to detect, we can also correct them all!  Just as long as one bit was in an allowable spot and the other 2 were not, then we correct the ones that were not, with the other colors in the triad of the one color that was allowable.  We still record this as a 2-bit error though, because the chance we corrected it wrongly is quite high, since as seen below, the chance that a 3-bit error goes undetected is over 70%25.  Many of these undetected 3-bit errors will look like 2-bit errors (14.8%25 actually - (2/3)×(2/3)×(1/3) ).%0a
host:1611727285=104.175.54.158
author:1611727123=
diff:1611727123:1611726804:=287c287%0a%3c We will be able to correct every 1-bit error and only falsely correct (3/12)*(1/12)= 2.1%25 of 2-bit errors without detection because we diagnosed them as 1-bit errors wrongly.  This is because the chance that an error color is in an allowable spot is 1/3 (which is 4/12) but can't be the correct color (so subtract 1/12 from 4/12 and get 3/12) and the chance the last spot has the perfect color to go with the last error color, is 1/12. This way the correct color actually seems wrong and the error colors seem right.  %0a---%0a> We will be able to correct every 1-bit error and only falsely correct (3/12)*(1/12)= 2.1%25 of 2-bit errors without detection because we diagnosed them as 1-bit errors wrongly.  This is because the chance that an error color is in an allowable spot is 1/3 (which is 4/12) but can't be the correct color (so subtract 1/12 from 4/12 and get 3/12) and the chance a color in that error color's triad is also an error color in the triad in the correct spot where the actual correct color is not, is 1/12. This way the correct color actually seems wrong and the error colors seem right.  %0a
host:1611727123=104.175.54.158
author:1611726804=
diff:1611726804:1611726469:=289c289%0a%3c The chance that a 3-bit error is diagnosed wrongly as a 1-bit error is 10.9%25 as seen in the below calculations.%0a---%0a> The chance that a 3-bit error is diagnosed wrongly as a 1-bit error is (4/12)*(1/12)*(11/12) or 2.5%25.  This is because of a 1/3 chance an error color is in an allowable location.  Then there is only 1 color that will work to give an apparent correct triad so 1/12.  Then we need anything other than the correct color in the third spot so 11/12.%0a
host:1611726804=104.175.54.158
author:1611726469=
diff:1611726469:1611724139:=295,308c295,309%0a%3c See probability of "at least one" [[https://math.stackexchange.com/questions/85849/calculating-the-probability-that-at-least-one-of-a-series-of-events-will-happen#85852|#]].%0a%3c %0a%3c When all 3 colors in a triad are unallowable, this is a detectable 3-bit error.  Because of this we can detect some 3-bit errors.  %0a%3c %0a%3c To determine the chance we will need to calculate the chance that at least one color is in an allowable position.  The chance a color error bit is in an allowable position is 1/3.  So the chance that at least one color is in one of the allowable positions is 1-(chance none are in allowable positions) so 1-(2/3)*(2/3)*(2/3) = 70.4%25.  This means that in a 3-bit error, the chance that at least one color is in an allowable position is 70%25. So since we need all colors to be in an unallowable position, this means that we can only detect 30%25 of 3-bit errors.%0a%3c %0a%3c Having 3 colors all in unallowable positions is nonsense to a computer.  We cannot have a nonsense bit like this so we have to correct it, even though the chance of correcting it wrongly are extremely high.  To "correct" it and make it into a sensical bit (triad) we first look to see what colors the nonsensical triad contains.  If it contains all the colors of a sensical triad, just in the wrong locations, or if it contains the same color 2 times in the wrong spots we choose to correct it to that triad that contains that color bit.  Also if it contains 2 colors of a certain triad in the wrong locations we correct it to that triad.  If it contains 3 different colors all of different triads, at least that removes one of the 4 possible triads.  To select which triad to correct it to out of these 3, we now have a simple solution, correct it to the triad that gives the middle value.  Since all 4 triads are numbered 0-3, and all 3 triads are different in this case, one will have a value between the other 2.  We choose this one since it will effect the checksum of the chromaton the least.%0a%3c %0a%3c The chance a 3-bit error is undetected and looks like a 2-bit error or 1-bit error or no error is 70.4%25, since at least one needs to be in an allowable position.  Using the below calculation the chance of it looking like a 2-bit error exactly, is 70.4-11.2 = 59.2%25 chance.%0a%3c %0a%3c The chance a 3-bit error is undetected and looks like a 1-bit error or no error is 0.704*(1-(11/12)*(11/12)) = 11.2%25.  This means that there is a 70.4%25 chance of at least one spot having an allowable color and then at least one of the remaining spots having the exact right color, a 1/12 chance.  So 11.2%25 of 3-bit errors look like at least 2 of the colors are in the right spot. Using the below calculqtion, the chance a 3-bit error looks like a 1-bit error exactly, that 2 of the collorz are correct and 1 is wrong is 11.2 - 0.23 = 10.97%25 chance.%0a%3c %0a%3c The chance a 3-bit error is undetected and looks like no error at all is (1/3)×(1/12)×(1/12) or 0.23%25 chance.%0a%3c %0a---%0a> See probability of "at least one" [[https://www.khanacademy.org/math/ap-statistics/probability-ap/probability-multiplication-rule/a/probabilities-involving-at-least-one-success|#]].%0a> %0a> When all 3 colors in a triad are unallowable, this is a detectable 3-bit error.  Because of this we can detect a few 3-bit errors.  %0a> %0a> To determine the chance we will need to calculate the chance that at least one color is in an allowable position.  The chance a color is in the right position is 1/3.  So the chance that at least one color is in one of the right positions is 1-(chance they are all in allowable positions) so 1-(1/3)*(1/3)*(1/3) = 96.3%25.  This means that in a 3-bit error, the chance that at least one color is in an allowable position is 96.3%25. So this means that we can only detect 3.7%25 of 3-bit errors unfortunatly.%0a> %0a> We cannot have a nonsense bit like this so we have to correct it, even though the chance of correcting it wrongly are extremely high.  To "correct" it and make it into a sensical bit (triad) we first look to see what colors the nonsensical triad contains.  If it contains all the colors of a sensical triad, just in the wrong locations, or if it contains the same color 2 times in the wrong spots we choose to correct it to that triad.  Also if it contains 2 colors of a certain triad in the wrong locations we correct it to that triad.  If it contains 3 different colors all of different triads, at least that removes one of the 4 possible triads.  To select which triad to correct it to out of these 3, we now have a simple solution, correct it to the triad that gives the middle value.  Since all 4 triads are numbered 0-3, and all 3 triads are different in this case, one will have a value between the other 2.  We choose this one since it will effect the checksum of the chromaton the least.%0a> %0a> The chance a 3-bit error is undetected and looks like a 2-bit error is (2/3)×(2/3)×(1/3) or 14.8%25%0a> %0a> The chance a 3-bit error is undetected and looks like a 1-bit error is (2/3)×(1/3)×(1/12) or 1.9%25%0a> %0a> The chance a 3-bit error is undetected and looks like no error at all is (1/3)×(1/12)×(1/12) or 0.23%25%0a> %0a> 29.6+14.8+1.9+0.23 = 46.53%25.  This should add up to 100%25 so I think these are all underestimates but should be roughly correct relative to eachother.%0a
host:1611726469=104.175.54.158
author:1611724139=
diff:1611724139:1611720527:=297,299c297,299%0a%3c When all 3 colors in a triad are unallowable, this is a detectable 3-bit error.  Because of this we can detect a few 3-bit errors.  %0a%3c %0a%3c To determine the chance we will need to calculate the chance that at least one color is in an allowable position.  The chance a color is in the right position is 1/3.  So the chance that at least one color is in one of the right positions is 1-(chance they are all in allowable positions) so 1-(1/3)*(1/3)*(1/3) = 96.3%25.  This means that in a 3-bit error, the chance that at least one color is in an allowable position is 96.3%25. So this means that we can only detect 3.7%25 of 3-bit errors unfortunatly.%0a---%0a> When all 3 colors in a triad are unallowable, this is a detectable 3-bit error.  Because of this we can detect some 3-bit errors.  %0a> %0a> The chance we would detect a 3-bit error is (8/12)×(8/12)×(8/12)=29.6%25.  The explanation for this is a random error bit has a 2/3 chance of being in an unallowable spot.  So we need both of the other spots error bits to also have that 2/3 chance of bieng in an unallowable spot too. So we can detect roughly 1/3 of all 3-bit errors.  %0a
host:1611724139=104.175.54.158
author:1611720527=
diff:1611720527:1611719364:=295,296d294%0a%3c See probability of "at least one" [[https://www.khanacademy.org/math/ap-statistics/probability-ap/probability-multiplication-rule/a/probabilities-involving-at-least-one-success|#]].%0a%3c %0a
host:1611720527=104.175.54.158
author:1611719364=
diff:1611719364:1611718597:=297c297%0a%3c The chance we would detect a 3-bit error is (8/12)×(8/12)×(8/12)=29.6%25.  The explanation for this is a random error bit has a 2/3 chance of being in an unallowable spot.  So we need both of the other spots error bits to also have that 2/3 chance of bieng in an unallowable spot too. So we can detect roughly 1/3 of all 3-bit errors.  %0a---%0a> The chance we would detect a 3-bit error is (2/3)×(2/3)×(2/3)=29.6%25.  The explanation for this is a random error bit has a 2/3 chance of being in an unallowable spot.  So we need both of the other spots error bits to also have that 2/3 chance of bieng in an unallowable spot too. So we can detect roughly 1/3 of all 3-bit errors.  %0a
host:1611719364=104.175.54.158
author:1611718597=
diff:1611718597:1611718571:=278c278%0a%3c To get up to speed with probability calculations you will need to learn all these concepts found here [[https://www.statisticshowto.com/probability-and-statistics/probability-main-index/probability-of-a-and-b/|#]].%0a---%0a> To get up to speed with probability calculations you will need to elarn all these co cepts found here [[https://www.statisticshowto.com/probability-and-statistics/probability-main-index/probability-of-a-and-b/|#]].%0a
host:1611718597=104.175.54.158
author:1611718571=
diff:1611718571:1611717590:=278,279d277%0a%3c To get up to speed with probability calculations you will need to elarn all these co cepts found here [[https://www.statisticshowto.com/probability-and-statistics/probability-main-index/probability-of-a-and-b/|#]].%0a%3c %0a
host:1611718571=104.175.54.158
author:1611717590=
diff:1611717590:1611717560:=280c280%0a%3c As will be shown below, the Cv3 PEC system gives us 100%25 detection and correction of 1-bit errors, 98%25 detection and correction of 2-bit errors, and 30%25 detection of 3-bit errors.  These numbers increase astronomically when kilochromaton or higher are employed.  In kilochromaton most errors up to 48 bits will be corrected!%0a---%0a> As will be shown below, the Cv3 PEC system gives us 100%25 detection and correction of 1-bit errors, 94%25 detection and correction of 2-bit errors, and 30%25 detection of 3-bit errors.  These numbers increase astronomically when kilochromaton or higher are employed.  In kilochromaton most errors up to 48 bits will be corrected!%0a
host:1611717590=104.175.54.158
author:1611717560=
diff:1611717560:1611717537:=290c290%0a%3c For that 97.9%25 of 2-bit errors we were able to detect, we can also correct them all!  Just as long as one bit was in an allowable spot and the other 2 were not, then we correct the ones that were not, with the other colors in the triad of the one color that was allowable.  We still record this as a 2-bit error though, because the chance we corrected it wrongly is quite high, since as seen below, the chance that a 3-bit error goes undetected is over 70%25.  Many of these undetected 3-bit errors will look like 2-bit errors (14.8%25 actually - (2/3)×(2/3)×(1/3) ).%0a---%0a> For that 94.4%25 of 2-bit errors we were able to detect, we can also correct them all!  Just as long as one bit was in an allowable spot and the other 2 were not, then we correct the ones that were not, with the other colors in the triad of the one color that was allowable.  We still record this as a 2-bit error though, because the chance we corrected it wrongly is quite high, since as seen below, the chance that a 3-bit error goes undetected is over 70%25.  Many of these undetected 3-bit errors will look like 2-bit errors (14.8%25 actually - (2/3)×(2/3)×(1/3) ).%0a
host:1611717560=104.175.54.158
author:1611717537=
diff:1611717537:1611717288:=
host:1611717537=104.175.54.158
author:1611717288=
diff:1611717288:1611716861:=287c287%0a%3c The chance that a 3-bit error is diagnosed wrongly as a 1-bit error is (4/12)*(1/12)*(11/12) or 2.5%25.  This is because of a 1/3 chance an error color is in an allowable location.  Then there is only 1 color that will work to give an apparent correct triad so 1/12.  Then we need anything other than the correct color in the third spot so 11/12.%0a---%0a> The chance that a 3-bit error is diagnosed wrongly as a 1-bit error is (4/12)*(1/12)*(11/12) or 2.5%25.  This is because of a 1/3 chance an error color is in an allowable location.  Then there is only 1 color that will work to give an apparent correct triad so 1/12.  Then we need anything other than the correct color in the thjrd spot so 11/12.%0a
host:1611717288=104.175.54.158
author:1611716861=
diff:1611716861:1611713467:=285c285%0a%3c We will be able to correct every 1-bit error and only falsely correct (3/12)*(1/12)= 2.1%25 of 2-bit errors without detection because we diagnosed them as 1-bit errors wrongly.  This is because the chance that an error color is in an allowable spot is 1/3 (which is 4/12) but can't be the correct color (so subtract 1/12 from 4/12 and get 3/12) and the chance a color in that error color's triad is also an error color in the triad in the correct spot where the actual correct color is not, is 1/12. This way the correct color actually seems wrong and the error colors seem right.  %0a---%0a> We will be able to correct every 1-bit error and only falsely correct (3/12)*(1/12)= 2.1%25 of 2-bit errors without detection because we diagnosed them as 1-bit errors wrongly.  This is because the chance that an error color is in an allowable spot is 1/3 (which is 4/12) but can't be the correct color (so subtract 1/12 from 4/12 and get 3/12) and the chance a color in that error color's triad is also an error color in the triad in the correct spot where the actual correct color is not, is 1/12.  Then the correct color needs to be different than what the other 2 colors would indicate it should be, so 11/12.  This way the correct color actually seems wrong and the error colors seem right.  %0a
host:1611716861=104.175.54.158
author:1611713467=
diff:1611713467:1611713420:=
host:1611713467=104.175.54.158
author:1611713420=
diff:1611713420:1611712928:=285,287c285%0a%3c We will be able to correct every 1-bit error and only falsely correct (3/12)*(1/12)= 2.1%25 of 2-bit errors without detection because we diagnosed them as 1-bit errors wrongly.  This is because the chance that an error color is in an allowable spot is 1/3 (which is 4/12) but can't be the correct color (so subtract 1/12 from 4/12 and get 3/12) and the chance a color in that error color's triad is also an error color in the triad in the correct spot where the actual correct color is not, is 1/12.  Then the correct color needs to be different than what the other 2 colors would indicate it should be, so 11/12.  This way the correct color actually seems wrong and the error colors seem right.  %0a%3c %0a%3c The chance that a 3-bit error is diagnosed wrongly as a 1-bit error is (4/12)*(1/12)*(11/12) or 2.5%25.  This is because of a 1/3 chance an error color is in an allowable location.  Then there is only 1 color that will work to give an apparent correct triad so 1/12.  Then we need anything other than the correct color in the thjrd spot so 11/12.%0a---%0a> We will be able to correct every 1-bit error and only falsely correct (4/12)*(1/12)= 2.8%25 of 2-bit errors without detection because we diagnosed them as 1-bit errors wrongly.  This is because the chance that an error color is in an allowable spot is 1/3 (which is 4/12) and the chance a color in that error color's triad is also an error color in the triad in the correct spot where the actual correct color is not, is 1/12.  Then the correct color needs to be different than what the other 2 colors would indicate it should be, so 11/12.  This way the correct color actually seems wrong.  The chance that a 3-bit error is diagnosed wrongly as a 1-bit error is (4/12)*(1/12)*(11/12) or 2.5%25.%0a
host:1611713420=104.175.54.158
author:1611712928=
diff:1611712928:1611712703:=346c346%0a%3c Femto laser creates color centers down to 3x10-3 um^3 which is around 100nm wide [[https://europepmc.org/article/PMC/PMC7823324|#]].%0a\ No newline at end of file%0a---%0a> Femto laser creates color centers down to 3x10-3 um^3 [[https://europepmc.org/article/PMC/PMC7823324|#]].%0a\ No newline at end of file%0a
host:1611712928=104.175.54.158
author:1611712703=
diff:1611712703:1611711523:=344,346c344%0a%3c Diceware uses dice to create random numbers in base-6 [[https://en.m.wikipedia.org/wiki/Diceware|#]]%0a%3c %0a%3c Femto laser creates color centers down to 3x10-3 um^3 [[https://europepmc.org/article/PMC/PMC7823324|#]].%0a\ No newline at end of file%0a---%0a> Diceware uses dice to create random numbers in base-6 [[https://en.m.wikipedia.org/wiki/Diceware|#]]%0a\ No newline at end of file%0a
host:1611712703=104.175.54.158
author:1611711523=
diff:1611711523:1611711483:=17c17%0a%3c Chromaton is a free and open source visual code system similar to the patented QR (Quick Response) code.  Chromaton was natively designed to use six colors and is human readable.  Black and white are used for processing and do not constitute data.  The chromaton system is infinitely scalable in a fractal way.  Kilochromaton, Megachromaton, Gigachromaton, Terachromaton and more are all possible, the only limitation is the fidelity of the camera and printing/etching ability.%0a---%0a> Chromaton is a free and open source visual code system similar to the patented QR (Quick Response) code.  Chromaton was natively designed to use six colors and is human readable.  Black and white are used for processing and do not constitute data.  The chromaton system is infinitely scalable in a fractal way.  Kilochromaton, Megachromaton, Gigachromaton, Terachromaton and more are all possible, the only limitation is the fidelity of the camera.%0a
host:1611711523=104.175.54.158
author:1611711483=
diff:1611711483:1611711376:=18,19d17%0a%3c %0a%3c Chromaton "dots" can be any shape including circles or squares, hexagons are used here for placement and organization sake but any shape can be used.%0a
host:1611711483=104.175.54.158
author:1611711376=
diff:1611711376:1611711162:=263,265c263,265%0a%3c Assuming an 11cm chromaton disk chromaton would have 1cm wide hexagons.  Kilochromaton would have 0.0909cm. Megachromaton is 0.008cm.  Gigachromaton is 0.00075cm.  Terachromaton is 680nm. Petachromaton is 62nm.  Exachromaton is 5.6nm.  So a CD size chromaton could potentially hold up to a couple gigabytes of data.  Not bad.%0a%3c %0a%3c If we started with 110cm chromaton sort of the size of very large book pages or posters a chromaton would have 10 cm pixels. Kilochromaton 0.909cm. Megachromaton 0.083cm.  Gigachromaton 0.0075cm. Terachromaton 0.00068cm. Pentachromaton 620nm (size of a dvd pit). Exachromaton 62nm. Zettachromaton is 5.6nm which is probably the limit for the near future. This means you could have a (very expensive) book that holds 62.5 gigabytes of data per page with flawless error correction.%0a---%0a> Assuming an 11cm chromaton disk chromaton would have 1cm wide hexagons.  Kilochromaton would have 0.0909cm. Megachromaton is 0.008cm.  Gigachromaton is 0.00075cm.  Terachromaton is 680nm. Petachromaton is 62nm.  Exachromaton is 5.6nm.%0a> %0a> If we started with 110cm chromaton sort of the size of book pages a chromaton would have 10 cm pixels. Kilochromaton 0.909cm. Megachromaton 0.083cm.  Gigachromaton 0.0075cm. Terachromaton 0.00068cm. Pentachromaton 620nm (size of a dvd pit). Exachromaton 62nm. Zettachromaton is 5.6nm which is probably the limit for the near future. This means you could have a (very expensive) book that holds 62.5 gigabytes of data per page with flawless error correction.%0a
host:1611711376=104.175.54.158
author:1611711162=
diff:1611711162:1611710414:=263,265c263%0a%3c Assuming an 11cm chromaton disk chromaton would have 1cm wide hexagons.  Kilochromaton would have 0.0909cm. Megachromaton is 0.008cm.  Gigachromaton is 0.00075cm.  Terachromaton is 680nm. Petachromaton is 62nm.  Exachromaton is 5.6nm.%0a%3c %0a%3c If we started with 110cm chromaton sort of the size of book pages a chromaton would have 10 cm pixels. Kilochromaton 0.909cm. Megachromaton 0.083cm.  Gigachromaton 0.0075cm. Terachromaton 0.00068cm. Pentachromaton 620nm (size of a dvd pit). Exachromaton 62nm. Zettachromaton is 5.6nm which is probably the limit for the near future. This means you could have a (very expensive) book that holds 62.5 gigabytes of data per page with flawless error correction.%0a---%0a> Assuming an 11cm chromaton disk chromaton would have 1cm wide hexagons.  Kilochromaton would have 0.0909cm. Megachromaton is 0.008cm.  Gigachromaton is 0.00075cm.  Terachromaton is 680nm. Petachromaton is 62nm.  Exachromaton is 5.6nm%0a
host:1611711162=104.175.54.158
author:1611710414=
diff:1611710414:1611697573:=259,260d258%0a%3c !!!Storage calculations%0a%3c %0a262,263d259%0a%3c %0a%3c Assuming an 11cm chromaton disk chromaton would have 1cm wide hexagons.  Kilochromaton would have 0.0909cm. Megachromaton is 0.008cm.  Gigachromaton is 0.00075cm.  Terachromaton is 680nm. Petachromaton is 62nm.  Exachromaton is 5.6nm%0a
host:1611710414=104.175.54.158
author:1611697573=
diff:1611697573:1611690579:=277c277%0a%3c We will be able to correct every 1-bit error and only falsely correct (4/12)*(1/12)= 2.8%25 of 2-bit errors without detection because we diagnosed them as 1-bit errors wrongly.  This is because the chance that an error color is in an allowable spot is 1/3 (which is 4/12) and the chance a color in that error color's triad is also an error color in the triad in the correct spot where the actual correct color is not, is 1/12.  Then the correct color needs to be different than what the other 2 colors would indicate it should be, so 11/12.  This way the correct color actually seems wrong.  The chance that a 3-bit error is diagnosed wrongly as a 1-bit error is (4/12)*(1/12)*(11/12) or 2.5%25.%0a---%0a> We will be able to correct every 1-bit error and only falsely correct (1/3)*(1/12+1/12) = 1/18 = 5.6%25 of 2-bit errors without detection because we diagnosed them as 1-bit errors wrongly.  This is because the chance that an error color is in an allowable spot is 1/3 and the chance a color in that error color's triad is also an error color in the triad in an allowable spot is 1/12 for each spot so 2/12 total.  The chance that a 3-bit error is diagnosed wrongly as a 1-bit error is (2/3)×(1/3)×(1/12) or 1.9%25.%0a
host:1611697573=104.175.54.158
author:1611690579=
diff:1611690579:1611675220:=197,198d196%0a%3c %0a%3c Why version 2?  Better [[#v2error|error correction]]%0a204c202%0a%3c !!!Error correction [[#v2error]]%0a---%0a> !!!Error correction%0a
host:1611690579=104.175.54.158
author:1611675220=
diff:1611675220:1611674055:=281,293c281%0a%3c When all 3 colors in a triad are unallowable, this is a detectable 3-bit error.  Because of this we can detect some 3-bit errors.  %0a%3c %0a%3c The chance we would detect a 3-bit error is (2/3)×(2/3)×(2/3)=29.6%25.  The explanation for this is a random error bit has a 2/3 chance of being in an unallowable spot.  So we need both of the other spots error bits to also have that 2/3 chance of bieng in an unallowable spot too. So we can detect roughly 1/3 of all 3-bit errors.  %0a%3c %0a%3c We cannot have a nonsense bit like this so we have to correct it, even though the chance of correcting it wrongly are extremely high.  To "correct" it and make it into a sensical bit (triad) we first look to see what colors the nonsensical triad contains.  If it contains all the colors of a sensical triad, just in the wrong locations, or if it contains the same color 2 times in the wrong spots we choose to correct it to that triad.  Also if it contains 2 colors of a certain triad in the wrong locations we correct it to that triad.  If it contains 3 different colors all of different triads, at least that removes one of the 4 possible triads.  To select which triad to correct it to out of these 3, we now have a simple solution, correct it to the triad that gives the middle value.  Since all 4 triads are numbered 0-3, and all 3 triads are different in this case, one will have a value between the other 2.  We choose this one since it will effect the checksum of the chromaton the least.%0a%3c %0a%3c The chance a 3-bit error is undetected and looks like a 2-bit error is (2/3)×(2/3)×(1/3) or 14.8%25%0a%3c %0a%3c The chance a 3-bit error is undetected and looks like a 1-bit error is (2/3)×(1/3)×(1/12) or 1.9%25%0a%3c %0a%3c The chance a 3-bit error is undetected and looks like no error at all is (1/3)×(1/12)×(1/12) or 0.23%25%0a%3c %0a%3c 29.6+14.8+1.9+0.23 = 46.53%25.  This should add up to 100%25 so I think these are all underestimates but should be roughly correct relative to eachother.%0a---%0a> When all 3 colors in a triad are unallowable, this is a detectable 3-bit error.  Because of this we can detect some 3-bit errors.  The chance we would detect a 3-bit error is (2/3)×(2/3)×(2/3)=29.6%25.  The explanation for this is a random error bit has a 2/3 chance of being in an unallowable spot.  So we need both of the other spots error bits to also have that 2/3 chance of bieng in an unallowable spot too. So we can detect roughly 1/3 of all 3-bit errors.  We cannot have a nonsense bit like this so we have to correct it, even though the chance of correcting it wrongly are extremely high.  To "correct" it and make it into a sensical bit (triad) we first look to see what colors the nonsensical triad contains.  If it contains all the colors of a sensical triad, just in the wrong locations, or if it contains the same color 2 times in the wrong spots we choose to correct it to that triad.  Also if it contains 2 colors of a certain triad in the wrong locations we correct it to that triad.  If it contains 3 different colors all of different triads, at least that removes one of the 4 possible triads.  To select which triad to correct it to out of these 3, we now have a simple solution, correct it to the triad that gives the middle value.  Since all 4 triads are numbered 0-3, and all 3 triads are different in this case, one will have a value between the other 2.  We choose this one since it will effect the checksum of the chromaton the least.%0a
host:1611675220=104.175.54.158
author:1611674055=
diff:1611674055:1611673861:=270c270%0a%3c As will be shown below, the Cv3 PEC system gives us 100%25 detection and correction of 1-bit errors, 94%25 detection and correction of 2-bit errors, and 30%25 detection of 3-bit errors.  These numbers increase astronomically when kilochromaton or higher are employed.  In kilochromaton most errors up to 48 bits will be corrected!%0a---%0a> As will be shown below, the Cv3 system gives us 100%25 detection and correction of 1-bit errors, 94%25 detection and correction of 2-bit errors, and 30%25 detection of 3-bit errors.  These numbers increase astronomically when kilochromaton or higher are employed.  In kilochromaton most errors up to 48 bits will be corrected!%0a
host:1611674055=104.175.54.158
author:1611673861=
diff:1611673861:1611673557:=271,272d270%0a%3c %0a%3c The following calculations are estimates and are not perfect.  They assume an infinite sample size of colors and since we only have 12 to choose from the percentages of correct diagnosis seen below would be higher than I have recorded.%0a
host:1611673861=104.175.54.158
author:1611673557=
diff:1611673557:1611673295:=273c273%0a%3c We will be able to correct every 1-bit error and only falsely correct (1/3)*(1/12+1/12) = 1/18 = 5.6%25 of 2-bit errors without detection because we diagnosed them as 1-bit errors wrongly.  This is because the chance that an error color is in an allowable spot is 1/3 and the chance a color in that error color's triad is also an error color in the triad in an allowable spot is 1/12 for each spot so 2/12 total.  The chance that a 3-bit error is diagnosed wrongly as a 1-bit error is (2/3)×(1/3)×(1/12) or 1.9%25.%0a---%0a> We will be able to correct every 1-bit error and only falsely correct (1/3)*(1/12+1/12) = 1/18 = 5.6%25 of 2-bit errors without detection because we diagnosed them as 1-bit errors wrongly.  This is because the chance that an error color is in an allowable spot is 1/3 and the chance a color in that error color's triad is also an error color in the triad in an allowable spot is 1/12 for each spot so 2/12 total.%0a
host:1611673557=104.175.54.158
author:1611673295=
diff:1611673295:1611673143:=276c276%0a%3c For that 94.4%25 of 2-bit errors we were able to detect, we can also correct them all!  Just as long as one bit was in an allowable spot and the other 2 were not, then we correct the ones that were not, with the other colors in the triad of the one color that was allowable.  We still record this as a 2-bit error though, because the chance we corrected it wrongly is quite high, since as seen below, the chance that a 3-bit error goes undetected is over 70%25.  Many of these undetected 3-bit errors will look like 2-bit errors (14.8%25 actually - (2/3)×(2/3)×(1/3) ).%0a---%0a> For that 94.4%25 of 2-bit errors we were able to detect, we can also correct them all!  Just as long as one bit was in an allowable spot and the other 2 were not, then we correct the ones that were not, with the other colors in the triad of the one color that was allowable.  We still record this as a 2-bit error though, because the chance we corrected it wrongly is quite high, since as seen below, the chance that a 3-bit error goes undetected is over 70%25.  Most of these undetected 3-bit errors will look like 2-bit errors.%0a
host:1611673295=104.175.54.158
author:1611673143=
diff:1611673143:1611672790:=285c285%0a%3c That 30%25 chance when we diagnose a 3-bit error correctly, we will still "correct" it wrongly but we will make a note that it is a 3-bit error [[https://electronics.stackexchange.com/questions/71410/single-bit-error-correction-double-bit-error-detection|#]].  This is because we do not know what the correct value is supposed to be so we have to make it something.  It would be nice if we could keep it and compare each color of each triad with the other replicate chromaton at the kilo- level, but unfortunatly we don't record a value for each color, only for each triad.  So if we can't get consensus within the triad, we have to correct it to a wrong value and record it as an error.  The good news is at the kilo- level, if the other 2 chromaton don't have an error recorded here, their data will take precedence over our erroneous data.%0a---%0a> The 94.4%25 of times we correctly diagnose 2-bit errors, we will still "correct" it wrongly but we will make a note that it is an error [[https://electronics.stackexchange.com/questions/71410/single-bit-error-correction-double-bit-error-detection|#]].  This is because we do not know what the correct value is supposed to be so we have to make it something.  It would be nice if we could keep it and compare each color of each triad with the other replicate chromaton at the kilo- level, bit unfortunatly we don't record a value for each color, only for each triad.  So if we can't get consensus within the triad, we have to correct it to a wrong value and record it as an error.  The good news is at the kilo- level, if the other 2 chromaton don't have an error recorded here, their data will take precedence over our erroneous data.%0a
host:1611673143=104.175.54.158
author:1611672790=
diff:1611672790:1611672744:=283c283%0a%3c We have a 94.4%25 2-bit error detection rate and 100%25 1-bit error correction rate.  This is excellent, triads of Cv3 compared to the pairs of Cv2, Cv2 only had 50%25 2-bit error detection (without filters) whereas with Cv3 and 3 bits, we get 94.4%25 2-bit error detection.  This is more than enough especially when using kilochromaton and higher as it will correct even more errors.  Even though the 3-bit error is now "corrected" (probably wrongly) the good news is we detected the error so that will help us sort this out in [[#kerror|kilochromaton error correction]].%0a---%0a> We have a 94.4%25 2-bit error detection rate and 100%25 1-bit error correction rate.  This is excellent, triads of Cv3 compared to the pairs of Cv2, Cv2 only had 50%25 2-bit error detection (without filters) whereas with Cv3 and 3 bits, we get 94.4%25 2-bit error detection.  This is more than enough especially when using kilochromaton and higher as it will correct even more errors.  Even though the 3-bit error is now "corrected" (probably wrongly) the good news is we detected the error so that will help us sort this out in kilochromaton error correction.%0a
host:1611672790=104.175.54.158
author:1611672744=
diff:1611672744:1611672501:=299c299%0a%3c !!!!Kilo error correction [[#kerror]]%0a---%0a> !!!!Kilo error correction %0a
host:1611672744=104.175.54.158
author:1611672501=
diff:1611672501:1611672286:=283c283%0a%3c We have a 94.4%25 2-bit error detection rate and 100%25 1-bit error correction rate.  This is excellent, triads of Cv3 compared to the pairs of Cv2, Cv2 only had 50%25 2-bit error detection (without filters) whereas with Cv3 and 3 bits, we get 94.4%25 2-bit error detection.  This is more than enough especially when using kilochromaton and higher as it will correct even more errors.  Even though the 3-bit error is now "corrected" (probably wrongly) the good news is we detected the error so that will help us sort this out in kilochromaton error correction.%0a---%0a> We have a 94.4%25 2-bit error detection rate and 100%25 1-bit error correction rate.  This is excellent, 3 bits compared to 2 bits of Cv2, Cv2 only had 50%25 2-bit error detection (without filters) wheras with Cv3 and 3 bits, we get 94.4%25 2-bit error detection.  This is more than enough especially when using kilochromaton and higher as it will correct even more errors.  Even though the 3-bit error is now "corrected" (probably wrongly) the good news is we detected the error so that will help us sort this out in kilochromaton error correction.%0a
host:1611672501=104.175.54.158
author:1611672286=
diff:1611672286:1611671989:=279c279%0a%3c When all 3 colors in a triad are unallowable, this is a detectable 3-bit error.  Because of this we can detect some 3-bit errors.  The chance we would detect a 3-bit error is (2/3)×(2/3)×(2/3)=29.6%25.  The explanation for this is a random error bit has a 2/3 chance of being in an unallowable spot.  So we need both of the other spots error bits to also have that 2/3 chance of bieng in an unallowable spot too. So we can detect roughly 1/3 of all 3-bit errors.  We cannot have a nonsense bit like this so we have to correct it, even though the chance of correcting it wrongly are extremely high.  To "correct" it and make it into a sensical bit (triad) we first look to see what colors the nonsensical triad contains.  If it contains all the colors of a sensical triad, just in the wrong locations, or if it contains the same color 2 times in the wrong spots we choose to correct it to that triad.  Also if it contains 2 colors of a certain triad in the wrong locations we correct it to that triad.  If it contains 3 different colors all of different triads, at least that removes one of the 4 possible triads.  To select which triad to correct it to out of these 3, we now have a simple solution, correct it to the triad that gives the middle value.  Since all 4 triads are numbered 0-3, and all 3 triads are different in this case, one will have a value between the other 2.  We choose this one since it will effect the checksum of the chromaton the least.%0a---%0a> When all 3 colors in a triad are unallowable, this is a detectable 3-bit error.  Because of this we can detect some 3-bit errors.  The chance we would rightly detect a 3-bit error is (2/3)×(2/3)×(2/3)=29.6%25.  The explanation for this is a random error bit has a 2/3 chance of being in an unallowable spot.  So we need both of the other spots error bits to also have that 2/3 chance of bieng in an unallowable spot too. So we can detect roughly 1/3 of all 3-bit errors.  We cannot have a nonsense bit like this so we have to correct it, even though the chance of correcting it wrongly are extremely high.  To "correct" it and make it into a sensical bit (triad) we first look to see what colors the nonsensical triad contains.  If it contains all the colors of a sensical triad, just in the wrong locations, or if it contains the same color 2 times in the wrong spots we choose to correct it to that triad.  Also if it contains 2 colors of a certain triad in the wrong locations we correct it to that triad.  If it contains 3 different colors all of different triads, at least that removes one of the 4 possible triads.  To select which triad to correct it to out of these 3, we now have a simple solution, correct it to the triad that gives the middle value.  Since all 4 triads are numbered 0-3, and all 3 triads are different in this case, one will have a value between the other 2.  We choose this one since it will effect the checksum of the chromaton the least.%0a
host:1611672286=104.175.54.158
author:1611671989=
diff:1611671989:1611671923:=280,281d279%0a%3c %0a%3c !!!!!Conclusion%0a
host:1611671989=104.175.54.158
author:1611671923=
diff:1611671923:1611671700:=279c279%0a%3c When all 3 colors in a triad are unallowable, this is a detectable 3-bit error.  Because of this we can detect some 3-bit errors.  The chance we would rightly detect a 3-bit error is (2/3)×(2/3)×(2/3)=29.6%25.  The explanation for this is a random error bit has a 2/3 chance of being in an unallowable spot.  So we need both of the other spots error bits to also have that 2/3 chance of bieng in an unallowable spot too. So we can detect roughly 1/3 of all 3-bit errors.  We cannot have a nonsense bit like this so we have to correct it, even though the chance of correcting it wrongly are extremely high.  To "correct" it and make it into a sensical bit (triad) we first look to see what colors the nonsensical triad contains.  If it contains all the colors of a sensical triad, just in the wrong locations, or if it contains the same color 2 times in the wrong spots we choose to correct it to that triad.  Also if it contains 2 colors of a certain triad in the wrong locations we correct it to that triad.  If it contains 3 different colors all of different triads, at least that removes one of the 4 possible triads.  To select which triad to correct it to out of these 3, we now have a simple solution, correct it to the triad that gives the middle value.  Since all 4 triads are numbered 0-3, and all 3 triads are different in this case, one will have a value between the other 2.  We choose this one since it will effect the checksum of the chromaton the least.%0a---%0a> When all 3 colors in a triad are unallowable, this is a detectable 3-bit error.  Because of this we can detect some 3-bit errors.  The chance we would rightly detect a 3-bit error is (2/3)×(2/3)×(2/3)=29.6%25.  So we can detect roughly 1/3 of all 3-bit errors.  We cannot have a nonsense bit like this so we have to correct it, even though the chance of correcting it wrongly are extremely high.  To "correct" it and make it into a sensical bit (triad) we first look to see what colors the nonsensical triad contains.  If it contains all the colors of a sensical triad, just in the wrong locations, or if it contains the same color 2 times in the wrong spots we choose to correct it to that triad.  Also if it contains 2 colors of a certain triad in the wrong locations we correct it to that triad.  If it contains 3 different colors all of different triads, at least that removes one of the 4 possible triads.  To select which triad to correct it to out of these 3, we now have a simple solution, correct it to the triad that gives the middle value.  Since all 4 triads are numbered 0-3, and all 3 triads are different in this case, one will have a value between the other 2.  We choose this one since it will effect the checksum of the chromaton the least.%0a
host:1611671923=104.175.54.158
author:1611671700=
diff:1611671700:1611671475:=272,275c272,273%0a%3c !!!!!1-bit error%0a%3c We will be able to correct every 1-bit error and only falsely correct (1/3)*(1/12+1/12) = 1/18 = 5.6%25 of 2-bit errors without detection because we diagnosed them as 1-bit errors wrongly.  This is because the chance that an error color is in an allowable spot is 1/3 and the chance a color in that error color's triad is also an error color in the triad in an allowable spot is 1/12 for each spot so 2/12 total.%0a%3c %0a%3c !!!!!2-bit error%0a---%0a> This means we will be able to correct every 1-bit error and only falsely correct (1/3)*(1/12+1/12) = 1/18 = 5.6%25 of 2-bit errors without detection because we diagnosed them as 1-bit errors wrongly.  This is because the chance that an error color is in an allowable spot is 1/3 and the chance a color in that error color's triad is also an error color in the triad in an allowable spot is 1/12 for each spot so 2/12 total.%0a> %0a278,279c276%0a%3c !!!!!3-bit error%0a%3c When all 3 colors in a triad are unallowable, this is a detectable 3-bit error.  Because of this we can detect some 3-bit errors.  The chance we would rightly detect a 3-bit error is (2/3)×(2/3)×(2/3)=29.6%25.  So we can detect roughly 1/3 of all 3-bit errors.  We cannot have a nonsense bit like this so we have to correct it, even though the chance of correcting it wrongly are extremely high.  To "correct" it and make it into a sensical bit (triad) we first look to see what colors the nonsensical triad contains.  If it contains all the colors of a sensical triad, just in the wrong locations, or if it contains the same color 2 times in the wrong spots we choose to correct it to that triad.  Also if it contains 2 colors of a certain triad in the wrong locations we correct it to that triad.  If it contains 3 different colors all of different triads, at least that removes one of the 4 possible triads.  To select which triad to correct it to out of these 3, we now have a simple solution, correct it to the triad that gives the middle value.  Since all 4 triads are numbered 0-3, and all 3 triads are different in this case, one will have a value between the other 2.  We choose this one since it will effect the checksum of the chromaton the least.%0a---%0a> When all 3 colors in a triad are unallowable, this is a 3-bit error.  Because of this we can detect some 3-bit errors.  The chance we would rightly detect a 3-bit error is (2/3)×(2/3)×(2/3)=29.6%25.  So we can detect roughly 1/3 of all 3-bit errors.  We cannot have a nonsense bit like this so we have to correct it, even though the chance of correcting it wrongly are extremely high.  To "correct" it and make it into a sensical bit (triad) we first look to see what colors the nonsensical triad contains.  If it contains all the colors of a sensical triad, just in the wrong locations, or if it contains the same color 2 times in the wrong spots we choose to correct it to that triad.  Also if it contains 2 colors of a certain triad in the wrong locations we correct it to that triad.  If it contains 3 different colors all of different triads, at least that removes one of the 4 possible triads.  To select which triad to correct it to out of these 3, we now have a simple solution, correct it to the triad that gives the middle value.  Since all 4 triads are numbered 0-3, and all 3 triads are different in this case, one will have a value between the other 2.  We choose this one since it will effect the checksum of the chromaton the least.%0a
host:1611671700=104.175.54.158
author:1611671475=
diff:1611671475:1611596441:=276c276%0a%3c When all 3 colors in a triad are unallowable, this is a 3-bit error.  Because of this we can detect some 3-bit errors.  The chance we would rightly detect a 3-bit error is (2/3)×(2/3)×(2/3)=29.6%25.  So we can detect roughly 1/3 of all 3-bit errors.  We cannot have a nonsense bit like this so we have to correct it, even though the chance of correcting it wrongly are extremely high.  To "correct" it and make it into a sensical bit (triad) we first look to see what colors the nonsensical triad contains.  If it contains all the colors of a sensical triad, just in the wrong locations, or if it contains the same color 2 times in the wrong spots we choose to correct it to that triad.  Also if it contains 2 colors of a certain triad in the wrong locations we correct it to that triad.  If it contains 3 different colors all of different triads, at least that removes one of the 4 possible triads.  To select which triad to correct it to out of these 3, we now have a simple solution, correct it to the triad that gives the middle value.  Since all 4 triads are numbered 0-3, and all 3 triads are different in this case, one will have a value between the other 2.  We choose this one since it will effect the checksum of the chromaton the least.%0a---%0a> When all 3 colors in a triad are unallowable, this is a 3-bit error.  Because of this we can detect some 3-bit errors.  The chance we would rightly detect a 3-bit error is (2/3)×(2/3)×(2/3)=29.6%25.  So we can detect roughly 1/3 of all 3-bit errors.  We cannot have a nonsense bit like this so we have to correct it, even though the chance of correcting it wrongly are extremely high.  To "correct" it and make it into a sensical bit (triad) we first look to see what colors the nonsensical triad contains.  If it contains all the colors of a sensical triad, just in the wrong locations, or if it contains the same color 3 times we choose to correct it to that triad.  If it contains 2 colors of a certain triad in the wrong locations, or if it contains 2 of the same color, we correct it to that triad.  If it contains 3 different colors all of different triads, at least that removes one possible triad.  To select which triad to correct it to out of these 3 we now hqve a simple solution, correct it to the triad that gives the middle value.  Since all 4 triads are numbered 0-3, and all 3 triads are different in this case, one will have a value between the other 2.  We choose this one since it will effect the checksum of the chromaton the least.%0a
host:1611671475=104.175.54.158
author:1611596441=
diff:1611596441:1611596242:=300c300%0a%3c The Chromaton system can be used for any purpose including data transmission (including cryptographic keys and/or signatures proving ownership) and/or storage that is both human and computer readable, making visual displays for any use or purpose, for doing computations, etc.  It was invented to be used in transferring private keys between users of [[digital collectible network]].  Chromaton can also be used as data storage for photonic computers.%0a---%0a> The Chromaton system can be used for any purpose including data transmission (including cryptographic keys and/or signatures proving ownership) and/or storage that is both human and computer readable, making visual displays for any use or purpose, for doing computations, etc.  It was invented to be used in transferring private keys between users of [[digital collectible network]].%0a
host:1611596441=104.175.54.158
author:1611596242=
diff:1611596242:1611594062:=256,257d255%0a%3c %0a%3c In terms of storage, a chromaton contains 29 bits of data.  So a kilochromaton has 29×29=841 bits.  Megachromaton has 24,389 bits. Gigachromaton has 707,281 bits which is 88.4 kilobytes of data. Terachromaton has 20,511,149 bits which is 2.56 megabytes of data (which can store close to this entire website).  A petachromaton has 594,823,321 bits which is 74.4 megabytes of data.  An exachromaton has 17,249,876,309 bits which is 2.16 gigabytes of data.  A zettachromaton has 500,246,412,961 bits which is 62.5 gigabytes of data. A yottachromaton has 14507145975869 bits which is 1.8 terabytes of data. And in my mind that will be about the limit of practical 2D chromaton.  See [[3D chromaton disc]] for larger storages.%0a
host:1611596242=104.175.54.158
author:1611594062=
diff:1611594062:1611593770:=300c300%0a%3c For digital data storage and/or transmission uses, colors don't need to be used at all and can be replaced with numbers.  Using this system virtually perfect data transmission can be achieved free of any size bit error.  The whole purpose of the colors is making the data transmittible via visible photons at the speed of light with no prior established data link.  But if there is an established data link between the 2 (like bluetooth or internet) then colors are not needed. One thing that would not work with numbers would be the the color filters ([[#v2|chromaton version 2]]), so if that was removed only 50%25 error correction could be carried out on the lowest level of chromaton.  Perhaps instead of 2 bit groupings, 3 bit groupings could be used on the lowest level similar to higher levels of chromaton. And instead of having 24 base-6 digits on the lowest level and thus 60 binary bits, you would have 16 base-4 digits and thus 29 binary bits.  This was done in [[#v3|Chromaton v3]].%0a---%0a> For digital data storage and/or transmission uses, colors don't need to be used at all and can be replaced with numbers.  Using this system virtually perfect data transmission can be achieved free of any size bit error.  The whole purpose of the colors is making the data transmittible via visible photons at the speed of light with no prior established data link.  But if there is an established data link between the 2 (like bluetooth or internet) then colors are not needed. One thing that would not work with numbers would be the the color filters ([[#v2|chromaton version 2]]), so if that was removed only 50%25 error correction could be carried out on the lowest level of chromaton.  Perhaps instead of 2 bit groupings, 3 bit groupings could be used on the lowest level similar to higher levels of chromaton. And instead of having 24 base-6 digits on the lowest level and thus 60 binary bits, you would have 16 base-4 digits and thus 29 binary bits.  This was done in [[#v2|Chromaton v3]].%0a
host:1611594062=104.175.54.158
author:1611593770=
diff:1611593770:1611593659:=266c266%0a%3c To get rid of the color filters in Cv2, we need to use 3-color triads instead of 2-color pairs.  We will also force orientation in certain ways so there are 12 colors and only base-4.  We are giving up 8 bases (2/3rds) in order to have robust error detection and correction.  This means that each color is only in a set of 3 and must maintain a certain orientation. These methods, like in [[#v2|Cv2]], are part of physical information theory (PIT) or [[physical error correction]] (PEC) which is in contrast to algorithmic error correction (AEC) invented by Hamming.  PEC uses physical properties of data to detect and/or correct and/or prevent errors.  Some of these properties, as also explained in [[#v2|Cv2]], can be location, orientation, partnering, tagging, contrast, etc.  [[Physical error correction]] is the methodology most used in nature and can be found in DNA, visual field, neurons (such as memory and recall); and other data storage, transmission, and processing.%0a---%0a> To get rid of the color filters in Cv2, we need to use 3-color triads instead of 2-color pairs.  We will also force orientation in certain ways so there are 12 colors and only base-4.  We are giving up 8 bases (2/3rds) in order to have robust error detection and correction.  This means that each color is only in a set of 3 and must maintain a certain orientation. These methods, like in [[#v2|Cv2]], are part of physical information theory (PIT) or [[physical error correction]] (PEC).  PEC uses physical properties of data to detect and/or correct and/or prevent errors.  Some of these properties, as also explained in [[#v2|Cv2]], can be location, orientation, partnering, tagging, contrast, etc.  [[Physical error correction]] is the methodology most used in nature and can be found in DNA, visual field, neurons (such as memory and recall); and other data storage, transmission, and processing.%0a
host:1611593770=104.175.54.158
author:1611593659=
diff:1611593659:1611593527:=268c268%0a%3c As will be shown below, the Cv3 system gives us 100%25 detection and correction of 1-bit errors, 94%25 detection and correction of 2-bit errors, and 30%25 detection of 3-bit errors.  These numbers increase astronomically when kilochromaton or higher are employed.  In kilochromaton most errors up to 48 bits will be corrected!%0a---%0a> As will be shown below, this system gives us 100%25 detection and correction of 1-bit errors, 94%25 detection and correction of 2-bit errors, and 30%25 detection of 3-bit errors.  These numbers increase astronomically when kilochromaton or higher are employed.  In kilochromaton most errors up to 48 bits will be corrected!%0a
host:1611593659=104.175.54.158
author:1611593527=
diff:1611593527:1611593387:=
host:1611593527=104.175.54.158
author:1611593387=
diff:1611593387:1611592001:=266c266%0a%3c To get rid of the color filters in Cv2, we need to use 3-color triads instead of 2-color pairs.  We will also force orientation in certain ways so there are 12 colors and only base-4.  We are giving up 8 bases (2/3rds) in order to have robust error detection and correction.  This means that each color is only in a set of 3 and must maintain a certain orientation. These methods, like in [[#v2|Cv2]], are part of physical information theory (PIT) or [[physical error correction]] (PEC).  PEC uses physical properties of data to detect and/or correct and/or prevent errors.  Some of these properties, as also explained in [[#v2|Cv2]], can be location, orientation, partnering, tagging, contrast, etc.  [[Physical error correction]] is the methodology most used in nature and can be found in DNA, visual field, neurons (such as memory and recall); and other data storage, transmission, and processing.%0a---%0a> To get rid of the color filters in Cv2, we need to use 3 color triads instead of 2 color pairs.  We will also force orientation in certain ways so there are 12 colors and only base-4.  We are giving up 8 bases (2/3rds) in order to have robust error detection and correction.  This means that each color is only in a set of 3 and must maintain a certain orientation. These methods, like in [[#v2|Cv2]], are part of physical information theory (PIT) or [[physical error correction]] (PEC).  PEC uses physical properties of data to detect and/or correct and/or prevent errors.  Some of these properties, as also explained in [[#v2|Cv2]], can be location, orientation, partnering, tagging, contrast, etc.  [[Physical error correction]] is the methodology most used in nature and can be found in DNA, visual field, neurons (such as memory and recall); and other data storage, transmission, and processing.%0a
host:1611593387=104.175.54.158
author:1611592001=
diff:1611592001:1611591902:=266c266%0a%3c To get rid of the color filters in Cv2, we need to use 3 color triads instead of 2 color pairs.  We will also force orientation in certain ways so there are 12 colors and only base-4.  We are giving up 8 bases (2/3rds) in order to have robust error detection and correction.  This means that each color is only in a set of 3 and must maintain a certain orientation. These methods, like in [[#v2|Cv2]], are part of physical information theory (PIT) or [[physical error correction]] (PEC).  PEC uses physical properties of data to detect and/or correct and/or prevent errors.  Some of these properties, as also explained in [[#v2|Cv2]], can be location, orientation, partnering, tagging, contrast, etc.  [[Physical error correction]] is the methodology most used in nature and can be found in DNA, visual field, neurons (such as memory and recall); and other data storage, transmission, and processing.%0a---%0a> To get rid of the color filters in Cv2, we need to use 3 color triads instead of 2 color pairs.  We will also force orientation in certain ways so there are 12 colors and only base-4.  We are giving up 8 bases (2/3rds) in order to have robust error detection and correction.  This means that each color is only in a set of 3 and must maintain a certain orientation. These methods, like in [[#v2|Cv2]], are part of physical information theory (PIT) or [[physical error correction]] (PEC).  PEC uses physical properties of data to detect and/or correct errors.  Some of these properties, as also explained in [[#v2|Cv2]], can be orientation, partnering, tagging, etc.  [[Physical error correction]] is the methodology most used in nature and can be found in DNA, visual field, neurons (such as memory and recall); and other data storage, transmission, and processing.%0a
host:1611592001=104.175.54.158
author:1611591902=
diff:1611591902:1611591844:=266c266%0a%3c To get rid of the color filters in Cv2, we need to use 3 color triads instead of 2 color pairs.  We will also force orientation in certain ways so there are 12 colors and only base-4.  We are giving up 8 bases (2/3rds) in order to have robust error detection and correction.  This means that each color is only in a set of 3 and must maintain a certain orientation. These methods, like in [[#v2|Cv2]], are part of physical information theory (PIT) or [[physical error correction]] (PEC).  PEC uses physical properties of data to detect and/or correct errors.  Some of these properties, as also explained in [[#v2|Cv2]], can be orientation, partnering, tagging, etc.  [[Physical error correction]] is the methodology most used in nature and can be found in DNA, visual field, neurons (such as memory and recall); and other data storage, transmission, and processing.%0a---%0a> To get rid of the color filters in Cv2, we need to use 3 color triads instead of 2 color pairs.  We will also force orientation in certain ways so there are 12 colors and only base-4.  We are giving up 8 bases (2/3rds) in order to have robust error detection and correction.  This means that each color is only in a set of 3 and must maintain a certain orientation. These methods, like in [[#v2|Cv2]], are part of physical information theory (PIT) or [[physical error correction]] (PEC).  PEC uses physical properties of data to detect and/or correct errors.  Some of these properties, as also explained in [[#v2|Cv2]] can be orientation, partnering, tagging, etc.  [[Physical error correction]] is the methodology most used in nature and can be found in DNA, visual field, neurons (such as memory and recall); and other data storage, transmission, and processing.%0a
host:1611591902=104.175.54.158
author:1611591844=
diff:1611591844:1611591678:=266c266%0a%3c To get rid of the color filters in Cv2, we need to use 3 color triads instead of 2 color pairs.  We will also force orientation in certain ways so there are 12 colors and only base-4.  We are giving up 8 bases (2/3rds) in order to have robust error detection and correction.  This means that each color is only in a set of 3 and must maintain a certain orientation. These methods, like in [[#v2|Cv2]], are part of physical information theory (PIT) or [[physical error correction]] (PEC).  PEC uses physical properties of data to detect and/or correct errors.  Some of these properties, as also explained in [[#v2|Cv2]] can be orientation, partnering, tagging, etc.  [[Physical error correction]] is the methodology most used in nature and can be found in DNA, visual field, neurons (such as memory and recall); and other data storage, transmission, and processing.%0a---%0a> To get rid of the color filters in Cv2, we need to use 3 color triads instead of 2 color pairs.  We will also force orientation in certain ways so there are 12 colors and only base-4.  We are giving up 8 bases (2/3rds) in order to have robust error detection and correction.  This means that each color is only in a set of 3 and must maintain a certain orientation. These methods, like in [[#v2|Cv2]], are part of physical information theory (PIT) or physical error correction (PEC).  PEC uses physical properties of data to detect and/or correct errors.  Some of these properties, as also explained in [[#v2|Cv2]] can be orientation, partnering, tagging, etc.  Physical error correction is the methodology most used in nature.%0a
host:1611591844=104.175.54.158
author:1611591678=
diff:1611591678:1611591527:=266c266%0a%3c To get rid of the color filters in Cv2, we need to use 3 color triads instead of 2 color pairs.  We will also force orientation in certain ways so there are 12 colors and only base-4.  We are giving up 8 bases (2/3rds) in order to have robust error detection and correction.  This means that each color is only in a set of 3 and must maintain a certain orientation. These methods, like in [[#v2|Cv2]], are part of physical information theory (PIT) or physical error correction (PEC).  PEC uses physical properties of data to detect and/or correct errors.  Some of these properties, as also explained in [[#v2|Cv2]] can be orientation, partnering, tagging, etc.  Physical error correction is the methodology most used in nature.%0a---%0a> To get rid of the color filters in Cv2, we need to use 3 color triads instead of 2 color pairs.  We will also force orientation in certain ways so there are 12 colors and only base-4.  We are giving up 8 bases (2/3rds) in order to have robust error detection and correction.  This means that each color is only in a set of 3 and must maintain a certain orientation. These methods, like in [[#v2|Cv2]], are part of physical information theory (PIT) or physical error correction (PEC).%0a
host:1611591678=104.175.54.158
author:1611591527=
diff:1611591527:1611591257:=266c266%0a%3c To get rid of the color filters in Cv2, we need to use 3 color triads instead of 2 color pairs.  We will also force orientation in certain ways so there are 12 colors and only base-4.  We are giving up 8 bases (2/3rds) in order to have robust error detection and correction.  This means that each color is only in a set of 3 and must maintain a certain orientation. These methods, like in [[#v2|Cv2]], are part of physical information theory (PIT) or physical error correction (PEC).%0a---%0a> To get rid of the color filters in Cv2, we need to use 3 color triads instead of 2 color pairs.  We will also force orientation in certain ways so there are 12 colors and only base-4.  We are giving up 8 bases (2/3rds) in order to have robust error detection and correction.  This means that each color is only in a set of 3 and must maintain a certain orientation. These methods, like in [[#v2|Cv2]], are part of physical information theory (PIT).%0a
host:1611591527=104.175.54.158
author:1611591257=
diff:1611591257:1611590939:=266c266%0a%3c To get rid of the color filters in Cv2, we need to use 3 color triads instead of 2 color pairs.  We will also force orientation in certain ways so there are 12 colors and only base-4.  We are giving up 8 bases (2/3rds) in order to have robust error detection and correction.  This means that each color is only in a set of 3 and must maintain a certain orientation. These methods, like in [[#v2|Cv2]], are part of physical information theory (PIT).%0a---%0a> To get rid of the color filters in Cv2, we need to use 3 color triads instead of 2 color pairs.  We will also force orientation in certain ways so there are 12 colors and only base-4.  We are giving up 8 bases (2/3rds) in order to have robust error detection and correction.  This means that each color is only in a set of 3 and must maintain a certain orientation. %0a
host:1611591257=104.175.54.158
author:1611590939=
diff:1611590939:1611590180:=274c274%0a%3c When all 3 colors in a triad are unallowable, this is a 3-bit error.  Because of this we can detect some 3-bit errors.  The chance we would rightly detect a 3-bit error is (2/3)×(2/3)×(2/3)=29.6%25.  So we can detect roughly 1/3 of all 3-bit errors.  We cannot have a nonsense bit like this so we have to correct it, even though the chance of correcting it wrongly are extremely high.  To "correct" it and make it into a sensical bit (triad) we first look to see what colors the nonsensical triad contains.  If it contains all the colors of a sensical triad, just in the wrong locations, or if it contains the same color 3 times we choose to correct it to that triad.  If it contains 2 colors of a certain triad in the wrong locations, or if it contains 2 of the same color, we correct it to that triad.  If it contains 3 different colors all of different triads, at least that removes one possible triad.  To select which triad to correct it to out of these 3 we now hqve a simple solution, correct it to the triad that gives the middle value.  Since all 4 triads are numbered 0-3, and all 3 triads are different in this case, one will have a value between the other 2.  We choose this one since it will effect the checksum of the chromaton the least.%0a---%0a> When all 3 colors in a triad are unallowable, this is a 3-bit error.  Because of this we can detect many 3-bit errors.  The chance we would rightly detect a 3-bit error is (2/3)×(2/3)×(2/3)=29.6%25.  So we can detect roughly 1/3 of all 3-bit errors.  We cannot have a nonsense bit like this so we have to correct it, even though the chance of correcting it wrongly are extremely high.  To "correct" it and make it into a sensical bit (triad) we first look to see what colors the nonsensical triad contains.  If it contains all the colors of a sensical triad, just in the wrong locations, or if it contains the same color 3 times we choose to correct it to that triad.  If it contains 2 colors of a certain triad in the wrong locations, or if it contains 2 of the same color, we correct it to that triad.  If it contains 3 different colors all of different triads, at least that removes one possible triad.  To select which triad to correct it to out of these 3 we now hqve a simple solution, correct it to the triad that gives the middle value.  Since all 4 triads are numbered 0-3, and all 3 triads are different in this case, one will have a value between the other 2.  We choose this one since it will effect the checksum of the chromaton the least.%0a
host:1611590939=104.175.54.158
author:1611590180=
diff:1611590180:1611589674:=266,268c266%0a%3c To get rid of the color filters in Cv2, we need to use 3 color triads instead of 2 color pairs.  We will also force orientation in certain ways so there are 12 colors and only base-4.  We are giving up 8 bases (2/3rds) in order to have robust error detection and correction.  This means that each color is only in a set of 3 and must maintain a certain orientation. %0a%3c %0a%3c As will be shown below, this system gives us 100%25 detection and correction of 1-bit errors, 94%25 detection and correction of 2-bit errors, and 30%25 detection of 3-bit errors.  These numbers increase astronomically when kilochromaton or higher are employed.  In kilochromaton most errors up to 48 bits will be corrected!%0a---%0a> To get rid of the color filters in Cv2, we need to use 3 color triads instead of 2 color pairs.  We will also force orientation in certain ways so there are 12 colors and only base-4.  We are giving up 8 bases (2/3rds) in order to have robust error detection and correction.  This means that each color is only in a set of 3 and must maintain a certain orientation.  %0a
host:1611590180=104.175.54.158
author:1611589674=
diff:1611589674:1611589582:=270c270%0a%3c For that 94.4%25 of 2-bit errors we were able to detect, we can also correct them all!  Just as long as one bit was in an allowable spot and the other 2 were not, then we correct the ones that were not, with the other colors in the triad of the one color that was allowable.  We still record this as a 2-bit error though, because the chance we corrected it wrongly is quite high, since as seen below, the chance that a 3-bit error goes undetected is over 70%25.  Most of these undetected 3-bit errors will look like 2-bit errors.%0a---%0a> For that 94.4%25 of 2-bit errors we were able to detect, we can also correct them all!  Just as long as one bit was in an allowable spot and the other 2 were not, then we correct the ones that were not, with the other colors in the triad of the one color that was allowable.  We still record this as a 2-bit error though, because the chance we corrected it wrongly is quite high, since as seen below, the chance a 3-bit error is undetected is over 70%25.%0a
host:1611589674=104.175.54.158
author:1611589582=
diff:1611589582:1611589433:=270c270%0a%3c For that 94.4%25 of 2-bit errors we were able to detect, we can also correct them all!  Just as long as one bit was in an allowable spot and the other 2 were not, then we correct the ones that were not, with the other colors in the triad of the one color that was allowable.  We still record this as a 2-bit error though, because the chance we corrected it wrongly is quite high, since as seen below, the chance a 3-bit error is undetected is over 70%25.%0a---%0a> For that 94.4%25 of 2-bit errors we were able to detect, we can also correct them all!  Just as long as one bit was in an allowable spot and the other 2 were not, then we correct the ones that were not, with the other colors in the triad of the one color that was allowable.  We still record this as a 2-bit error though, because the chance we corrected it wrongly is quite high.%0a
host:1611589582=104.175.54.158
author:1611589433=
diff:1611589433:1611589197:=270c270%0a%3c For that 94.4%25 of 2-bit errors we were able to detect, we can also correct them all!  Just as long as one bit was in an allowable spot and the other 2 were not, then we correct the ones that were not, with the other colors in the triad of the one color that was allowable.  We still record this as a 2-bit error though, because the chance we corrected it wrongly is quite high.%0a---%0a> For that 94.4%25 of 2-bit errors we were able to detect, we can also correct them all!  Just as long as one bit was in an allowable spot and the other 2 were not, then we correct the ones that were not, with the other colors in the triad of the one that was allowable.%0a
host:1611589433=104.175.54.158
author:1611589197=
diff:1611589197:1611587399:=268,274c268,270%0a%3c This means we will be able to correct every 1-bit error and only falsely correct (1/3)*(1/12+1/12) = 1/18 = 5.6%25 of 2-bit errors without detection because we diagnosed them as 1-bit errors wrongly.  This is because the chance that an error color is in an allowable spot is 1/3 and the chance a color in that error color's triad is also an error color in the triad in an allowable spot is 1/12 for each spot so 2/12 total.%0a%3c %0a%3c For that 94.4%25 of 2-bit errors we were able to detect, we can also correct them all!  Just as long as one bit was in an allowable spot and the other 2 were not, then we correct the ones that were not, with the other colors in the triad of the one that was allowable.%0a%3c %0a%3c When all 3 colors in a triad are unallowable, this is a 3-bit error.  Because of this we can detect many 3-bit errors.  The chance we would rightly detect a 3-bit error is (2/3)×(2/3)×(2/3)=29.6%25.  So we can detect roughly 1/3 of all 3-bit errors.  We cannot have a nonsense bit like this so we have to correct it, even though the chance of correcting it wrongly are extremely high.  To "correct" it and make it into a sensical bit (triad) we first look to see what colors the nonsensical triad contains.  If it contains all the colors of a sensical triad, just in the wrong locations, or if it contains the same color 3 times we choose to correct it to that triad.  If it contains 2 colors of a certain triad in the wrong locations, or if it contains 2 of the same color, we correct it to that triad.  If it contains 3 different colors all of different triads, at least that removes one possible triad.  To select which triad to correct it to out of these 3 we now hqve a simple solution, correct it to the triad that gives the middle value.  Since all 4 triads are numbered 0-3, and all 3 triads are different in this case, one will have a value between the other 2.  We choose this one since it will effect the checksum of the chromaton the least.%0a%3c %0a%3c We have a 94.4%25 2-bit error detection rate and 100%25 1-bit error correction rate.  This is excellent, 3 bits compared to 2 bits of Cv2, Cv2 only had 50%25 2-bit error detection (without filters) wheras with Cv3 and 3 bits, we get 94.4%25 2-bit error detection.  This is more than enough especially when using kilochromaton and higher as it will correct even more errors.  Even though the 3-bit error is now "corrected" (probably wrongly) the good news is we detected the error so that will help us sort this out in kilochromaton error correction.%0a---%0a> This means we will be able to correct every 1-bit error and only falsely correct (1/3)*(1/12+1/12) = 1/18 = 5.6%25 of 2-bit errors without detection because we diagnosed them as 1-bit errors wrongly.  This is because the chance that an error color is in an allowable spot is 1/3 and the chance a color in that error color's triad is also an error color in the triad in the right spot is 1/12 for each spot so 2/12 total.%0a> %0a> This means we have a 94.4%25 2-bit error detection rate and 100%25 1-bit error correction rate.  This is excellent, 3 bits compared to 2 bits of Cv2, Cv2 only had 50%25 2-bit error detection (without filters) wheras with Cv3 and 3 bits, we get 94.4%25 2-bit error detection.  This is more than enough especially when using kilochromaton and higher as it will correct even more errors.%0a
host:1611589197=104.175.54.158
author:1611587399=
diff:1611587399:1611587171:=289c289%0a%3c If all 3 of the checksums are different, what do we do?  Firstly I want to say that all 3 bieng different will be extremely rare since we already have perfect 1-bit error correction and roughly 95%25 2-bit error detection at the base level. But when it does rarely happen we can do something else so we don't loose all the data in the base chromaton just because of a couple errors.  What we will do is take the 2 chromaton with the fewest detected errors (if there is a tie, favor chromaton with fewest errors and most similar checksums, if still a tie favor chromaton with the fewest errors and most different checksums, if still a tie forget about errors and choose the two with the most different checksums) and then compare those two at the base chromaton level.  Anything that is different between the 2, we check to see if there were any errors detected previously in those spots.  If in one of the chromaton one triad was detected as an error and the other chromaton does not have an error detected in that triad, then the error triad is replaced with the non-error triad.  After all of this what we will be left with is 2 chromaton that are either now identical or only vary in one of two ways.  The first way they can vary is if both have different errors in the same triad.  The second way is they both have different values in the same triad and neither was detected as an error.  In both of these cases the data from the third chromaton is used to fix these.  Even if the third chromaton is wrong or has a detected error in the spot in question, we need a tie breaker, so the data in the third chromaton is used to settle any remaining disputes between the two chromaton bieng compared.  Now the 2 chromaton that were bieng compared are identical and are considered the correct version.%0a---%0a> If all 3 of the checksums were different, what do we do?  Firstly I want to say that all 3 bieng different will be extremely rare since we already have perfect 1-bit error correction and roughly 95%25 2-bit error detection at the base level. But when it does rarely happen we can do something else so we don't loose all the data in the base chromaton just because of a couple errors.  What we will do is take the 2 chromaton with the fewest detected errors (if there is a tie, favor chromaton with fewest errors and most similar checksums, if still a tie favor chromaton with the fewest errors and most different checksums, if still a tie forget about errors and choose the two with the most different checksums) and then compare those two at the base chromaton level.  Anything that is different between the 2, we check to see if there were any errors detected previously in those spots.  If in one of the chromaton one triad was detected as an error and the other chromaton does not have an error detected in that triad, then the error triad is replaced with the non-error triad.  After all of this what we will be left with is 2 chromaton that are either now identical or only vary in one of two ways.  The first way they can vary is if both have different errors in the same triad.  The second way is they both have different values in the same triad and neither was detected as an error.  In both of these cases the data from the third chromaton is used to fix these.  Even if the third chromaton is wrong or has a detected error in the spot in question, we need a tie breaker, so the data in the third chromaton is used to settle any remaining disputes between the two chromaton bieng compared.  Now the 2 chromaton that were bieng compared are identical and are considered the correct version.%0a
host:1611587399=104.175.54.158
author:1611587171=
diff:1611587171:1611587139:=287c287%0a%3c This gives us another check of the lower chromaton we are reading.  At this level we use "checksum" of the lower level.  So first we decode and error correct all base level chromaton.  Then we sum up all the numbers in each chromaton and this is the checksum, one for each chromaton.  In kilochromaton level we compare the three checksums for each replicate chromaton.  If all 3 are the same then we verified that everything is perfect (we have 16 base-4 numbers so the chance that we randomly got the checksums to equal yet actually be wrong is 1/64 × 1/64 × 1/64 = 3.8×10^(-6) or 4 times in 1 million).  But for 2 of them to randomly give the same checksum wrongly is 1/64 × (1/64+1/64) = 0.049%25 or 488 times in a million.  So since we will accept if 2 of them add to the same checksum, we will have a 99.95%25 correct - error correction rate.  This not only corrects 1-bit errors at this level, this corrects up to 48-bit errors!  An entire base chromaton could be wrong and it could be fixed at this level.%0a---%0a> This gives us another check of the lower chromaton we are reading.  At this level we use "checksum" of the lower level.  So first we decode and error correct all base level chromaton.  Then we sum up all the numbers in each chromaton and this is the checksum, one for each chromaton.  In kilochromaton level we compare the three checksums for each replicate chromaton.  If all 3 are the same then we verified that everything is perfect (we have 16 base-4 numbers so the chance that we randomly got the checksums to equal yet actually be wrong is 1/64 × 1/64 × 1/64 = 3.8×10^(-6) or 4 times in 1 million).  But for 2 of them to randomly give the same checksum wrongly is 1/64 × (1/64+1/64) = 0.049%25 or 488 times in a million.  So since we will accept if 2 of them add to the same checksum, we will have a 99.95%25 correct - error correction rate.  This not only corrects 1 bit errors at this level, this corrects up to 48 bit errors!  An entire base chromaton could be wrong and it could be fixed at this level.%0a
host:1611587171=104.175.54.158
author:1611587139=
diff:1611587139:1611586360:=287c287%0a%3c This gives us another check of the lower chromaton we are reading.  At this level we use "checksum" of the lower level.  So first we decode and error correct all base level chromaton.  Then we sum up all the numbers in each chromaton and this is the checksum, one for each chromaton.  In kilochromaton level we compare the three checksums for each replicate chromaton.  If all 3 are the same then we verified that everything is perfect (we have 16 base-4 numbers so the chance that we randomly got the checksums to equal yet actually be wrong is 1/64 × 1/64 × 1/64 = 3.8×10^(-6) or 4 times in 1 million).  But for 2 of them to randomly give the same checksum wrongly is 1/64 × (1/64+1/64) = 0.049%25 or 488 times in a million.  So since we will accept if 2 of them add to the same checksum, we will have a 99.95%25 correct - error correction rate.  This not only corrects 1 bit errors at this level, this corrects up to 48 bit errors!  An entire base chromaton could be wrong and it could be fixed at this level.%0a---%0a> This gives us another check of the lower chromaton we are reading.  At this level we use "checksum" of the lower level.  So first we decode and error correct all base level chromaton.  Then we sum up all the numbers in each chromaton and this is the checksum, one for each chromaton.  In kilochromaton level we compare the three checksums for each replicate chromaton.  If all 3 are the same then we verified that everything is perfect (we have 16 base-4 numbers so the chance that we randomly got the checksums to equal yet actually be wrong is 1/64 × 1/64 × 1/64 = 3.8×10^(-6) or 4 times in 1 million).  But for 2 of them to randomly give the same checksum wrongly is 1/64 × (1/64+1/64) = 0.049%25 or 488 times in a million.  So since we will accept if 2 of them add to the same checksum, we will have a 99.95%25 correct - error correction rate.  This not only corrects 1 bit errors at this level, this corrects up to 16 bit errors!  An entire base chromaton could be wrong and it could be fixed at this level.%0a
host:1611587139=104.175.54.158
author:1611586360=
diff:1611586360:1611586135:=289c289%0a%3c If all 3 of the checksums were different, what do we do?  Firstly I want to say that all 3 bieng different will be extremely rare since we already have perfect 1-bit error correction and roughly 95%25 2-bit error detection at the base level. But when it does rarely happen we can do something else so we don't loose all the data in the base chromaton just because of a couple errors.  What we will do is take the 2 chromaton with the fewest detected errors (if there is a tie, favor chromaton with fewest errors and most similar checksums, if still a tie favor chromaton with the fewest errors and most different checksums, if still a tie forget about errors and choose the two with the most different checksums) and then compare those two at the base chromaton level.  Anything that is different between the 2, we check to see if there were any errors detected previously in those spots.  If in one of the chromaton one triad was detected as an error and the other chromaton does not have an error detected in that triad, then the error triad is replaced with the non-error triad.  After all of this what we will be left with is 2 chromaton that are either now identical or only vary in one of two ways.  The first way they can vary is if both have different errors in the same triad.  The second way is they both have different values in the same triad and neither was detected as an error.  In both of these cases the data from the third chromaton is used to fix these.  Even if the third chromaton is wrong or has a detected error in the spot in question, we need a tie breaker, so the data in the third chromaton is used to settle any remaining disputes between the two chromaton bieng compared.  Now the 2 chromaton that were bieng compared are identical and are considered the correct version.%0a---%0a> If all 3 of the checksums were different, what do we do?  Firstly I want to say that all 3 bieng different will be extremely rare since we already have perfect 1-bit error correction and roughly 95%25 2-bit error detection at the base level. But when it does rarely happen we can do something else so we don't loose all the data in the base chromaton just because of a couple errors.  What we will do is take the 2 chromaton with the fewest detected errors (if there is a tie, favor chromaton with fewest errors and most similar checksums, if still a tie favor chromaton with the fewest errors and most different checksums) and then compare those two at the base chromaton level.  Anything that is different between the 2, we check to see if there were any errors detected previously in those spots.  If in one of the chromaton one triad was detected as an error and the other chromaton does not have an error detected in that triad, then the error triad is replaced with the non-error triad.  After all of this what we will be left with is 2 chromaton that are either now identical or only vary in one of two ways.  The first way they can vary is if both have different errors in the same triad.  The second way is they both have different values in the same triad and neither was detected as an error.  In both of these cases the data from the third chromaton is used to fix these.  Even if the third chromaton is wrong or has a detected error in the spot in question, we need a tie breaker, so the data in the third chromaton is used to settle any remaining disputes between the two chromaton bieng compared.  Now the 2 chromaton that were bieng compared are identical and are considered the correct version.%0a
host:1611586360=104.175.54.158
author:1611586135=
diff:1611586135:1611585956:=289c289%0a%3c If all 3 of the checksums were different, what do we do?  Firstly I want to say that all 3 bieng different will be extremely rare since we already have perfect 1-bit error correction and roughly 95%25 2-bit error detection at the base level. But when it does rarely happen we can do something else so we don't loose all the data in the base chromaton just because of a couple errors.  What we will do is take the 2 chromaton with the fewest detected errors (if there is a tie, favor chromaton with fewest errors and most similar checksums, if still a tie favor chromaton with the fewest errors and most different checksums) and then compare those two at the base chromaton level.  Anything that is different between the 2, we check to see if there were any errors detected previously in those spots.  If in one of the chromaton one triad was detected as an error and the other chromaton does not have an error detected in that triad, then the error triad is replaced with the non-error triad.  After all of this what we will be left with is 2 chromaton that are either now identical or only vary in one of two ways.  The first way they can vary is if both have different errors in the same triad.  The second way is they both have different values in the same triad and neither was detected as an error.  In both of these cases the data from the third chromaton is used to fix these.  Even if the third chromaton is wrong or has a detected error in the spot in question, we need a tie breaker, so the data in the third chromaton is used to settle any remaining disputes between the two chromaton bieng compared.  Now the 2 chromaton that were bieng compared are identical and are considered the correct version.%0a---%0a> If all 3 of the checksums were different, what do we do?  Firstly I want to say that all 3 bieng different will be extremely rare since we already have perfect 1-bit error correction and roughly 95%25 2-bit error detection at the base level. But when it does rarely happen we can do something else so we don't loose all the data in the base chromaton just because of a couple errors.  What we will do is take the 2 chromaton with the fewest detected errors (if there is a tie, favor chromaton with fewest errors and most similar checksums, if still a tie favor chromaton with the fewest errors and most different checksums) and then compare those two at the base chromaton level.  Anything that is different between the 2, we check to see if there were any errors detected previously in those spots.  If in one of the chromaton one triad was detected as an error and the other chromaton does not have an error detected in that triad, then the error triad is replaced with the non-error triad.  After all of this what we will be left with is 2 chromaton that are either now identical or only vary in one of two ways.  The first way they can vary is if both have different errors in the same triad.  The second way is they both have different values in the same triad and neither was detected as an error.  In both of these cases the data from the third chromaton is used to fix these.  Even if the third chromaton is wrong or has a detected error in the spot in question, we need a tie breaker.  Now the 2 chromaton that were bieng compared are identical and are considered the correct version.%0a
host:1611586135=104.175.54.158
author:1611585956=
diff:1611585956:1611585835:=289c289%0a%3c If all 3 of the checksums were different, what do we do?  Firstly I want to say that all 3 bieng different will be extremely rare since we already have perfect 1-bit error correction and roughly 95%25 2-bit error detection at the base level. But when it does rarely happen we can do something else so we don't loose all the data in the base chromaton just because of a couple errors.  What we will do is take the 2 chromaton with the fewest detected errors (if there is a tie, favor chromaton with fewest errors and most similar checksums, if still a tie favor chromaton with the fewest errors and most different checksums) and then compare those two at the base chromaton level.  Anything that is different between the 2, we check to see if there were any errors detected previously in those spots.  If in one of the chromaton one triad was detected as an error and the other chromaton does not have an error detected in that triad, then the error triad is replaced with the non-error triad.  After all of this what we will be left with is 2 chromaton that are either now identical or only vary in one of two ways.  The first way they can vary is if both have different errors in the same triad.  The second way is they both have different values in the same triad and neither was detected as an error.  In both of these cases the data from the third chromaton is used to fix these.  Even if the third chromaton is wrong or has a detected error in the spot in question, we need a tie breaker.  Now the 2 chromaton that were bieng compared are identical and are considered the correct version.%0a---%0a> If all 3 of the checksums were different, what do we do?  Firstly I want to say that all 3 bieng different will be extremely rare since we already have perfect 1-bit error correction and roughly 95%25 2-bit error detection at the base level. But when it does rarely happen we can do something else so we don't loose all the data in the base chromaton just because of a couple errors.  What we will do is take the 2 chromaton with the fewest detected errors (if there is a tie, favor chromaton with fewest errors and most similar checksums, if still a tie favor chromaton with the fewest errors and most different checksums) and then compare those two at the base chromaton level.  Anything that is different between the 2 we see if there were any errors detected previously.  If in one of the chromaton one triad was detected as an error and the other chromaton does not have an error detected in that triad, then the error triad is replaced with the non-error triad.  After all of this what we will be left with is 2 chromaton that are either now identical or only vary in one of two ways.  The first way they can vary is if both have different errors in the same triad.  The second way is they both have different values in the same triad and neither was detected as an error.  In both of these cases the data from the third chromaton is used to fix these.  Even if the third chromaton is wrong or has a detected error in the spot in question, we need a tie breaker.  Now the 2 chromaton that were bieng compared are identical and are considered the correct version.%0a
host:1611585956=104.175.54.158
author:1611585835=
diff:1611585835:1611585731:=289c289%0a%3c If all 3 of the checksums were different, what do we do?  Firstly I want to say that all 3 bieng different will be extremely rare since we already have perfect 1-bit error correction and roughly 95%25 2-bit error detection at the base level. But when it does rarely happen we can do something else so we don't loose all the data in the base chromaton just because of a couple errors.  What we will do is take the 2 chromaton with the fewest detected errors (if there is a tie, favor chromaton with fewest errors and most similar checksums, if still a tie favor chromaton with the fewest errors and most different checksums) and then compare those two at the base chromaton level.  Anything that is different between the 2 we see if there were any errors detected previously.  If in one of the chromaton one triad was detected as an error and the other chromaton does not have an error detected in that triad, then the error triad is replaced with the non-error triad.  After all of this what we will be left with is 2 chromaton that are either now identical or only vary in one of two ways.  The first way they can vary is if both have different errors in the same triad.  The second way is they both have different values in the same triad and neither was detected as an error.  In both of these cases the data from the third chromaton is used to fix these.  Even if the third chromaton is wrong or has a detected error in the spot in question, we need a tie breaker.  Now the 2 chromaton that were bieng compared are identical and are considered the correct version.%0a---%0a> If all 3 of the checksums were different, what do we do?  Firstly I want to say that all 3 bieng different will be extremely rare since we already have perfect 1-bit error correction and roughly 95%25 2-bit error detection at the base level. But when it does rarely happen we can do something else so we don't loose all the data in the base chromaton just because of a couple errors.  What we will do is take the 2 chromaton with the fewest detected errors (if there is a tie, favor chromaton with fewest errors and most similar checksums, if still a tie favor chromaton with the fewest errors and most different checksums) and then compare those at the base chromaton level.  Anything that is different between the 2 we see if there were any errors detected previously.  If in one of the chromaton one triad was detected as an error and the other chromaton does not have an error detected in that triad, then the error triad is replaced with the non-error triad.  After all of this what we will be left with is 2 chromaton that are either now identical or only vary in one of two ways.  The first way they can vary is if both have different errors in the same triad.  The second way is they both have different values in the same triad and neither was detected as an error.  In both of these cases the data from the third chromaton is used to fix these.  Even if the third chromaton is wrong or has a detected error in the spot in question, we need a tie breaker.  Now the 2 chromaton that were bieng compared are identical and are considered the correct version.%0a
host:1611585835=104.175.54.158
author:1611585731=
diff:1611585731:1611584812:=289c289%0a%3c If all 3 of the checksums were different, what do we do?  Firstly I want to say that all 3 bieng different will be extremely rare since we already have perfect 1-bit error correction and roughly 95%25 2-bit error detection at the base level. But when it does rarely happen we can do something else so we don't loose all the data in the base chromaton just because of a couple errors.  What we will do is take the 2 chromaton with the fewest detected errors (if there is a tie, favor chromaton with fewest errors and most similar checksums, if still a tie favor chromaton with the fewest errors and most different checksums) and then compare those at the base chromaton level.  Anything that is different between the 2 we see if there were any errors detected previously.  If in one of the chromaton one triad was detected as an error and the other chromaton does not have an error detected in that triad, then the error triad is replaced with the non-error triad.  After all of this what we will be left with is 2 chromaton that are either now identical or only vary in one of two ways.  The first way they can vary is if both have different errors in the same triad.  The second way is they both have different values in the same triad and neither was detected as an error.  In both of these cases the data from the third chromaton is used to fix these.  Even if the third chromaton is wrong or has a detected error in the spot in question, we need a tie breaker.  Now the 2 chromaton that were bieng compared are identical and are considered the correct version.%0a---%0a> If all 3 of the checksums were different, what do we do?  Firstly I want to say that all 3 bieng different will be extremely rare since we already have perfect 1-bit error correction and roughly 95%25 2-bit error detection at the base level. But when it does rarely happen we can do something else so we don't loose all the data in the base chromaton just because of a couple errors.  What we will do is take the 2 chromaton with the fewest detected errors (if there is a tie, favor chromaton with fewest errors and most similar checksums, if still a tie forget about the errors and pick the two with highest and lowest checksums) and then compare those at the base chromaton level.  Anything that is different between the 2 we see if there were any errors detected previously.  If in one of the chromaton one triad was detected as an error and the other chromaton does not have an error detected in that triad, then the error triad is replaced with the non-error triad.  After all of this what we will be left with is 2 chromaton that are either now identical or only vary in one of two ways.  The first way they can vary is if both have different errors in the same triad.  The second way is they both have different values in the same triad and neither was detected as an error.  In both of these cases the data from the third chromaton is used to fix these.  Even if the third chromaton is wrong or has a detected error in the spot in question, we need a tie breaker.  Now the 2 chromaton that were bieng compared are identical and are considered the correct version.%0a
host:1611585731=104.175.54.158
author:1611584812=
diff:1611584812:1611584554:=251c251%0a%3c In version 3 we want to accomplish 2 things.  Firstly we want to get rid of color filters altogether so Chromaton becomes a more versatile protocol.  Secondly we need to resist burst errors so redundant data needs to be placed far apart from eachother.%0a---%0a> In version 3 we want to accomplish 2 things.  Firstly we want to get rid of color filters altogether so Chromaton becomes a more flexible protocol.  Secondly we need to resist burst errors so redundant data needs to be placed far apart from eachother.%0a
host:1611584812=104.175.54.158
author:1611584554=
diff:1611584554:1611559549:=9c9%0a%3c (:Also:[[Digital collectible network]], [[Chromaton disc]], [[3D chromaton disc]]:)%0a---%0a> (:Also:[[Digital collectible network]], [[Chromaton disc]]:)%0a
host:1611584554=104.175.54.158
author:1611559549=
diff:1611559549:1611558998:=289c289%0a%3c If all 3 of the checksums were different, what do we do?  Firstly I want to say that all 3 bieng different will be extremely rare since we already have perfect 1-bit error correction and roughly 95%25 2-bit error detection at the base level. But when it does rarely happen we can do something else so we don't loose all the data in the base chromaton just because of a couple errors.  What we will do is take the 2 chromaton with the fewest detected errors (if there is a tie, favor chromaton with fewest errors and most similar checksums, if still a tie forget about the errors and pick the two with highest and lowest checksums) and then compare those at the base chromaton level.  Anything that is different between the 2 we see if there were any errors detected previously.  If in one of the chromaton one triad was detected as an error and the other chromaton does not have an error detected in that triad, then the error triad is replaced with the non-error triad.  After all of this what we will be left with is 2 chromaton that are either now identical or only vary in one of two ways.  The first way they can vary is if both have different errors in the same triad.  The second way is they both have different values in the same triad and neither was detected as an error.  In both of these cases the data from the third chromaton is used to fix these.  Even if the third chromaton is wrong or has a detected error in the spot in question, we need a tie breaker.  Now the 2 chromaton that were bieng compared are identical and are considered the correct version.%0a---%0a> If all 3 of the checksums were different, what do we do?  Firstly I want to say that all 3 bieng different will be extremely rare since we already have perfect 1-bit error correction and roughly 95%25 2-bit error detection at the base level. But when it does rarely happen we can do something else so we don't loose all the data in the base chromaton just because of a couple errors.  What we will do is take the 2 chromaton with the fewest detected errors (if there is a tie, favor chromaton that have fewest errors and most similar checksum, if still a tie forget about the errors and favor 2 with most similar checksum, if still a tie pick the 2 with the highest checksum) and then compare those at the base chromaton level.  Anything that is different between the 2 we see if there were any errors detected previously.  If in one of the chromaton one triad was detected as an error and the other chromaton does not have an error detected in that triad, then the error triad is replaced with the non-error triad.  After all of this what we will be left with is 2 chromaton that are either now identical or only vary in one of two ways.  The first way they can vary is if both have different errors in the same triad.  The second way is they both have different values in the same triad and neither was detected as an error.  In both of these cases the data from the third chromaton is used to fix these.  Even if the third chromaton is wrong or has a detected error in the spot in question, we need a tie breaker.  Now the 2 chromaton that were bieng compared are identical and are considered the correct version.%0a
host:1611559549=104.175.54.158
author:1611558998=
diff:1611558998:1611558778:=289c289%0a%3c If all 3 of the checksums were different, what do we do?  Firstly I want to say that all 3 bieng different will be extremely rare since we already have perfect 1-bit error correction and roughly 95%25 2-bit error detection at the base level. But when it does rarely happen we can do something else so we don't loose all the data in the base chromaton just because of a couple errors.  What we will do is take the 2 chromaton with the fewest detected errors (if there is a tie, favor chromaton that have fewest errors and most similar checksum, if still a tie forget about the errors and favor 2 with most similar checksum, if still a tie pick the 2 with the highest checksum) and then compare those at the base chromaton level.  Anything that is different between the 2 we see if there were any errors detected previously.  If in one of the chromaton one triad was detected as an error and the other chromaton does not have an error detected in that triad, then the error triad is replaced with the non-error triad.  After all of this what we will be left with is 2 chromaton that are either now identical or only vary in one of two ways.  The first way they can vary is if both have different errors in the same triad.  The second way is they both have different values in the same triad and neither was detected as an error.  In both of these cases the data from the third chromaton is used to fix these.  Even if the third chromaton is wrong or has a detected error in the spot in question, we need a tie breaker.  Now the 2 chromaton that were bieng compared are identical and are considered the correct version.%0a---%0a> If all 3 of the checksums were different, what do we do?  Firstly I want to say that all 3 bieng different will be extremely rare since we already have perfect 1-bit error correction and roughly 95%25 2-bit error detection at the base level. But when it does rarely happen we can do something else so we don't loose all the data in the base chromaton just because of a couple errors.  What we will do is take the 2 chromaton with the fewest detected errors (if there is a tie, favor chromaton that have most similar checksum) and then compare those at the base chromaton level.  Anything that is different between the 2 we see if there were any errors detected previously.  If in one of the chromaton one triad was detected as an error and the other chromaton does not have an error detected in that triad, then the error triad is replaced with the non-error triad.  After all of this what we will be left with is 2 chromaton that are either now identical or only vary in one of two ways.  The first way they can vary is if both have different errors in the same triad.  The second way is they both have different values in the same triad and neither was detected as an error.  In both of these cases the data from the third chromaton is used to fix these.  Even if the third chromaton is wrong or has a detected error in the spot in question, we need a tie breaker.  Now the 2 chromaton that were bieng compared are identical and are considered the correct version.%0a
host:1611558998=104.175.54.158
author:1611558778=
diff:1611558778:1611558510:=
host:1611558778=104.175.54.158
author:1611558510=
diff:1611558510:1611558212:=289c289%0a%3c If all 3 of the checksums were different, what do we do?  Firstly I want to say that all 3 bieng different will be extremely rare since we already have perfect 1-bit error correction and roughly 95%25 2-bit error detection at the base level. But when it does rarely happen we can do something else so we don't loose all the data in the base chromaton just because of a couple errors.  What we will do is take the 2 chromaton with the fewest detected errors (if there is a tie, favor chromaton that have most similar checksum) and then compare those at the base chromaton level.  Anything that is different between the 2 we see if there were any errors detected previously.  If in one of the chromaton one triad was detected as an error and the other chromaton does not have an error detected in that triad, then the error triad is replaced with the non-error triad.  After all of this what we will be left with is 2 chromaton that are either now identical or only vary in one of two ways.  The first way they can vary is if both have different errors in the same triad.  The second way is they both have different values in the same triad and neither was detected as an error.  In both of these cases the data from the third chromaton is used to fix these.  Even if the third chromaton is wrong or has a detected error in the spot in question, we need a tie breaker.  Now the 2 chromaton that were bieng compared are identical and are considered the correct version.%0a---%0a> If all 3 of the checksums were different, what do we do?  Firstly I want to say that all 3 bieng different will be extremely rare since we already have perfect 1-bit error correction and roughly 95%25 2-bit error detection at the base level. But when it does rarely happen we can do something else so we don't loose all the data in the base chromaton just because of a couple errors.  What we will do is take the 2 chromaton with the fewest detected errors (if there is a tie, favor chromaton that have most similar checksum) and then compare those at the base chromaton level.  Anything that is different between the 2 we see if there were any errors detected previously.  If in one of the chromaton one triad was detected as an error and the other chromaton does not have an error detected in that triad, then the error triad is replaced with the non-error triad.  After all of this what we will be left with is 2 chromaton that are either now identical or only vary in one of two ways.  The first way they can vary is if both have different errors in the same triad.  The second way is they both have different values in the same triad and neither was detected as an error.  In both of these cases the data from the third chromaton is used to fix these.  Even if the third chromaton is wrong or has a detected error in the spot in question, we need a tie breaker. This way we can maintain the majority of the data while still attaining a best possible consensus.%0a
host:1611558510=104.175.54.158
author:1611558212=
diff:1611558212:1611558172:=289c289%0a%3c If all 3 of the checksums were different, what do we do?  Firstly I want to say that all 3 bieng different will be extremely rare since we already have perfect 1-bit error correction and roughly 95%25 2-bit error detection at the base level. But when it does rarely happen we can do something else so we don't loose all the data in the base chromaton just because of a couple errors.  What we will do is take the 2 chromaton with the fewest detected errors (if there is a tie, favor chromaton that have most similar checksum) and then compare those at the base chromaton level.  Anything that is different between the 2 we see if there were any errors detected previously.  If in one of the chromaton one triad was detected as an error and the other chromaton does not have an error detected in that triad, then the error triad is replaced with the non-error triad.  After all of this what we will be left with is 2 chromaton that are either now identical or only vary in one of two ways.  The first way they can vary is if both have different errors in the same triad.  The second way is they both have different values in the same triad and neither was detected as an error.  In both of these cases the data from the third chromaton is used to fix these.  Even if the third chromaton is wrong or has a detected error in the spot in question, we need a tie breaker. This way we can maintain the majority of the data while still attaining a best possible consensus.%0a---%0a> Typically if all 3 of the checksums were different, what do we do?  Firstly I want to say that all 3 bieng different will be extremely rare since we already have perfect 1-bit error correction and roughly 95%25 2-bit error detection at the base level. But when it does rarely happen we can do something else so we don't loose all the data in the base chromaton just because of a couple errors.  What we will do is take the 2 chromaton with the fewest detected errors (if there is a tie, favor chromaton that have most similar checksum) and then compare those at the base chromaton level.  Anything that is different between the 2 we see if there were any errors detected previously.  If in one of the chromaton one triad was detected as an error and the other chromaton does not have an error detected in that triad, then the error triad is replaced with the non-error triad.  After all of this what we will be left with is 2 chromaton that are either now identical or only vary in one of two ways.  The first way they can vary is if both have different errors in the same triad.  The second way is they both have different values in the same triad and neither was detected as an error.  In both of these cases the data from the third chromaton is used to fix these.  Even if the third chromaton is wrong or has a detected error in the spot in question, we need a tie breaker. This way we can maintain the majority of the data while still attaining a best possible consensus.%0a
host:1611558212=104.175.54.158
author:1611558172=
diff:1611558172:1611557984:=289c289%0a%3c Typically if all 3 of the checksums were different, what do we do?  Firstly I want to say that all 3 bieng different will be extremely rare since we already have perfect 1-bit error correction and roughly 95%25 2-bit error detection at the base level. But when it does rarely happen we can do something else so we don't loose all the data in the base chromaton just because of a couple errors.  What we will do is take the 2 chromaton with the fewest detected errors (if there is a tie, favor chromaton that have most similar checksum) and then compare those at the base chromaton level.  Anything that is different between the 2 we see if there were any errors detected previously.  If in one of the chromaton one triad was detected as an error and the other chromaton does not have an error detected in that triad, then the error triad is replaced with the non-error triad.  After all of this what we will be left with is 2 chromaton that are either now identical or only vary in one of two ways.  The first way they can vary is if both have different errors in the same triad.  The second way is they both have different values in the same triad and neither was detected as an error.  In both of these cases the data from the third chromaton is used to fix these.  Even if the third chromaton is wrong or has a detected error in the spot in question, we need a tie breaker. This way we can maintain the majority of the data while still attaining a best possible consensus.%0a---%0a> Typically if all 3 of the checksums were different, what do we do?  Firstly I want to say that all 3 bieng different will be extremely rare since we already have perfect 1-bit error correction and roughly 95%25 2-bit error detection at the base level. But when it does rarely happen we can do something else so we don't loose all the data in the base chromaton just because of a couple errors.  What we will do is take the 2 chromaton with the fewest detected errors (if there is a tie, favor chromaton that have most similar checksum) and then compare those at the base chromaton level.  Anything that is different between the 2 we see if there were any errors detected previously.  If one triad was detected as an error and the other chromaton does not have an error detected in that triad, then the error triad is replaced with the non-error triad.  After all of this what we will be left with is 2 chromaton that are either now identical or only vary in one of two ways.  The first way they can vary is if both have different errors in the same triad.  The second way is they both have different values in the same triad and neither was detected as an error.  In both of these cases the data from the third chromaton is used to fix these.  Even if the third chromaton is wrong or has a detected error in the spot in question, we need a tie breaker. This way we can maintain the majority of the data while still attaining a best possible consensus.%0a
host:1611558172=104.175.54.158
author:1611557984=
diff:1611557984:1611557683:=289c289%0a%3c Typically if all 3 of the checksums were different, what do we do?  Firstly I want to say that all 3 bieng different will be extremely rare since we already have perfect 1-bit error correction and roughly 95%25 2-bit error detection at the base level. But when it does rarely happen we can do something else so we don't loose all the data in the base chromaton just because of a couple errors.  What we will do is take the 2 chromaton with the fewest detected errors (if there is a tie, favor chromaton that have most similar checksum) and then compare those at the base chromaton level.  Anything that is different between the 2 we see if there were any errors detected previously.  If one triad was detected as an error and the other chromaton does not have an error detected in that triad, then the error triad is replaced with the non-error triad.  After all of this what we will be left with is 2 chromaton that are either now identical or only vary in one of two ways.  The first way they can vary is if both have different errors in the same triad.  The second way is they both have different values in the same triad and neither was detected as an error.  In both of these cases the data from the third chromaton is used to fix these.  Even if the third chromaton is wrong or has a detected error in the spot in question, we need a tie breaker. This way we can maintain the majority of the data while still attaining a best possible consensus.%0a---%0a> Typically if all 3 of the checksums were different, what do we do?  Firstly I want to say that all 3 bieng different will be extremely rare since we already have perfect 1-bit error correction and roughly 95%25 2-bit error detection at the base level. But when it does rarely happen we can do something else so we don't loose all the data in the base chromaton just because of a couple errors.  What we will do is take the 2 chromaton with the fewest detected errors and then compare those at the base chromaton level.  Anything that is different between the 2 we see if there were any errors detected previously.  If one triad was detected as an error and the other chromaton does not have an error detected in that triad, then the error triad is replaced with the non-error triad.  After all of this what we will be left with is 2 chromaton that are either now identical or only vary in one of two ways.  The first way they can vary is if both have different errors in the same triad.  The second way is they both have different values in the same triad and neither was detected as an error.  In both of these cases the data from the third chromaton is used to fix these.  Even if the third chromaton is wrong or has a detected error in the spot in question, we need a tie breaker. This way we can maintain the majority of the data while still attaining a best possible consensus.%0a
host:1611557984=104.175.54.158
author:1611557683=
diff:1611557683:1611556907:=289c289%0a%3c Typically if all 3 of the checksums were different, what do we do?  Firstly I want to say that all 3 bieng different will be extremely rare since we already have perfect 1-bit error correction and roughly 95%25 2-bit error detection at the base level. But when it does rarely happen we can do something else so we don't loose all the data in the base chromaton just because of a couple errors.  What we will do is take the 2 chromaton with the fewest detected errors and then compare those at the base chromaton level.  Anything that is different between the 2 we see if there were any errors detected previously.  If one triad was detected as an error and the other chromaton does not have an error detected in that triad, then the error triad is replaced with the non-error triad.  After all of this what we will be left with is 2 chromaton that are either now identical or only vary in one of two ways.  The first way they can vary is if both have different errors in the same triad.  The second way is they both have different values in the same triad and neither was detected as an error.  In both of these cases the data from the third chromaton is used to fix these.  Even if the third chromaton is wrong or has a detected error in the spot in question, we need a tie breaker. This way we can maintain the majority of the data while still attaining a best possible consensus.%0a---%0a> Typically if all 3 of the checksums were different, we would just erase all of them since we don't know what is right.  Firstly I want to say that all 3 bieng different will be extremely rare since we already have perfect 1-bit error correction and roughly 95%25 2-bit error detection at the base level. But  when it does rarely happen we can do something else so we don't loose all the data in the base chromaton just because of a couple errors.  What we will do is take the 2 chromaton with the closest checksums and then compare those at the base chromaton level.  Anything that is different between the 2 will be erased.  If there are already erasures in one of the base chromaton from initial error correction, the erasures will be replaced by the chromaton it is bieng compared with, if the one it is bieng compared to has a full triad in that spot.  This way we can maintain the majority of the data while still attaining a 2/3 consensus.%0a
host:1611557683=104.175.54.158
author:1611556907=
diff:1611556907:1611556758:=287c287%0a%3c This gives us another check of the lower chromaton we are reading.  At this level we use "checksum" of the lower level.  So first we decode and error correct all base level chromaton.  Then we sum up all the numbers in each chromaton and this is the checksum, one for each chromaton.  In kilochromaton level we compare the three checksums for each replicate chromaton.  If all 3 are the same then we verified that everything is perfect (we have 16 base-4 numbers so the chance that we randomly got the checksums to equal yet actually be wrong is 1/64 × 1/64 × 1/64 = 3.8×10^(-6) or 4 times in 1 million).  But for 2 of them to randomly give the same checksum wrongly is 1/64 × (1/64+1/64) = 0.049%25 or 488 times in a million.  So since we will accept if 2 of them add to the same checksum, we will have a 99.95%25 correct - error correction rate.  This not only corrects 1 bit errors at this level, this corrects up to 16 bit errors!  An entire base chromaton could be wrong and it could be fixed at this level.%0a---%0a> This gives us another check of the lower chromaton we are reading.  At this level we use "checksum" of the lower level.  So first we decode and error correct all base level chromaton.  Then we sum up all the numbers in each chromaton and this is the checksum.  In kilochromaton level we compare the three checksums for each replicate chromaton.  If all 3 are the same then we verified that everything is perfect (we have 16 base-4 numbers so the chance that we randomly got the checksums to equal yet actually be wrong is 1/64 × 1/64 × 1/64 = 3.8×10^(-6) or 4 times in 1 million).  But for 2 of them to randomly give the same checksum wrongly is 1/64 × (1/64+1/64) = 0.049%25 or 488 times in a million.  So since we will accept if 2 of them add to the same checksum, we will have a 99.95%25 correct - error correction rate.  This not only corrects 1 bit errors at this level, this corrects up to 16 bit errors!  An entire base chromaton could be wrong and it could be fixed at this level.%0a
host:1611556907=104.175.54.158
author:1611556758=
diff:1611556758:1611556673:=272c272%0a%3c The 94.4%25 of times we correctly diagnose 2-bit errors, we will still "correct" it wrongly but we will make a note that it is an error [[https://electronics.stackexchange.com/questions/71410/single-bit-error-correction-double-bit-error-detection|#]].  This is because we do not know what the correct value is supposed to be so we have to make it something.  It would be nice if we could keep it and compare each color of each triad with the other replicate chromaton at the kilo- level, bit unfortunatly we don't record a value for each color, only for each triad.  So if we can't get consensus within the triad, we have to correct it to a wrong value and record it as an error.  The good news is at the kilo- level, if the other 2 chromaton don't have an error recorded here, their data will take precedence over our erroneous data.%0a---%0a> The 94.4%25 of times we correctly diagnose 2-bit errors, we will still "correct" it wrongly but we will make a note that it is an error.  This is because we do not know what the correct value is supposed to be so we have to make it something.  It would be nice if we could keep it and compare each color of each triad with the other replicate chromaton at the kilo- level, bit unfortunatly we don't record a value for each color, only for each triad.  So if we can't get consensus within the triad, we have to correct it to a wrong value and record it as an error.  The good news is at the kilo- level, if the other 2 chromaton don't have an error recorded here, their data will take precedence over our erroneous data.%0a
host:1611556758=104.175.54.158
author:1611556673=
diff:1611556673:1611554309:=268,269c268,269%0a%3c This means we will be able to correct every 1-bit error and only falsely correct (1/3)*(1/12+1/12) = 1/18 = 5.6%25 of 2-bit errors without detection because we diagnosed them as 1-bit errors wrongly.  This is because the chance that an error color is in an allowable spot is 1/3 and the chance a color in that error color's triad is also an error color in the triad in the right spot is 1/12 for each spot so 2/12 total.%0a%3c %0a---%0a> This means we will be able to correct every 1-bit error and only falsely correct (1/3)*(1/12+1/12) = 1/18 = 5.6%25 of 2-bit errors because we diagnosed them as 1-bit errors wrongly.  This is because the chance that an error color is in an allowable spot is 1/3 and the chance a color in that error color's triad is also an error color in the triad in the right spot is 1/12 for each spot so 2/12 total.%0a> %0a272c272%0a%3c The 94.4%25 of times we correctly diagnose 2-bit errors, we will still "correct" it wrongly but we will make a note that it is an error.  This is because we do not know what the correct value is supposed to be so we have to make it something.  It would be nice if we could keep it and compare each color of each triad with the other replicate chromaton at the kilo- level, bit unfortunatly we don't record a value for each color, only for each triad.  So if we can't get consensus within the triad, we have to correct it to a wrong value and record it as an error.  The good news is at the kilo- level, if the other 2 chromaton don't have an error recorded here, their data will take precedence over our erroneous data.%0a---%0a> The 94.4%25 tof times we correctly diagnose 2-bit errors, we will erase the triad that is infected with a 2-bit error.  This is because we do not know what the correct value is supposed to be.  It is better to have missing data than wrong data.  It would be nice if we could keep it and compare each color of each triad with the other replicate chromaton at the kilo- level, bit unfortunatly we don't record a value for each color, only for each triad.  So if we can't get consensus within the triad, we erase it.  The good news is at the kilo- level, if the other 2 chromaton don't have it erased, the missing triad will be restored.%0a
host:1611556673=104.175.54.158
author:1611554309=
diff:1611554309:1611553955:=287,289c287,289%0a%3c This gives us another check of the lower chromaton we are reading.  At this level we use "checksum" of the lower level.  So first we decode and error correct all base level chromaton.  Then we sum up all the numbers in each chromaton and this is the checksum.  In kilochromaton level we compare the three checksums for each replicate chromaton.  If all 3 are the same then we verified that everything is perfect (we have 16 base-4 numbers so the chance that we randomly got the checksums to equal yet actually be wrong is 1/64 × 1/64 × 1/64 = 3.8×10^(-6) or 4 times in 1 million).  But for 2 of them to randomly give the same checksum wrongly is 1/64 × (1/64+1/64) = 0.049%25 or 488 times in a million.  So since we will accept if 2 of them add to the same checksum, we will have a 99.95%25 correct - error correction rate.  This not only corrects 1 bit errors at this level, this corrects up to 16 bit errors!  An entire base chromaton could be wrong and it could be fixed at this level.%0a%3c %0a%3c Typically if all 3 of the checksums were different, we would just erase all of them since we don't know what is right.  Firstly I want to say that all 3 bieng different will be extremely rare since we already have perfect 1-bit error correction and roughly 95%25 2-bit error detection at the base level. But  when it does rarely happen we can do something else so we don't loose all the data in the base chromaton just because of a couple errors.  What we will do is take the 2 chromaton with the closest checksums and then compare those at the base chromaton level.  Anything that is different between the 2 will be erased.  If there are already erasures in one of the base chromaton from initial error correction, the erasures will be replaced by the chromaton it is bieng compared with, if the one it is bieng compared to has a full triad in that spot.  This way we can maintain the majority of the data while still attaining a 2/3 consensus.%0a---%0a> This gives us another check of the lower chromaton we are reading.  At this level we use "checksum" of the lower level.  So first we decode and error correct all base level chromaton.  Then we sum up all the numbers in each chromaton and this is the checksum.  In kilochromaton level we compare the three checksums for each replicate chromaton.  If all 3 are the same then we verified that everything is perfect (we have 16 base-4 numbers so the chance that we randomly got the checksums to equal yet actually be wrong is 1/64 × 1/64 × 1/64 = 3.8×10^(-6) or 4 times in 1 million).  But for 2 of them to randomly give the same checksum wrongly is 1/64 × (1/64+1/64) = 0.049%25 or 488 times in a million.  So since we will accept if 2 of them add to the same checksum, we will have a 99.95%25 correct error correction rate.  This not only corrects 1 bit errors at this level, this corrects up to 16 bit errors!  An entire base chromaton could be wrong and it could be fixed at this level.%0a> %0a> Typically if all 3 of the checksums were different, we would just erase all of them since we don't know what is right.  Firstly I want to say that all 3 bieng different will be extremely rare since we already have perfect 1-bit error correction and roughly 95%25 2-bit error detection at the base level. But  when it does rarely happen we can do something else so we don't loose all the data in the base chromaton just because of a couple errors.  What we will do is take the 2 chromaton withthe closest checksums and then compare those at the base chromaton level.  Anything that is different between the 2 will be erased.  This way we can maintain the majority of the data while still attaining a 2/3 consensus.%0a
host:1611554309=104.175.54.158
author:1611553955=
diff:1611553955:1611553445:=268,269c268,269%0a%3c This means we will be able to correct every 1-bit error and only falsely correct (1/3)*(1/12+1/12) = 1/18 = 5.6%25 of 2-bit errors because we diagnosed them as 1-bit errors wrongly.  This is because the chance that an error color is in an allowable spot is 1/3 and the chance a color in that error color's triad is also an error color in the triad in the right spot is 1/12 for each spot so 2/12 total.%0a%3c %0a---%0a> This means we will be able to correct every 1 bit error and only falsely correct (1/3)*(1/12+1/12) = 1/18 = 5.6%25 of 2 bit errors because we diagnosed them as 1-bit errors wrongly.  This is because the chance that an error color is in an allowable spot is 1/3 and the chance a color in that error color's triad is also an error color in the triad in the right spot is 1/12 for each spot so 2/12 total.%0a> %0a271,273d270%0a%3c %0a%3c The 94.4%25 tof times we correctly diagnose 2-bit errors, we will erase the triad that is infected with a 2-bit error.  This is because we do not know what the correct value is supposed to be.  It is better to have missing data than wrong data.  It would be nice if we could keep it and compare each color of each triad with the other replicate chromaton at the kilo- level, bit unfortunatly we don't record a value for each color, only for each triad.  So if we can't get consensus within the triad, we erase it.  The good news is at the kilo- level, if the other 2 chromaton don't have it erased, the missing triad will be restored.%0a%3c %0a
host:1611553955=104.175.54.158
author:1611553445=
diff:1611553445:1611553205:=286c286%0a%3c Typically if all 3 of the checksums were different, we would just erase all of them since we don't know what is right.  Firstly I want to say that all 3 bieng different will be extremely rare since we already have perfect 1-bit error correction and roughly 95%25 2-bit error detection at the base level. But  when it does rarely happen we can do something else so we don't loose all the data in the base chromaton just because of a couple errors.  What we will do is take the 2 chromaton withthe closest checksums and then compare those at the base chromaton level.  Anything that is different between the 2 will be erased.  This way we can maintain the majority of the data while still attaining a 2/3 consensus.%0a---%0a> Typically if all 3 of the checksums were different, we would just erase all of them since we don't know what is right.  But we can do something else so we don't loose all the data in the base chromaton just because of a couple errors.  What we will do is take the 2 chromaton withthe closest checksums and then compare those at the base chromaton level.  Ajything that is different between the 2 will be erased.  This way we can maintain the majority of the data while still attaining a 2/3 consensus.%0a
host:1611553445=104.175.54.158
author:1611553205=
diff:1611553205:1611552995:=285,286d284%0a%3c %0a%3c Typically if all 3 of the checksums were different, we would just erase all of them since we don't know what is right.  But we can do something else so we don't loose all the data in the base chromaton just because of a couple errors.  What we will do is take the 2 chromaton withthe closest checksums and then compare those at the base chromaton level.  Ajything that is different between the 2 will be erased.  This way we can maintain the majority of the data while still attaining a 2/3 consensus.%0a
host:1611553205=104.175.54.158
author:1611552995=
diff:1611552995:1611552795:=284c284%0a%3c This gives us another check of the lower chromaton we are reading.  At this level we use "checksum" of the lower level.  So first we decode and error correct all base level chromaton.  Then we sum up all the numbers in each chromaton and this is the checksum.  In kilochromaton level we compare the three checksums for each replicate chromaton.  If all 3 are the same then we verified that everything is perfect (we have 16 base-4 numbers so the chance that we randomly got the checksums to equal yet actually be wrong is 1/64 × 1/64 × 1/64 = 3.8×10^(-6) or 4 times in 1 million).  But for 2 of them to randomly give the same checksum wrongly is 1/64 × (1/64+1/64) = 0.049%25 or 488 times in a million.  So since we will accept if 2 of them add to the same checksum, we will have a 99.95%25 correct error correction rate.  This not only corrects 1 bit errors at this level, this corrects up to 16 bit errors!  An entire base chromaton could be wrong and it could be fixed at this level.%0a---%0a> This gives us another check of the lower chromaton we are reading.  At this level we use "checksum" of the lower level.  So first we decode and error correct all base level chromaton.  Then we sum up all the numbers in each chromaton and this is the checksum.  In kilochromaton level we compare the three checksums for each replicate chromaton.  If all 3 are the same then we verified that everything is perfect (we have 16 base-4 numbers so the chance that we randomly got the checksums to equal yet actually be wrong is 1/64 × 1/64 × 1/64 = 3.8×10^(-6) or 4 times in 1 million).  But for 2 of them to randomly give the same checksum wrongly is 1/64 × (1/64+1/64) = 0.049%25 or 488 times in a million.  So since we will accept if 2 of them add to the right checksum, we will have a 99.95%25 correct error correction rate.  This not only corrects 1 bit errors at this level, this corrects up to 16 bit errors!  An entire base chromaton could be wrong and it could be fixed at this level.%0a
host:1611552995=104.175.54.158
author:1611552795=
diff:1611552795:1611552739:=280c280%0a%3c The basic data structure of Cv3 is the same as Cv2.  In version 3 kilochromaton, three copies of each chromaton are used.  The way the data is organized the [[#cv3number|same as base cv3]].%0a---%0a> The basic data structure of Cv3 is the same as Cv2.  In version 3 kilochromaton, three copies of each chromaton are used.%0a
host:1611552795=104.175.54.158
author:1611552739=
diff:1611552739:1611552695:=257c257%0a%3c !!!Version 3 numbering [[#cv3number]]%0a---%0a> !!!Version 3 numbering%0a
host:1611552739=104.175.54.158
author:1611552695=
diff:1611552695:1611552252:=280c280,283%0a%3c The basic data structure of Cv3 is the same as Cv2.  In version 3 kilochromaton, three copies of each chromaton are used.%0a---%0a> The basic data structure of Cv3 is the same as Cv2.  In version 3 kilochromaton, three copies of each chromaton are used.  %0a> %0a> !!!!Kilo error correction %0a> This gives us another check of the lower chromaton we are reading.  At this level we use "checksum" of the lower level.  So first we decode and error correct all base level chromaton.  Then we sum up all the numbers in each chromaton and this is the checksum.  In kilochromaton level we compare the three checksums for each replicate chromaton.  If all 3 are the same then we verified that everything is perfect (we have 16 base-4 numbers so the chance that we randomly got the checksums to equal yet actually be wrong is 1/64 × 1/64 × 1/64 = 3.8×10^(-6) or 4 times in 1 million.  But for 2 of them to randomly give the same checksum wrongly is 1/64 × (1/64+1/64) = 0.049%25 or 488 times in a million.%0a282,285d284%0a%3c %0a%3c !!!!Kilo error correction %0a%3c This gives us another check of the lower chromaton we are reading.  At this level we use "checksum" of the lower level.  So first we decode and error correct all base level chromaton.  Then we sum up all the numbers in each chromaton and this is the checksum.  In kilochromaton level we compare the three checksums for each replicate chromaton.  If all 3 are the same then we verified that everything is perfect (we have 16 base-4 numbers so the chance that we randomly got the checksums to equal yet actually be wrong is 1/64 × 1/64 × 1/64 = 3.8×10^(-6) or 4 times in 1 million).  But for 2 of them to randomly give the same checksum wrongly is 1/64 × (1/64+1/64) = 0.049%25 or 488 times in a million.  So since we will accept if 2 of them add to the right checksum, we will have a 99.95%25 correct error correction rate.  This not only corrects 1 bit errors at this level, this corrects up to 16 bit errors!  An entire base chromaton could be wrong and it could be fixed at this level.%0a%3c %0a
host:1611552695=104.175.54.158
author:1611552252=
diff:1611552252:1611551448:=280,283c280%0a%3c The basic data structure of Cv3 is the same as Cv2.  In version 3 kilochromaton, three copies of each chromaton are used.  %0a%3c %0a%3c !!!!Kilo error correction %0a%3c This gives us another check of the lower chromaton we are reading.  At this level we use "checksum" of the lower level.  So first we decode and error correct all base level chromaton.  Then we sum up all the numbers in each chromaton and this is the checksum.  In kilochromaton level we compare the three checksums for each replicate chromaton.  If all 3 are the same then we verified that everything is perfect (we have 16 base-4 numbers so the chance that we randomly got the checksums to equal yet actually be wrong is 1/64 × 1/64 × 1/64 = 3.8×10^(-6) or 4 times in 1 million.  But for 2 of them to randomly give the same checksum wrongly is 1/64 × (1/64+1/64) = 0.049%25 or 488 times in a million.%0a---%0a> The basic data structure of Cv3 is the same as Cv2.%0a
host:1611552252=104.175.54.158
author:1611551448=
diff:1611551448:1611551310:=270c270%0a%3c This means we have a 94.4%25 2-bit error detection rate and 100%25 1-bit error correction rate.  This is excellent, 3 bits compared to 2 bits of Cv2, Cv2 only had 50%25 2-bit error detection (without filters) wheras with Cv3 and 3 bits, we get 94.4%25 2-bit error detection.  This is more than enough especially when using kilochromaton and higher as it will correct even more errors.%0a---%0a> This means we have a 94.4%25 2-bit error detection rate and 100%25 1-bit error correction rate.  This is excellent, 3 bits compared to 2 bits of Cv2, Cv2 only hasd 50%25 2-bit error detection (without filters) wheras with Cv3 and 3 bits, we get 94.4%25 2-bit error detection.  This is more than enough especially when using kilochromaton and higher as it will correct even more errors.%0a
host:1611551448=104.175.54.158
author:1611551310=
diff:1611551310:1611551211:=268c268%0a%3c This means we will be able to correct every 1 bit error and only falsely correct (1/3)*(1/12+1/12) = 1/18 = 5.6%25 of 2 bit errors because we diagnosed them as 1-bit errors wrongly.  This is because the chance that an error color is in an allowable spot is 1/3 and the chance a color in that error color's triad is also an error color in the triad in the right spot is 1/12 for each spot so 2/12 total.%0a---%0a> This means we will be able to correct every 1 bit error and only falsely correct (1/3)*(1/12+1/12) = 1/18 = 5.6%25 of 2 bit errors because we diagnosed them as 1-bit errors wrongly.  This is because the chance that an error color is in the right spot is 1/3 and the chance a color in that error color's triad is also an error color in the triad in the right spot is 1/12 for each spot so 2/12 total.%0a
host:1611551310=104.175.54.158
author:1611551211=
diff:1611551211:1611550496:=268c268%0a%3c This means we will be able to correct every 1 bit error and only falsely correct (1/3)*(1/12+1/12) = 1/18 = 5.6%25 of 2 bit errors because we diagnosed them as 1-bit errors wrongly.  This is because the chance that an error color is in the right spot is 1/3 and the chance a color in that error color's triad is also an error color in the triad in the right spot is 1/12 for each spot so 2/12 total.%0a---%0a> This means we will be able to correct every 1 bit error and only falsely correct (1/3)*(1/12+1/12) = 1/18 = 5.6%25 of 2 bit errors.  This is because the chance that an error color is in the right spot is 1/3 and the chance a color in that error color's triad is also an error color in the triad in the right spot is 1/12 for each spot so 2/12 total.%0a
host:1611551211=104.175.54.158
author:1611550496=
diff:1611550496:1611550423:=262c262%0a%3c The numbers represent the shape redundant data takes.  So each "1" is a replicate of the same data (in kilochromaton and greater it is the exact same data, but in base chromaton it represents a unique color combination triad, which all represent the same number as well).  And same for "2" and so on.  So version 3 chromaton can have 16 digits of base-4 numbers.  So each of these numbers can be 0,1,2 or 3.  Red-green-blue is 0. Purple-orange-bluegreen is 1. Yellow-cyan-magenta is 2. lightblue-yellowgreen-redmagenta is 3.%0a---%0a> The numbers represent the shape redundant data takes.  So each "1" is a replicate of the same data (in kilochromaton and greater it is the exact same data, but in base chromaton it represents a unique color combination which all represent the same number as well).  And same for "2" and so on.  So version 3 chromaton can have 16 digits of base-4 numbers.  So each of these numbers can be 0,1,2 or 3.  Red-green-blue is 0. Purple-orange-bluegreen is 1. Yellow-cyan-magenta is 2. lightblue-yellowgreen-redmagenta is 3.%0a
host:1611550496=104.175.54.158
author:1611550423=
diff:1611550423:1611550112:=263,264c263%0a%3c Attach:chromaton3.png%0a%3c %0a---%0a> %0a271c270%0a%3c %0a---%0a> Attach:chromaton3.png%0a
host:1611550423=104.175.54.158
author:1611550112=
diff:1611550112:1611550032:=6c6%0a%3c (:Update:1/24/2021:)%0a---%0a> (:Update:1/21/2021:)%0a
host:1611550112=104.175.54.158
author:1611550032=
diff:1611550032:1611549930:=260c260%0a%3c The colors here denote a certain shape that the color set (triad) can take, thus there are 4 shapes (green, orange, light blue, red)%0a---%0a> The colors here denote a certain shape that the color set can take, thus there are 4 shapes (green, orange, light blue, red)%0a
host:1611550032=104.175.54.158
author:1611549930=
diff:1611549930:1611549735:=264,269c264%0a%3c !!!!Error correction%0a%3c To get rid of the color filters in Cv2, we need to use 3 color triads instead of 2 color pairs.  We will also force orientation in certain ways so there are 12 colors and only base-4.  We are giving up 8 bases (2/3rds) in order to have robust error detection and correction.  This means that each color is only in a set of 3 and must maintain a certain orientation.  %0a%3c %0a%3c This means we will be able to correct every 1 bit error and only falsely correct (1/3)*(1/12+1/12) = 1/18 = 5.6%25 of 2 bit errors.  This is because the chance that an error color is in the right spot is 1/3 and the chance a color in that error color's triad is also an error color in the triad in the right spot is 1/12 for each spot so 2/12 total.%0a%3c %0a%3c This means we have a 94.4%25 2-bit error detection rate and 100%25 1-bit error correction rate.  This is excellent, 3 bits compared to 2 bits of Cv2, Cv2 only hasd 50%25 2-bit error detection (without filters) wheras with Cv3 and 3 bits, we get 94.4%25 2-bit error detection.  This is more than enough especially when using kilochromaton and higher as it will correct even more errors.%0a---%0a> To get rid of the color filters in Cv2, we need to use 3 color triads instead of 2 color pairs.  We will also force orientation in certain ways so there are 12 colors and only base-4.  We are giving up 8 bases (2/3rds) in order to have robust error detection and correction.  This means that each color is only in a set of 3 and must maintain a certain orientation.  This means we will be able to correct every 1 bit error and only falsely correct (1/3)*(1/12+1/12) = 1/18 = 5.6%25 of 2 bit errors.  This means we have a 94.4%25 2-bit error detection rate and 100%25 1-bit error correction rate.  This is excellent, 3 bits compared to 2 bits of Cv2, Cv2 only hasd 50%25 2-bit error detection (without filters) wheras with Cv3 and 3 bits, we get 94.4%25 2-bit error detection.  This is more than enough especially when using kilochromaton and higher as it will correct even more errors.%0a
host:1611549930=104.175.54.158
author:1611549735=
diff:1611549735:1611549645:=264c264%0a%3c To get rid of the color filters in Cv2, we need to use 3 color triads instead of 2 color pairs.  We will also force orientation in certain ways so there are 12 colors and only base-4.  We are giving up 8 bases (2/3rds) in order to have robust error detection and correction.  This means that each color is only in a set of 3 and must maintain a certain orientation.  This means we will be able to correct every 1 bit error and only falsely correct (1/3)*(1/12+1/12) = 1/18 = 5.6%25 of 2 bit errors.  This means we have a 94.4%25 2-bit error detection rate and 100%25 1-bit error correction rate.  This is excellent, 3 bits compared to 2 bits of Cv2, Cv2 only hasd 50%25 2-bit error detection (without filters) wheras with Cv3 and 3 bits, we get 94.4%25 2-bit error detection.  This is more than enough especially when using kilochromaton and higher as it will correct even more errors.%0a---%0a> To get rid of the color filters in Cv2, we need to use 3 bits instead of 2.  We will also force orientation in certain ways so there are 12 colors and only base-4.  We are giving up 8 bases (2/3rds) in order to have robust error detection and correction.  This means that each color is only in a set of 3 and must maintain a certain orientation.  This means we will be able to correct every 1 bit error and only falsely correct (1/3)*(1/12+1/12) = 1/18 = 5.6%25 of 2 bit errors.  This means we have a 94.4%25 2-bit error detection rate and 100%25 1-bit error correction rate.  This is excellent, 3 bits compared to 2 bits of Cv2, Cv2 only hasd 50%25 2-bit error detection (without filters) wheras with Cv3 and 3 bits, we get 94.4%25 2-bit error detection.  This is more than enough especially when using kilochromaton and higher as it will correct even more errors.%0a
host:1611549735=104.175.54.158
author:1611549645=
diff:1611549645:1611549023:=264c264%0a%3c To get rid of the color filters in Cv2, we need to use 3 bits instead of 2.  We will also force orientation in certain ways so there are 12 colors and only base-4.  We are giving up 8 bases (2/3rds) in order to have robust error detection and correction.  This means that each color is only in a set of 3 and must maintain a certain orientation.  This means we will be able to correct every 1 bit error and only falsely correct (1/3)*(1/12+1/12) = 1/18 = 5.6%25 of 2 bit errors.  This means we have a 94.4%25 2-bit error detection rate and 100%25 1-bit error correction rate.  This is excellent, 3 bits compared to 2 bits of Cv2, Cv2 only hasd 50%25 2-bit error detection (without filters) wheras with Cv3 and 3 bits, we get 94.4%25 2-bit error detection.  This is more than enough especially when using kilochromaton and higher as it will correct even more errors.%0a---%0a> To get rid of the color filters in Cv2, we need to use 3 bits instead of 2.  We will also force orientation in certain ways so there are 12 colors and only base-4.  We are giving up 8 bases (2/3rds) in order to have robust error detection and correction.  This means that each color is only in a set of 3 and must maintain a certain orientation.  This means we will be able to correct every 1 bit error and only falsely correct (1/3)*(1/12+1/12) = 1/18 = 5.6%25 of 2 bit errors.  This means we have a 94.4%25 2-bit error detection rate and 100%25 1-bit error correction rate.%0a
host:1611549645=104.175.54.158
author:1611549023=
diff:1611549023:1611548500:=264c264%0a%3c To get rid of the color filters in Cv2, we need to use 3 bits instead of 2.  We will also force orientation in certain ways so there are 12 colors and only base-4.  We are giving up 8 bases (2/3rds) in order to have robust error detection and correction.  This means that each color is only in a set of 3 and must maintain a certain orientation.  This means we will be able to correct every 1 bit error and only falsely correct (1/3)*(1/12+1/12) = 1/18 = 5.6%25 of 2 bit errors.  This means we have a 94.4%25 2-bit error detection rate and 100%25 1-bit error correction rate.%0a---%0a> To get rid of the color filters in Cv2, we need to use 3 bits instead of 2.  We will also force orientation in certain ways so there are 12 colors and only base-4.  We are giving up 8 bases (2/3rds) in order to have robust error detection and correction.  This means that each color is only in a set of 3 and must maintain a certain orientation.  This means we will be able to correct every 1 bit error and only falsely correct (1/3)*(1/12) = 1/36 = 2.8%25 of 2 bit errors.  This means we have a 97.2%25 2-bit error detection rate and 100%25 1-bit error correction rate.%0a
host:1611549023=104.175.54.158
author:1611548500=
diff:1611548500:1611547106:=258c258%0a%3c This applies to all levels of Cv3; base, kilo, mega, giga, etc.  So in Cv3 we achieve full fractal again.%0a---%0a> This applies to all levels of Cv3; base, kilo, mega, giga, etc.%0a
host:1611548500=104.175.54.158
author:1611547106=
diff:1611547106:1611547054:=255c255%0a%3c The basic data structure is the same as version 2.  In chromaton we had 48 unique digits that included some error correction.  In chromaton v2 we had a base level of 24 digits, and subsequent levels of 16 digits. In chromaton v3 every level has 16 digits.  Like in [[#v2|v2]], the grey dots can be white and achieve the same goal if desired (if grey is too hard to encode).%0a---%0a> The basic data structure is the same as version 2.  In chromaton we had 48 unique digits that included some error correction.  In chromaton v2 we had a base level of 24 digits, and subsequent levels of 16 digits. In chromaton v3 every level has 16 digits.%0a
host:1611547106=79.141.162.81
author:1611547054=
diff:1611547054:1611546831:=199c199%0a%3c The grey dots function as black dots but are used for orientation (they can be white if grey is undesired).  The black and white dots are used for timing and image flattening.  The white dots are used for markers for reading.  The reading algorithm would look at a white dot and read all the base pairs around the white dot in a clockwise fashion.  Then it would find the next white dot clockwise and read all base pairs around that clockwise.  It continues this in an outward spiral just like chromaton v1.  Even the outer white dots are used in the same way.  Notice that every base pair is read twice for redundancy...except the very corner data dots.  Actually when chromaton are linked together, the next chromaton will check that corner dot as well as the dot in it's own corner.  So the more chromaton linked together, the more complete the redundancy check.%0a---%0a> The grey dots function as black dots but are used for orientation.  The black and white dots are used for timing and image flattening.  The white dots are used for markers for reading.  The reading algorithm would look at a white dot and read all the base pairs around the white dot in a clockwise fashion.  Then it would find the next white dot clockwise and read all base pairs around that clockwise.  It continues this in an outward spiral just like chromaton v1.  Even the outer white dots are used in the same way.  Notice that every base pair is read twice for redundancy...except the very corner data dots.  Actually when chromaton are linked together, the next chromaton will check that corner dot as well as the dot in it's own corner.  So the more chromaton linked together, the more complete the redundancy check.%0a
host:1611547054=79.141.162.81
author:1611546831=
diff:1611546831:1611546794:=260c260%0a%3c The colors here denote a certain shape that the color set can take, thus there are 4 shapes (green, orange, light blue, red)%0a---%0a> The colors here denote a certain shape that the color set can take, thus there are 4 shapes (light blue, orange, red, green)%0a
host:1611546831=79.141.162.81
author:1611546794=
diff:1611546794:1611544734:=260c260%0a%3c The colors here denote a certain shape that the color set can take, thus there are 4 shapes (light blue, orange, red, green)%0a---%0a> The colors here denote a certain shape that the color set can take.%0a
host:1611546794=79.141.162.81
author:1611544734=
diff:1611544734:1611544667:=279,283c279,283%0a%3c For digital data storage and/or transmission uses, colors don't need to be used at all and can be replaced with numbers.  Using this system virtually perfect data transmission can be achieved free of any size bit error.  The whole purpose of the colors is making the data transmittible via visible photons at the speed of light with no prior established data link.  But if there is an established data link between the 2 (like bluetooth or internet) then colors are not needed. One thing that would not work with numbers would be the the color filters ([[#v2|chromaton version 2]]), so if that was removed only 50%25 error correction could be carried out on the lowest level of chromaton.  Perhaps instead of 2 bit groupings, 3 bit groupings could be used on the lowest level similar to higher levels of chromaton. And instead of having 24 base-6 digits on the lowest level and thus 60 binary bits, you would have 16 base-4 digits and thus 29 binary bits.  This was done in [[#v2|Chromaton v3]].%0a%3c %0a%3c For physical storage diffraction patterns (diffraction grating), thicknesses and angle of transparent layers (refraction: prism effect/internal reflection), or other methods can be used to achieve a certain fingerprint of light reflection/absorption that can be read as a "color" bit.  See also [[Chromaton disc]].%0a%3c %0a%3c For the time being chromaton is a 2D color representation of data.  Using diffraction of light chromaton could become 3D and instead of each 2D position of color defining the data, 3D position of color would define the data.%0a---%0a> For digital data storage and/or transmission uses, colors don't need to be used at all and can be replaced with numbers.  Using this system virtually perfect data transmission can be achieved free of any size bit error.  The whole purpose of the colors is making the data transmittible via visible photons at the speed of light with no prior established data link.  But if there is an established data link between the 2 (like bluetooth or internet) then colors are not needed. One thing that would not work with numbers would be the the color filters ([[#v2|chromaton version 2]]), so if that was removed only 50%25 error correction could be carried out on the lowest level of chromaton.  Perhaps instead of 2 bit groupings, 3 bit groupings could be used on the lowest level similar to higher levels of chromaton. And instead of hving 24 base-6 digits on the lowest level and thus 60 binary bits, you would have 16 base-4 digits and thus 29 binary bits.%0a> %0a> For physical storage diffraction patterns (diffraction grating), thicknesses and angle of transparent layers (refraction: prism effect/internal reflection), or other methods can be used to achieve a certain fingerprint of light reflection/absorption that can be read as a "color" bit.%0a> %0a> For the time bieng chromaton is a 2D color representation of data.  Using diffraction of light chromaton could become 3D and instead of each 2D position of color defining the data, 3D position of color would define the data.%0a
host:1611544734=79.141.162.81
author:1611544667=
diff:1611544667:1611544458:=279c279%0a%3c For digital data storage and/or transmission uses, colors don't need to be used at all and can be replaced with numbers.  Using this system virtually perfect data transmission can be achieved free of any size bit error.  The whole purpose of the colors is making the data transmittible via visible photons at the speed of light with no prior established data link.  But if there is an established data link between the 2 (like bluetooth or internet) then colors are not needed. One thing that would not work with numbers would be the the color filters ([[#v2|chromaton version 2]]), so if that was removed only 50%25 error correction could be carried out on the lowest level of chromaton.  Perhaps instead of 2 bit groupings, 3 bit groupings could be used on the lowest level similar to higher levels of chromaton. And instead of hving 24 base-6 digits on the lowest level and thus 60 binary bits, you would have 16 base-4 digits and thus 29 binary bits.%0a---%0a> For digital data storage and/or transmission uses, colors don't need to be used at all and can be replaced with numbers.  Using this system virtually perfect data transmission can be achieved free of any size bit error.  The whole purpose of the colors is making the data transmittible via visible photons at the speed of light with no prior established data link.  But if there is an established data link between the 2 (like bluetooth or internet) then colors are not needed. One thing that would not work with numbers would be the the color filters, so if that was removed only 50%25 error correction could be carried out on the lowest level of chromaton.  Perhaps instead of 2 bit groupings, 3 bit groupings could be used on the lowest level similar to higher levels of chromaton. And instead of hving 24 base-6 digits on the lowest level and thus 60 binary bits, you would have 16 base-4 digits and thus 29 binary bits.%0a
host:1611544667=79.141.162.81
author:1611544458=
diff:1611544458:1611544390:=274,275c274%0a%3c The basic data structure of Cv3 is the same as Cv2.%0a%3c Attach:kilov2.png%0a---%0a> The basic data structure of Cv3 is the same as Cv2%0a
host:1611544458=79.141.162.81
author:1611544390=
diff:1611544390:1611544295:=272,274d271%0a%3c %0a%3c !!!Kilochromaton v3%0a%3c The basic data structure of Cv3 is the same as Cv2%0a
host:1611544390=79.141.162.81
author:1611544295=
diff:1611544295:1611540854:=9c9%0a%3c (:Also:[[Digital collectible network]], [[Chromaton disc]]:)%0a---%0a> (:Also:[[Digital collectible network]]:)%0a
host:1611544295=79.141.162.81
author:1611540854=
diff:1611540854:1611540692:=277c277%0a%3c For physical storage diffraction patterns (diffraction grating), thicknesses and angle of transparent layers (refraction: prism effect/internal reflection), or other methods can be used to achieve a certain fingerprint of light reflection/absorption that can be read as a "color" bit.%0a---%0a> For physical storage diffraction patterns, thicknesses and angle of transparent layers (refraction: prism effect/internal reflection), or other methods can be used to achieve a certain fingerprint of light reflection/absorption that can be read as a "color" bit.%0a
host:1611540854=79.141.162.81
author:1611540692=
diff:1611540692:1611540289:=277c277%0a%3c For physical storage diffraction patterns, thicknesses and angle of transparent layers (refraction: prism effect/internal reflection), or other methods can be used to achieve a certain fingerprint of light reflection/absorption that can be read as a "color" bit.%0a---%0a> For physical storage diffraction patterns, thicknesses and angle of transparent layers (prism effect), or other methods can be used to achieve a certain fingerprint of light reflection/absorption that can be read as a "color" bit.%0a
host:1611540692=79.141.162.81
author:1611540289=
diff:1611540289:1611539849:=278,279d277%0a%3c %0a%3c For the time bieng chromaton is a 2D color representation of data.  Using diffraction of light chromaton could become 3D and instead of each 2D position of color defining the data, 3D position of color would define the data.%0a
host:1611540289=79.141.162.81
author:1611539849=
diff:1611539849:1611539635:=276,277d275%0a%3c %0a%3c For physical storage diffraction patterns, thicknesses and angle of transparent layers (prism effect), or other methods can be used to achieve a certain fingerprint of light reflection/absorption that can be read as a "color" bit.%0a
host:1611539849=79.141.162.81
author:1611539635=
diff:1611539635:1611539587:=258,259d257%0a%3c This applies to all levels of Cv3; base, kilo, mega, giga, etc.%0a%3c %0a
host:1611539635=79.141.162.81
author:1611539587=
diff:1611539587:1611539551:=255c255%0a%3c The basic data structure is the same as version 2.  In chromaton we had 48 unique digits that included some error correction.  In chromaton v2 we had a base level of 24 digits, and subsequent levels of 16 digits. In chromaton v3 every level has 16 digits.%0a---%0a> The basic data structure is the same as version 2.  In chromaton we had 48 unique digits that included some error correction.  In chromaton v2 we had a base level of 24 digits, and subsequent levels of 16 digits.%0a
host:1611539587=79.141.162.81
author:1611539551=
diff:1611539551:1611539355:=255c255%0a%3c The basic data structure is the same as version 2.  In chromaton we had 48 unique digits that included some error correction.  In chromaton v2 we had a base level of 24 digits, and subsequent levels of 16 digits.%0a---%0a> The basic data structure is the same as version 2.%0a
host:1611539551=79.141.162.81
author:1611539355=
diff:1611539355:1611539098:=260c260%0a%3c The numbers represent the shape redundant data takes.  So each "1" is a replicate of the same data (in kilochromaton and greater it is the exact same data, but in base chromaton it represents a unique color combination which all represent the same number as well).  And same for "2" and so on.  So version 3 chromaton can have 16 digits of base-4 numbers.  So each of these numbers can be 0,1,2 or 3.  Red-green-blue is 0. Purple-orange-bluegreen is 1. Yellow-cyan-magenta is 2. lightblue-yellowgreen-redmagenta is 3.%0a---%0a> The numbers represent the shape redundant data takes.  So each "1" is a replicate of the same data.  And same for "2" and so on.  So version 3 chromaton can have 16 digits of base-4 numbers.  So each of these numbers can be 0,1,2 or 3.  Red-green-blue is 0. Purple-orange-bluegreen is 1. Yellow-cyan-magenta is 2. lightblue-yellowgreen-redmagenta is 3.%0a
host:1611539355=79.141.162.81
author:1611539098=
diff:1611539098:1611539023:=260c260%0a%3c The numbers represent the shape redundant data takes.  So each "1" is a replicate of the same data.  And same for "2" and so on.  So version 3 chromaton can have 16 digits of base-4 numbers.  So each of these numbers can be 0,1,2 or 3.  Red-green-blue is 0. Purple-orange-bluegreen is 1. Yellow-cyan-magenta is 2. lightblue-yellowgreen-redmagenta is 3.%0a---%0a> The numbers represent the shape redundant data takes.  So each "1" is a replicate of the same data.  And same for "2" and so on.  So version 3 chromaton can have 16 digits of base-4 numbers.  So each of these numbers can be 0,1,2 or 3.  Red-green-blue is 0. Purple-orange-bluegreen is 1. Yellow-cyan-magenta is 2.%0a
host:1611539098=79.141.162.81
author:1611539023=
diff:1611539023:1611538960:=260c260%0a%3c The numbers represent the shape redundant data takes.  So each "1" is a replicate of the same data.  And same for "2" and so on.  So version 3 chromaton can have 16 digits of base-4 numbers.  So each of these numbers can be 0,1,2 or 3.  Red-green-blue is 0. Purple-orange-bluegreen is 1. Yellow-cyan-magenta is 2.%0a---%0a> The numbers represent the shape redundant data takes.  So each "1" is a replicate of the same data.  And same for "2" and so on.  So version 3 chromaton can have 16 digits of base-4 numbers.  So each of these numbers can be 0,1,2 or 3.  Red-green-blue is 0. Purple-orange-bluegreen is 1. %0a
host:1611539023=79.141.162.81
author:1611538960=
diff:1611538960:1611536722:=260c260%0a%3c The numbers represent the shape redundant data takes.  So each "1" is a replicate of the same data.  And same for "2" and so on.  So version 3 chromaton can have 16 digits of base-4 numbers.  So each of these numbers can be 0,1,2 or 3.  Red-green-blue is 0. Purple-orange-bluegreen is 1. %0a---%0a> The numbers represent the shape redundant data takes.  So each "1" is a replicate of the same data.  And same for "2" and so on.  So version 3 chromaton can have 16 digits of base-4 numbers.  So each of these numbers can be 0,1,2 or 3.  Red-green-blue is 0.  %0a
host:1611538960=79.141.162.81
author:1611536722=
diff:1611536722:1611536657:=260c260%0a%3c The numbers represent the shape redundant data takes.  So each "1" is a replicate of the same data.  And same for "2" and so on.  So version 3 chromaton can have 16 digits of base-4 numbers.  So each of these numbers can be 0,1,2 or 3.  Red-green-blue is 0.  %0a---%0a> The numbers represent the shape redundant data takes.  So each "1" is a replicate of the same data.  And same for "2" and so on.  So version 3 chromaton can have 16 digits of base-4 numbers.  So each of these numbers can be 0,1,2 or 3.%0a
host:1611536722=104.175.54.158
author:1611536657=
diff:1611536657:1611536502:=260c260%0a%3c The numbers represent the shape redundant data takes.  So each "1" is a replicate of the same data.  And same for "2" and so on.  So version 3 chromaton can have 16 digits of base-4 numbers.  So each of these numbers can be 0,1,2 or 3.%0a---%0a> The numbers represent the shape redundant data takes.  So each "1" is a replicate of the same data.  And same for "2" and so on.%0a
host:1611536657=104.175.54.158
author:1611536502=
diff:1611536502:1611530229:=259,260d258%0a%3c %0a%3c The numbers represent the shape redundant data takes.  So each "1" is a replicate of the same data.  And same for "2" and so on.%0a
host:1611536502=104.175.54.158
author:1611530229=
diff:1611530229:1611530183:=264d263%0a%3c The colors these were circled with match the colors above in the numbering picture.%0a
host:1611530229=79.141.162.81
author:1611530183=
diff:1611530183:1611530125:=266c266%0a%3c Attach:wheel1.png%0a---%0a> Attach:wheel.png%0a
host:1611530183=79.141.162.81
author:1611530125=
diff:1611530125:1611517647:=262,266d261%0a%3c %0a%3c !!!Version 3 combinations%0a%3c Attach:v3combos.png%0a%3c These were figured out using the below color wheel to get colors in the same possible position spaced out as far as possible on the color wheel.%0a%3c Attach:wheel.png%0a
host:1611530125=79.141.162.81
author:1611517647=
diff:1611517647:1611517581:=258,259d257%0a%3c The colors here denote a certain shape that the color set can take.%0a%3c %0a
host:1611517647=79.141.162.81
author:1611517581=
diff:1611517581:1611515313:=258c258%0a%3c To get rid of the color filters in Cv2, we need to use 3 bits instead of 2.  We will also force orientation in certain ways so there are 12 colors and only base-4.  We are giving up 8 bases (2/3rds) in order to have robust error detection and correction.  This means that each color is only in a set of 3 and must maintain a certain orientation.  This means we will be able to correct every 1 bit error and only falsely correct (1/3)*(1/12) = 1/36 = 2.8%25 of 2 bit errors.  This means we have a 97.2%25 2-bit error detection rate and 100%25 1-bit error correction rate.%0a---%0a> %0a
host:1611517581=79.141.162.81
author:1611515313=
diff:1611515313:1611515286:=250c250%0a%3c !!Chromaton Version 3 (Cv3) [[#v3]]%0a---%0a> !!Chromaton Version 3 (Cv3)%0a
host:1611515313=79.141.162.81
author:1611515286=
diff:1611515286:1611515233:=15c15%0a%3c See [[#v2|Version 2]] and also [[#v3|version 3]] for a more up to date version.%0a---%0a> See [[#v2|Version 2]] for a more up to date version.%0a
host:1611515286=79.141.162.81
author:1611515233=
diff:1611515233:1611511519:=252,259d251%0a%3c %0a%3c Attach:chromaton2.png%0a%3c %0a%3c The basic data structure is the same as version 2.%0a%3c %0a%3c !!!Version 3 numbering%0a%3c %0a%3c Attach:chromaton3.png%0a
host:1611515233=79.141.162.81
author:1611511519=
diff:1611511519:1611496509:=249,251d248%0a%3c %0a%3c !!Chromaton Version 3 (Cv3)%0a%3c In version 3 we want to accomplish 2 things.  Firstly we want to get rid of color filters altogether so Chromaton becomes a more flexible protocol.  Secondly we need to resist burst errors so redundant data needs to be placed far apart from eachother.%0a
host:1611511519=79.141.162.81
author:1611496509=
diff:1611496509:1611495276:=252c252%0a%3c For digital data storage and/or transmission uses, colors don't need to be used at all and can be replaced with numbers.  Using this system virtually perfect data transmission can be achieved free of any size bit error.  The whole purpose of the colors is making the data transmittible via visible photons at the speed of light with no prior established data link.  But if there is an established data link between the 2 (like bluetooth or internet) then colors are not needed. One thing that would not work with numbers would be the the color filters, so if that was removed only 50%25 error correction could be carried out on the lowest level of chromaton.  Perhaps instead of 2 bit groupings, 3 bit groupings could be used on the lowest level similar to higher levels of chromaton. And instead of hving 24 base-6 digits on the lowest level and thus 60 binary bits, you would have 16 base-4 digits and thus 29 binary bits.%0a---%0a> For digital data storage and/or transmission uses, colors don't need to be used at all and can be replaced with numbers.  Using this system virtually perfect data transmission can be achieved free of any size bit error.  The whole purpose of the colors is making the data transmittible via visible photons at the speed of light with no prior established data link.  But if there is an established data link between the 2 (like bluetooth or internet) then colors are not needed. One thing that would not work with numbers would be the the color filters, so if that was removed only 50%25 error correction could be carried out on the lowest level of chromaton.  Perhaps instead of 2 bit groupings, 3 bit groupings could be used on the lowest level similar to higher levels of chromaton.%0a
host:1611496509=104.175.54.158
author:1611495276=
diff:1611495276:1611494822:=252c252%0a%3c For digital data storage and/or transmission uses, colors don't need to be used at all and can be replaced with numbers.  Using this system virtually perfect data transmission can be achieved free of any size bit error.  The whole purpose of the colors is making the data transmittible via visible photons at the speed of light with no prior established data link.  But if there is an established data link between the 2 (like bluetooth or internet) then colors are not needed. One thing that would not work with numbers would be the the color filters, so if that was removed only 50%25 error correction could be carried out on the lowest level of chromaton.  Perhaps instead of 2 bit groupings, 3 bit groupings could be used on the lowest level similar to higher levels of chromaton.%0a---%0a> For digital data storage and/or transmission uses, colors don't need to be used at all and can be replaced with numbers.  Using this system virtually perfect data transmission can be achieved free of any size bit error.  The whole purpose of the colors is making the data transmittible via visible photons at the speed of light with no prior established data link.  But if there is an established data link between the 2 (like bluetooth or internet) then colors are not needed.%0a
host:1611495276=104.175.54.158
author:1611494822=
diff:1611494822:1611494630:=252c252%0a%3c For digital data storage and/or transmission uses, colors don't need to be used at all and can be replaced with numbers.  Using this system virtually perfect data transmission can be achieved free of any size bit error.  The whole purpose of the colors is making the data transmittible via visible photons at the speed of light with no prior established data link.  But if there is an established data link between the 2 (like bluetooth or internet) then colors are not needed.%0a---%0a> For digital data storage and/or transmission uses, colors don't need to be used at all and can be replaced with numbers.  Using this system virtually perfect data can be achieved free of any size bit error.  The whole purpose of the colors is making the data transmittible via visible photons at the speed of light.%0a
host:1611494822=104.175.54.158
author:1611494630=
diff:1611494630:1611494401:=252c252%0a%3c For digital data storage and/or transmission uses, colors don't need to be used at all and can be replaced with numbers.  Using this system virtually perfect data can be achieved free of any size bit error.  The whole purpose of the colors is making the data transmittible via visible photons at the speed of light.%0a---%0a> For digital data storage and/or transmission uses, colors don't need to be used at all and can be replaced with numbers.  Using this system virtually perfect data can be achieved free of any size bit error.%0a
host:1611494630=104.175.54.158
author:1611494401=
diff:1611494401:1611494356:=252c252%0a%3c For digital data storage and/or transmission uses, colors don't need to be used at all and can be replaced with numbers.  Using this system virtually perfect data can be achieved free of any size bit error.%0a---%0a> For digital data storage uses, colors don't need to be used at all and can be replaced with numbers.  Using this system virtually perfect data can be achieved free of any size bit error.%0a
host:1611494401=104.175.54.158
author:1611494356=
diff:1611494356:1611494037:=251,252d250%0a%3c %0a%3c For digital data storage uses, colors don't need to be used at all and can be replaced with numbers.  Using this system virtually perfect data can be achieved free of any size bit error.%0a
host:1611494356=104.175.54.158
author:1611494037=
diff:1611494037:1611493173:=230c230%0a%3c In chromaton v2 (Cv2), in higher orders of magnitude there will be 3 of each data "bit" where one bit is a lower level chromaton.  This can detect max of 2 bit errors and correct a maximum of 1 bit errors in the order of magnitude you are at.  For example in kilochromaton the 3 redundant bits means you can correct 1 bit errors in kilochromaton.  But what this means is this method can actually detect and correct errors of literally any size in the lower level of chromaton since it is comparing thier entire checksums. The nice thing here is this is perfect error correction instead of 96%25 like our first level.  The tradeoff is we can hold significantly less data in this method.  Instead of having 24 base-6 digits of storage like level 1, level 2 and beyond can only hold 16 digits each, but to integrity of data is astronomically high and virtually 100%25 perfection.%0a---%0a> In chromaton v2 (Cv2), in higher orders of magnitude there will be 3 of each data "bit" where one bit is a lower level chromaton.  This can detect max of 2 bit errors and correct a maximum of 1 bit errors.  The nice thing here is this is perfect error correction instead of 96%25 like our first level.  The tradeoff is we can hold significantly less data in this method.  Instead of having 24 base-6 digits of storage like level 1, level 2 and beyond can only hold 16 digits.%0a
host:1611494037=104.175.54.158
author:1611493173=
diff:1611493173:1611492408:=239,240d238%0a%3c Kilochromaton holds 16×24= senary digits or 16×60=960 binary bits of data. Megachromaton is needed to achieve the highest level of what a QR code can store by storing 15,360 error free bits, and %0a%3c Gigachromaton more than doubles what an iQR code can do by storing 245,760 error free bits.%0a
host:1611493173=104.175.54.158
author:1611492408=
diff:1611492408:1611491707:=219,223c219%0a%3c Notice there are 54 reads of 24 bits and that every double bit gets checked in full twice, and half of the double bit gets checked again for a total of 3x on each double bit.  The 3 checks vote and if it gets the same read 2 out of 3 times those 2 are considered the correct read.  If all 3 reads are different then it starts reading from the beginning again until there is a majority vote.%0a%3c %0a%3c When you stack more chromaton on eachother with the proper stacking bias, the corners of the next chromaton get checked with this chromaton.  %0a%3c %0a%3c The machine goes from one white bit to the next and reads the lower left bit first and moves around clockwise checking all bits.%0a---%0a> Notice there are 54 reads of 24 bits and that every bit get checked at least twice, some get checked 3x.  When you stack more chromaton on eachother with the proper stacking bias, the corners of the next chromaton get checkedin this chromaton.  The machine goes from one white bit to the next and reads the lower left bit first and moves around clockwise checking all bits.%0a
host:1611492408=104.175.54.158
author:1611491707=
diff:1611491707:1611472078:=217d216%0a%3c 24 senary (base-6) data bits means each chromaton contains 60 binary bits of data.%0a
host:1611491707=104.175.54.158
author:1611472078=
diff:1611472078:1611472025:=237,239d236%0a%3c %0a%3c Ignore the colors, that is just for visualization purposes.%0a%3c %0a
host:1611472078=79.141.162.81
author:1611472025=
diff:1611472025:1611471546:=225,227c225,227%0a%3c In chromaton v2 (Cv2), in higher orders of magnitude there will be 3 of each data "bit" where one bit is a lower level chromaton.  This can detect max of 2 bit errors and correct a maximum of 1 bit errors.  The nice thing here is this is perfect error correction instead of 96%25 like our first level.  The tradeoff is we can hold significantly less data in this method.  Instead of having 24 base-6 digits of storage like level 1, level 2 and beyond can only hold 16 digits.%0a%3c %0a%3c Higher order of magnitude error correction checks the "checksum" of each chromaton that is 1 order of magnitude below it and compares it between the 3 total copies of each.  One way to look at single bit error correction is the 3 copies vote and majority wins.  If none match, then that is considered detection of a 2 bit error.  This is a little different than normal.  Normally 4 copies are needed for 2 bit error detection and 1 bit correction.  Bit in this case the checksum's are so big that the chances of 2 checksums matching and both were in error, are very slim.  4 bits are needed for binary data.  For checksums which contain many more possibilities besides 0 and 1, only 3 bits are needed. %0a---%0a> In chromaton v2 (Cv2), in higher orders of magnitude there will be 4 of each data bit.  This can detect max of 2 bit errors and correct a maximum of 1 bit errors.  The nice thing here is this is perfect error correction instead of 96%25 like our first level.  The tradeoff is we can hold significantly less data in this method.  Instead of having 24 base-6 digits of storage like level 1, level 2 and beyond can only hold 12 digits.%0a> %0a> Higher order of magnitude error correction checks the "checksum" of each chromaton that is 1 order of magnitude below it and compares it between the 4 total copies of each.  One way to look at single bit error correction is the 4 copies vote and majority wins.  If it is a tie, then that is considered detection of a 2 bit error.  If 3 are wrong and 1 is right we will never know, as that would require 3 bit error detection which we don't have.  %0a
host:1611472025=79.141.162.81
author:1611471546=
diff:1611471546:1611471385:=233,235d232%0a%3c !!!!Kilochromaton%0a%3c Attach:kilov2.png%0a%3c %0a238c235%0a%3c Attach:kilov2machine.png%0a---%0a> Attach:kilov2.png%0a
host:1611471546=79.141.162.81
author:1611471385=
diff:1611471385:1611431236:=232,235d231%0a%3c %0a%3c !!!!Kilochromaton numbering%0a%3c Kilochromaton for Cv2 uses 3 redundant bits for each data bit.  It uses 1 bit error correction, if checksum's of the 3 replicates don't match, then error correction is run on all 3 on the lower chromaton level.  Then checksums are matched again.  If 2 match and one doesn't, the ones that matched are used as the correct data.  If all 3 still don't match then a 2 bit error is detected at the kilo level.%0a%3c Attach:kilov2.png%0a
host:1611471385=79.141.162.81
author:1611431236=
diff:1611431236:1611430983:=218c218%0a%3c Notice there are 54 reads of 24 bits and that every bit get checked at least twice, some get checked 3x.  When you stack more chromaton on eachother with the proper stacking bias, the corners of the next chromaton get checkedin this chromaton.  The machine goes from one white bit to the next and reads the lower left bit first and moves around clockwise checking all bits.%0a---%0a> Notice that every bit get checked at least twice, some get checked 3x.  The corners however only get checked once.  When you stack more chromaton on eachother with the proper stacking bias, these corners get checked.%0a
host:1611431236=79.141.162.81
author:1611430983=
diff:1611430983:1611428810:=220c220%0a%3c Attach:machinechromaton.png%0a---%0a> Attach:v2numbering.png%0a
host:1611430983=79.141.162.81
author:1611428810=
diff:1611428810:1611428778:=215c215%0a%3c The color correction bits are labeled with a "C" in front of them like "C1" and "C2".  The senary data bits (including inbuilt error correction) are labeled 1-24.%0a---%0a> The color correction bits are labeled with a "C" in front of them like "C1" and "C2".  The data bits (including inbuilt error correction) are labeled 1-24.%0a
host:1611428810=79.141.162.81
author:1611428778=
diff:1611428778:1611428582:=215d214%0a%3c The color correction bits are labeled with a "C" in front of them like "C1" and "C2".  The data bits (including inbuilt error correction) are labeled 1-24.%0a
host:1611428778=79.141.162.81
author:1611428582=
diff:1611428582:1611428526:=215c215%0a%3c Attach:chromatonnumber.png%0a---%0a> Attach:chromatonnumbering.png%0a
host:1611428582=79.141.162.81
author:1611428526=
diff:1611428526:1611423456:=213,215d212%0a%3c %0a%3c !!!Chromaton v2 Numbering%0a%3c Attach:chromatonnumbering.png%0a
host:1611428526=79.141.162.81
author:1611423456=
diff:1611423456:1611422947:=227c227%0a%3c Cv2 chromaton doesn't have a perfect fractaling outwards from the base level and beyond, but neither does DNA structure.  I am happy with Cv2 as a super robust error correcting design, perhaps the most practically robust ever designed by humans.%0a---%0a> Cv2 chromaton doesn't have a perfect fractaling outwards from the base level and beyond, but neither does DNA structure.  I am happy with Cv2 as a super robust error correcting design, perhaps the most practically robust ever designed.%0a
host:1611423456=104.175.54.158
author:1611422947=
diff:1611422947:1611422541:=205c205%0a%3c Anyway I started with pairing complementary colors.  I had 12 colors so with 6 pairs that gives 12 combinations.  I also realized that if I [[#orient|limit the directions]] the colors could go, so for example the lightest color always goes upwards, then there are only 6 combinations.  Doing this starts adding error correction ability.  With this restraint, we now have 50%25 1 bit error correction and 2 bit error detection.  The reason this works is if we have a random color error bit, there is a 50%25 chance it is in the wrong spot, and if so we know it was the wrong one and can correct it.  Next I figured I could improve the error correction ability more.  What if I added [[#filter|filters]] to areas of the chromaton, sort of like epigenetic modifications in DNA.  Filters would add another dimension to chromaton and could improve error detection.  I broke the chromaton into 12 areas each with one of the unique colors applied as a light filter.  Now the chances that a bad bit has the correct filter applied is 1 in 12.  So now we are at 1/2 * 1/12 = 96%25 1-bit error correction and 96%25 2-bit error detection!  This is closely approaching perfect algorithmic 1 bit error and 2 bit detection technology which typically would require 4 bits to achieve and we did it with only 2.%0a---%0a> Anyway I started with pairing complementary colors.  I had 12 colors so with 6 pairs that gives 12 combinations.  I also realized that if I [[#orient|limit the directions]] the colors could go, so for example the lightest color always goes upwards, then there are only 6 combinations.  Doing this starts adding error correction ability.  With this restraint, we now have 50%25 1 bit error correction and 2 bit error detection.  The reason this works is if we have a random color error bit, there is a 50%25 chance it is in the wrong spot, and if so we know it was the wrong one and can correct it.  Next I figured I could improve the error correction ability more.  What if I added [[#filter|filters]] to areas of the chromaton, sort of like epigenetic modifications in DNA.  Filters would add another dimension to chromaton and could improve error detection.  I broke the chromaton into 12 areas each with one of the unique colors applied as a light filter.  Now the chances that a bad bit has the correct filter applied is 1 in 12.  So now we are at 1/2 * 1/12 = 96%25 1-bit error correction and 96%25 2-bit error detection!  This is closely approaching perfect algorithmic 1 bit error and 2 bit detection technology which typically would require 4 bits to achieve and we only did it with 2.%0a
host:1611422947=104.175.54.158
author:1611422541=
diff:1611422541:1611422387:=202,203c202,203%0a%3c !!!Error correction%0a%3c Studying error correction I realized that in the original chromaton as a senary system, this would be quite a challenge to incorporate algorithmic error correction.  So Chromaton v2 was born, with the goal of physical error correction.  This is physics based information theory and has never been done before to my knowledge.  I discovered it studying DNA and how it has base pairs A-T and G-C that are always paired together.  I realized that this gives perfect 1 bit error detection.  I don't think there is error correction in DNA code, the polymerase just needs to be able to detect errors so it can fix them manually.  You don't want to gloss over damaged DNA by just adding bits for error correction, that is wasteful when you want the code to be maintained perfectly for life.%0a---%0a> %0a> Studying error correction I realized that on the original chromaton as a senary system, this would be quite a challenge to incorporate algorithmic error correction.  So Chromaton v2 was born, with the goal of physical error correction.  This is physics based information theory and has never been done before to my knowledge.  I discovered it studying DNA and how it has base pairs A-T and G-C that are always paired together.  I realized that this gives perfect 1 bit error detection.  I don't think there is error correction in DNA code, the polymerase just needs to be able to detect errors so it can fix them manually.  You don't want to gloss over damaged DNA by just adding bits for error correction, that is wasteful when you want the code to be maintained perfectly for life.%0a
host:1611422541=104.175.54.158
author:1611422387=
diff:1611422387:1611406252:=213c213%0a%3c !!!Machine reading%0a---%0a> !!!Numbering%0a
host:1611422387=104.175.54.158
author:1611406252=
diff:1611406252:1611405972:=205c205%0a%3c Anyway I started with pairing complementary colors.  I had 12 colors so with 6 pairs that gives 12 combinations.  I also realized that if I [[#orient|limit the directions]] the colors could go, so for example the lightest color always goes upwards, then there are only 6 combinations.  Doing this starts adding error correction ability.  With this restraint, we now have 50%25 1 bit error correction and 2 bit error detection.  The reason this works is if we have a random color error bit, there is a 50%25 chance it is in the wrong spot, and if so we know it was the wrong one and can correct it.  Next I figured I could improve the error correction ability more.  What if I added [[#filter|filters]] to areas of the chromaton, sort of like epigenetic modifications in DNA.  Filters would add another dimension to chromaton and could improve error detection.  I broke the chromaton into 12 areas each with one of the unique colors applied as a light filter.  Now the chances that a bad bit has the correct filter applied is 1 in 12.  So now we are at 1/2 * 1/12 = 96%25 1-bit error correction and 96%25 2-bit error detection!  This is closely approaching perfect algorithmic 1 bit error and 2 bit detection technology which typically would require 4 bits to achieve and we only did it with 2.%0a---%0a> Anyway I started with pairing complementary colors.  I had 12 colors so with 6 pairs that gives 12 combinations.  I also realized that if I [[#orient|limit the directions]] the colors could go, so for example the lightest color always goes upwards, then there are only 6 combinations.  Doing this starts adding error correction ability.  With this restraint, we now have 50%25 1 bit error correction and 2 bit error detection.  Next I figured I could improve the error correction ability more.  What if I added [[#filter|filters]] to areas of the chromaton, sort of like epigenetic modifications in DNA.  Filters would add another dimension to chromaton and could improve error detection.  I broke the chromaton into 12 areas each with one of the unique colors applied as a light filter.  Now the chances that a bad bit has the correct filter applied is 1 in 12.  So now we are at 1/2 * 1/12 = 96%25 1-bit error correction and 96%25 2-bit error detection!  This is closely approaching perfect algorithmic 1 bit error and 2 bit detection technology which typically would require 4 bits to achieve and we only did it with 2.%0a
host:1611406252=104.175.54.158
author:1611405972=
diff:1611405972:1611405277:=219c219%0a%3c Unlike v1 where any error correction can be carried out the same way on higher orders of magnitude, our color coding shortcuts cannot work on higher levels without degrading error correction performance on all levels (as far as I can design).  So we will opt for the standard physical error detection and correction; redundancy (again, the same error correction that DNA uses [[https://en.m.wikipedia.org/wiki/Genetic_redundancy|#]]).  Algorithmic data correction is weak.  If one check bit of algorithmic data correction becomes corrupted, error correction for multiple data bits is compromized. If one check bit of physical data correction becomes corrupted, error correction of only 1 data bit is compromized.  Therefore algorithmic always has tradeoffs.%0a---%0a> Unlike v1 where any error correction can be carried out the same way on higher orders of magnitude, our color coding shortcuts cannot work on higher levels without degrading error correction performance on all levels (as far as I can design).  So we will opt for the standard physical error detection and correction; redundancy.  Algorithmic data correction is weak.  If one check bit of algorithmic data correction becomes corrupted, error correction for multiple data bits is compromized. If one check bit of physical data correction becomes corrupted, error correction of only 1 data bit is compromized.  Therefore algorithmic always has tradeoffs.%0a
host:1611405972=104.175.54.158
author:1611405277=
diff:1611405277:1611404954:=219,222c219,222%0a%3c Unlike v1 where any error correction can be carried out the same way on higher orders of magnitude, our color coding shortcuts cannot work on higher levels without degrading error correction performance on all levels (as far as I can design).  So we will opt for the standard physical error detection and correction; redundancy.  Algorithmic data correction is weak.  If one check bit of algorithmic data correction becomes corrupted, error correction for multiple data bits is compromized. If one check bit of physical data correction becomes corrupted, error correction of only 1 data bit is compromized.  Therefore algorithmic always has tradeoffs.%0a%3c %0a%3c In chromaton v2 (Cv2), in higher orders of magnitude there will be 4 of each data bit.  This can detect max of 2 bit errors and correct a maximum of 1 bit errors.  The nice thing here is this is perfect error correction instead of 96%25 like our first level.  The tradeoff is we can hold significantly less data in this method.  Instead of having 24 base-6 digits of storage like level 1, level 2 and beyond can only hold 12 digits.%0a%3c %0a---%0a> Unlike V1 where any error correction can be carried out the same way on higher orders of magnitude, our color coding shortcuts cannot work on higher levels without degrading error correction performance on all levels (as far as I can design).  So we will opt for the standard physical error detection and correction; redundancy.  Algorithmic data correction is weak.  If one check bit of algorithmic data correction becomes corrupted, error correction for multiple data bits is compromized. If one check bit of physical data correction becomes corrupted, error correction of only 1 data bit is compromized.  Therefore algorithmic always has tradeoffs.%0a> %0a> In chromaton v2, in higher orders of magnitude there will be 4 of each data bit.  This can detect max of 2 bit errors and correct a maximum of 1 bit errors.  The nice thing here is this is perfect error correction instead of 96%25 like our first level.  The tradeoff is we can hold significantly less data in this method.  Instead of having 24 base-6 digits of storage like level 1, level 2 and beyond can only hold 12 digits.%0a> %0a225,227c225,227%0a%3c Therefore instead of having 100%25 error detection and correction rate since we are using perfect setup, since the check sum has only 72 possible outcomes (max sum would be 6x12) and the first level has 144 possible outcomes.  Therefore the actual rate is just over 99%25 for checking level 1, and just under 99%25 for each subsequent level.  Compound the 96%25 with the ~99%25 of each subsequent level and you have what quickly approaches perfect 1 bit error correction and 2 bit detection.%0a%3c %0a%3c Cv2 chromaton doesn't have a perfect fractaling outwards from the base level and beyond, but neither does DNA structure.  I am happy with Cv2 as a super robust error correcting design, perhaps the most practically robust ever designed.%0a---%0a> Therefore instead of having 100%25 error detection and correction rate since we are using perfect setup, since the check sum has only 72 possible outcomes (max sum would be 6x12) then the actual rate is just under 99%25.  Compound the 96%25 with the 99%25 of each subsequent level and you have what quickly approaches perfect 1 bit error correction and 2 bit detection.%0a> %0a> CV2 chromaton doesn't have a perfect fractaling outwards from the base level and beyond, but neither does DNA structure.  I am happy with CV2 as a super robust error correcting design, perhaps the most practically robust ever designed.%0a
host:1611405277=104.175.54.158
author:1611404954=
diff:1611404954:1611404661:=226,227d225%0a%3c %0a%3c CV2 chromaton doesn't have a perfect fractaling outwards from the base level and beyond, but neither does DNA structure.  I am happy with CV2 as a super robust error correcting design, perhaps the most practically robust ever designed.%0a
host:1611404954=104.175.54.158
author:1611404661=
diff:1611404661:1611404508:=223c223%0a%3c Higher order of magnitude error correction checks the "checksum" of each chromaton that is 1 order of magnitude below it and compares it between the 4 total copies of each.  One way to look at single bit error correction is the 4 copies vote and majority wins.  If it is a tie, then that is considered detection of a 2 bit error.  If 3 are wrong and 1 is right we will never know, as that would require 3 bit error detection which we don't have.  %0a---%0a> Higher order of magnitude error correction checks the "checksum" of each chromaton that is 1 order of magnitude below it and compares it with the 4 total copies of each.  One way to look at single bit error correction is the 4 copies vote and majority wins.  If it is a tie, then that is considered detection of a 2 bit error.  If 3 are wrong and 1 is right we will never know, as that would require 3 bit error detection which we don't have.  %0a
host:1611404661=104.175.54.158
author:1611404508=
diff:1611404508:1611404457:=219c219%0a%3c Unlike V1 where any error correction can be carried out the same way on higher orders of magnitude, our color coding shortcuts cannot work on higher levels without degrading error correction performance on all levels (as far as I can design).  So we will opt for the standard physical error detection and correction; redundancy.  Algorithmic data correction is weak.  If one check bit of algorithmic data correction becomes corrupted, error correction for multiple data bits is compromized. If one check bit of physical data correction becomes corrupted, error correction of only 1 data bit is compromized.  Therefore algorithmic always has tradeoffs.%0a---%0a> Unlike V1 where any error correction can be carried out the same way on higher orders of magnitude, our color coding shortcuts cannot work on higher levels without degrading error correction performance on all levels.  So we will opt for the standard physical error detection and correction; redundancy.  Algorithmic data correction is weak.  If one check bit of algorithmic data correction becomes corrupted, error correction for multiple data bits is compromized. If one check bit of physical data correction becomes corrupted, error correction of only 1 data bit is compromized.  Therefore algorithmic always has tradeoffs.%0a
host:1611404508=104.175.54.158
author:1611404457=
diff:1611404457:1611404039:=225c225%0a%3c Therefore instead of having 100%25 error detection and correction rate since we are using perfect setup, since the check sum has only 72 possible outcomes (max sum would be 6x12) then the actual rate is just under 99%25.  Compound the 96%25 with the 99%25 of each subsequent level and you have what quickly approaches perfect 1 bit error correction and 2 bit detection.%0a---%0a> Therefore instead of having 100%25 error detection and correction rate since we are using perfect setup, since the check sum has 144 possible outcomes then the actual rate is just over 99%25.%0a
host:1611404457=104.175.54.158
author:1611404039=
diff:1611404039:1611402972:=223,225c223%0a%3c Higher order of magnitude error correction checks the "checksum" of each chromaton that is 1 order of magnitude below it and compares it with the 4 total copies of each.  One way to look at single bit error correction is the 4 copies vote and majority wins.  If it is a tie, then that is considered detection of a 2 bit error.  If 3 are wrong and 1 is right we will never know, as that would require 3 bit error detection which we don't have.  %0a%3c %0a%3c Therefore instead of having 100%25 error detection and correction rate since we are using perfect setup, since the check sum has 144 possible outcomes then the actual rate is just over 99%25.%0a---%0a> Higher order of magnitude error correction checks the "checksum" of each chromaton 1 order of magnitude below it and compares it with the 4 total copies of each.  One way to look at single bit error correction is the 4 copies vote and majority wins.  If it is a tie, then that is considered detection of a 2 bit error.  If 3 are wrong and 1 is right we will never know, as that would require 3 bit error detection which we don't have.%0a
host:1611404039=104.175.54.158
author:1611402972=
diff:1611402972:1611402594:=222,223d221%0a%3c %0a%3c Higher order of magnitude error correction checks the "checksum" of each chromaton 1 order of magnitude below it and compares it with the 4 total copies of each.  One way to look at single bit error correction is the 4 copies vote and majority wins.  If it is a tie, then that is considered detection of a 2 bit error.  If 3 are wrong and 1 is right we will never know, as that would require 3 bit error detection which we don't have.%0a
host:1611402972=104.175.54.158
author:1611402594=
diff:1611402594:1611402288:=214c214%0a%3c Notice that every bit get checked at least twice, some get checked 3x.  The corners however only get checked once.  When you stack more chromaton on eachother with the proper stacking bias, these corners get checked.%0a---%0a> Notice that every bit get checked at least twice, some get checked 3x.  The corners however only get checked once.  When you stack more chromaton on eachother, these corners get checked.%0a
host:1611402594=104.175.54.158
author:1611402288=
diff:1611402288:1611402063:=219c219%0a%3c Unlike V1 where any error correction can be carried out the same way on higher orders of magnitude, our color coding shortcuts cannot work on higher levels without degrading error correction performance on all levels.  So we will opt for the standard physical error detection and correction; redundancy.  Algorithmic data correction is weak.  If one check bit of algorithmic data correction becomes corrupted, error correction for multiple data bits is compromized. If one check bit of physical data correction becomes corrupted, error correction of only 1 data bit is compromized.  Therefore algorithmic always has tradeoffs.%0a---%0a> Unlike V1 where any error correction can be carried out the same way on higher orders of magnitude, our color coding shortcutz cannot work on higher levels without degrading error correction performance on all levels.  So we will opt for the standard physical error detection and correction, redundancy.  Algorithmic data correction is weak.  If one check bit of algorithmic data correction becomes corrupted, error correction for multiple data bits is compromized. If one check bit of physical data correction becomes corrupted, error correction of only 1 data bit is compromized.  Therefore algorithmic always has tradeoffs.%0a
host:1611402288=104.175.54.158
author:1611402063=
diff:1611402063:1611382582:=197,200c197,198%0a%3c Unlike version 1 which could be stacked any way, version 2 requires a backwards stacking bias.  If a forward stacking bias is needed then the white and black dots on the outer ring need to be swapped.%0a%3c %0a%3c The grey dots function as black dots but are used for orientation.  The black and white dots are used for timing and image flattening.  The white dots are used for markers for reading.  The reading algorithm would look at a white dot and read all the base pairs around the white dot in a clockwise fashion.  Then it would find the next white dot clockwise and read all base pairs around that clockwise.  It continues this in an outward spiral just like chromaton v1.  Even the outer white dots are used in the same way.  Notice that every base pair is read twice for redundancy...except the very corner data dots.  Actually when chromaton are linked together, the next chromaton will check that corner dot as well as the dot in it's own corner.  So the more chromaton linked together, the more complete the redundancy check.%0a%3c %0a---%0a> The grey dots function as black dots but are used for orientation.  The black and white dots are used for timing and image flattening.  The white dots are used for markers for reading.  The reading algorithm would look at a white dot and read all the base pairs around the white dot in a clockwise fashion.  Then it would find the next white dot clockwise and read all base pairs around that clockwise.  It continues this in an outward spiral just like chromaton v1.  Even the outer white dots are used in the same way.  Notice that every base pair is read twice for redundancy...except the very corner data dots.  Actually when chromaton are linked together, the next chromaton will check that corner dot as well as the dot in it;s own corner.  So the more chromaton linked together, the more complete the redundancy check.%0a> %0a217,221d214%0a%3c %0a%3c !!!Higher order%0a%3c Unlike V1 where any error correction can be carried out the same way on higher orders of magnitude, our color coding shortcutz cannot work on higher levels without degrading error correction performance on all levels.  So we will opt for the standard physical error detection and correction, redundancy.  Algorithmic data correction is weak.  If one check bit of algorithmic data correction becomes corrupted, error correction for multiple data bits is compromized. If one check bit of physical data correction becomes corrupted, error correction of only 1 data bit is compromized.  Therefore algorithmic always has tradeoffs.%0a%3c %0a%3c In chromaton v2, in higher orders of magnitude there will be 4 of each data bit.  This can detect max of 2 bit errors and correct a maximum of 1 bit errors.  The nice thing here is this is perfect error correction instead of 96%25 like our first level.  The tradeoff is we can hold significantly less data in this method.  Instead of having 24 base-6 digits of storage like level 1, level 2 and beyond can only hold 12 digits.%0a
host:1611402063=104.175.54.158
author:1611382582=
diff:1611382582:1611382563:=196c196%0a%3c !!Chromaton Version 2[[#v2]]%0a---%0a> !!Chromaton Version 2%0a
host:1611382582=79.141.162.81
author:1611382563=
diff:1611382563:1611382019:=15,16d14%0a%3c See [[#v2|Version 2]] for a more up to date version.%0a%3c %0a
host:1611382563=79.141.162.81
author:1611382019=
diff:1611382019:1611381882:=10c10%0a%3c (:Archive:[[https://archive.is/W0na9|Archive.is]], [[https://web.archive.org/web/20210123060721/http://www.naturewiki.org/wiki/pmwiki.php/NatureWiki/Chromaton|Archive.org]]:)%0a---%0a> (:Archive:[[https://archive.is/W0na9|Archive.is]], [[https://web.archive.org/web/20210121190825/http://www.naturewiki.org/wiki/pmwiki.php/NatureWiki/Chromaton|Archive.org]]:)%0a
host:1611382019=79.141.162.81
author:1611381882=
diff:1611381882:1611381810:=10c10%0a%3c (:Archive:[[https://archive.is/W0na9|Archive.is]], [[https://web.archive.org/web/20210121190825/http://www.naturewiki.org/wiki/pmwiki.php/NatureWiki/Chromaton|Archive.org]]:)%0a---%0a> (:Archive:[[https://archive.is/q6wY1|Archive.is]], [[https://web.archive.org/web/20210121190825/http://www.naturewiki.org/wiki/pmwiki.php/NatureWiki/Chromaton|Archive.org]]:)%0a
host:1611381882=79.141.162.81
author:1611381810=
diff:1611381810:1611381520:=210c210%0a%3c Notice that every bit get checked at least twice, some get checked 3x.  The corners however only get checked once.  When you stack more chromaton on eachother, these corners get checked.%0a---%0a> Notice that every bit get checked at least twice, inner ones get checked 3x.  The corners however only get checked once.  When you stack more chromaton on eachother, these corners get checked.%0a
host:1611381810=79.141.162.81
author:1611381520=
diff:1611381520:1611380270:=208,212d207%0a%3c %0a%3c !!!Numbering%0a%3c Notice that every bit get checked at least twice, inner ones get checked 3x.  The corners however only get checked once.  When you stack more chromaton on eachother, these corners get checked.%0a%3c %0a%3c Attach:v2numbering.png%0a
host:1611381520=79.141.162.81
author:1611380270=
diff:1611380270:1611380175:=195c195%0a%3c The grey dots function as black dots but are used for orientation.  The black and white dots are used for timing and image flattening.  The white dots are used for markers for reading.  The reading algorithm would look at a white dot and read all the base pairs around the white dot in a clockwise fashion.  Then it would find the next white dot clockwise and read all base pairs around that clockwise.  It continues this in an outward spiral just like chromaton v1.  Even the outer white dots are used in the same way.  Notice that every base pair is read twice for redundancy...except the very corner data dots.  Actually when chromaton are linked together, the next chromaton will check that corner dot as well as the dot in it;s own corner.  So the more chromaton linked together, the more complete the redundancy check.%0a---%0a> The grey dots function as black dots but are used for orentation.  The black and white dots are used for timing and image flattening.  The white dots are used for markers for reading.  The reading algorithm would look at a white dot and read all the base pairs around the white dot in a clockwise fashion.  Then it would find the next white dot clockwise and read all base pairs around that clockwise.  It continues this in an outward spiral just like chromaton v1.  Even the outer white dots are used in the same way.  Notice that every base pair is read twice for redundancy...except the very corner data dots.  Actually when chromaton are linked together, the next %0a
host:1611380270=79.141.162.81
author:1611380175=
diff:1611380175:1611379457:=195d194%0a%3c The grey dots function as black dots but are used for orentation.  The black and white dots are used for timing and image flattening.  The white dots are used for markers for reading.  The reading algorithm would look at a white dot and read all the base pairs around the white dot in a clockwise fashion.  Then it would find the next white dot clockwise and read all base pairs around that clockwise.  It continues this in an outward spiral just like chromaton v1.  Even the outer white dots are used in the same way.  Notice that every base pair is read twice for redundancy...except the very corner data dots.  Actually when chromaton are linked together, the next %0a
host:1611380175=79.141.162.81
author:1611379457=
diff:1611379457:1611379330:=200c200%0a%3c Anyway I started with pairing complementary colors.  I had 12 colors so with 6 pairs that gives 12 combinations.  I also realized that if I [[#orient|limit the directions]] the colors could go, so for example the lightest color always goes upwards, then there are only 6 combinations.  Doing this starts adding error correction ability.  With this restraint, we now have 50%25 1 bit error correction and 2 bit error detection.  Next I figured I could improve the error correction ability more.  What if I added [[#filter|filters]] to areas of the chromaton, sort of like epigenetic modifications in DNA.  Filters would add another dimension to chromaton and could improve error detection.  I broke the chromaton into 12 areas each with one of the unique colors applied as a light filter.  Now the chances that a bad bit has the correct filter applied is 1 in 12.  So now we are at 1/2 * 1/12 = 96%25 1-bit error correction and 96%25 2-bit error detection!  This is closely approaching perfect algorithmic 1 bit error and 2 bit detection technology which typically would require 4 bits to achieve and we only did it with 2.%0a---%0a> Anyway I started with pairing complementary colors.  I had 12 colors so with 6 pairs that gives 12 combinations.  I also realized that if I limit the directions the colors could go, so for example the lightest color always goes upwards, then there are only 6 combinations.  Doing this starts adding error correction ability.  With this restraint, we now have 50%25 1 bit error correction and 2 bit error detection.  Next I figured I could improve the error correction ability more.  What if I added filters to areas of the chromaton, sort of like epigenetic modifications in DNA.  Filters would add another dimension to chromaton and could improve error detection.  I broke the chromaton into 12 areas each with one of the unique colors applied as a light filter.  Now the chances that a bad bit has the correct filter applied is 1 in 12.  So now we are at 1/2 * 1/12 = 96%25 1-bit error correction and 96%25 2-bit error detection!  This is closely approaching perfect algorithmic 1 bit error and 2 bit detection technology which typically would require 4 bits to achieve and we only did it with 2.%0a
host:1611379457=79.141.162.81
author:1611379330=
diff:1611379330:1611379302:=202c202%0a%3c !!!Allowed pair orientations[[#orient]]%0a---%0a> !!!Allowed pair orientations%0a
host:1611379330=79.141.162.81
author:1611379302=
diff:1611379302:1611378581:=205c205%0a%3c !!!Filter regions[[#filter]]%0a---%0a> !!!Filter regions%0a
host:1611379302=79.141.162.81
author:1611378581=
diff:1611378581:1611360833:=194,206d193%0a%3c !!Chromaton Version 2%0a%3c %0a%3c Attach:chromaton2.png%0a%3c %0a%3c Studying error correction I realized that on the original chromaton as a senary system, this would be quite a challenge to incorporate algorithmic error correction.  So Chromaton v2 was born, with the goal of physical error correction.  This is physics based information theory and has never been done before to my knowledge.  I discovered it studying DNA and how it has base pairs A-T and G-C that are always paired together.  I realized that this gives perfect 1 bit error detection.  I don't think there is error correction in DNA code, the polymerase just needs to be able to detect errors so it can fix them manually.  You don't want to gloss over damaged DNA by just adding bits for error correction, that is wasteful when you want the code to be maintained perfectly for life.%0a%3c %0a%3c Anyway I started with pairing complementary colors.  I had 12 colors so with 6 pairs that gives 12 combinations.  I also realized that if I limit the directions the colors could go, so for example the lightest color always goes upwards, then there are only 6 combinations.  Doing this starts adding error correction ability.  With this restraint, we now have 50%25 1 bit error correction and 2 bit error detection.  Next I figured I could improve the error correction ability more.  What if I added filters to areas of the chromaton, sort of like epigenetic modifications in DNA.  Filters would add another dimension to chromaton and could improve error detection.  I broke the chromaton into 12 areas each with one of the unique colors applied as a light filter.  Now the chances that a bad bit has the correct filter applied is 1 in 12.  So now we are at 1/2 * 1/12 = 96%25 1-bit error correction and 96%25 2-bit error detection!  This is closely approaching perfect algorithmic 1 bit error and 2 bit detection technology which typically would require 4 bits to achieve and we only did it with 2.%0a%3c %0a%3c !!!Allowed pair orientations%0a%3c Attach:colororientations.png%0a%3c %0a%3c !!!Filter regions%0a%3c Attach:filters.png%0a
host:1611378581=79.141.162.81
author:1611360833=
diff:1611360833:1611325423:=42c42%0a%3c Error correction in biology [[http://www.ece.iit.edu/~biitcomm/research/references/Manish%2520K.%2520Gupta/The%2520Quest%2520for%2520Error%2520Correction%2520in%2520Biology%2520-%25202006.pdf|#]].  Easy to understand explanation of error detection and correction [[http://web.mit.edu/6.02/www/f2006/handouts/bits_ecc.pdf|#]]%0a---%0a> Error correction in biology [[http://www.ece.iit.edu/~biitcomm/research/references/Manish%2520K.%2520Gupta/The%2520Quest%2520for%2520Error%2520Correction%2520in%2520Biology%2520-%25202006.pdf|#]].%0a
host:1611360833=79.141.162.81
author:1611325423=
diff:1611325423:1611323876:=41,42d40%0a%3c %0a%3c Error correction in biology [[http://www.ece.iit.edu/~biitcomm/research/references/Manish%2520K.%2520Gupta/The%2520Quest%2520for%2520Error%2520Correction%2520in%2520Biology%2520-%25202006.pdf|#]].%0a
host:1611325423=104.175.54.158
author:1611323876=
diff:1611323876:1611322180:=52c52%0a%3c Simplex codes for base-6 [[https://www.researchgate.net/publication/342464492_Quasi_Self-dual_Codes_over_Non-Unital_Rings_of_Order_Six|#]] [[https://www.researchgate.net/publication/247481215_Self-dual_codes_over_rings_and_the_Chinese_Remainder_Theorem|#]] [[https://www.researchgate.net/publication/260230094_On_Senary_Simplex_Codes|#]].%0a---%0a> Self dual codes for base-6 [[https://www.researchgate.net/publication/342464492_Quasi_Self-dual_Codes_over_Non-Unital_Rings_of_Order_Six|#]] [[https://www.researchgate.net/publication/247481215_Self-dual_codes_over_rings_and_the_Chinese_Remainder_Theorem|#]].%0a
host:1611323876=104.175.54.158
author:1611322180=
diff:1611322180:1611321886:=52c52%0a%3c Self dual codes for base-6 [[https://www.researchgate.net/publication/342464492_Quasi_Self-dual_Codes_over_Non-Unital_Rings_of_Order_Six|#]] [[https://www.researchgate.net/publication/247481215_Self-dual_codes_over_rings_and_the_Chinese_Remainder_Theorem|#]].%0a---%0a> Self dual codes for base-6 [[https://www.researchgate.net/publication/342464492_Quasi_Self-dual_Codes_over_Non-Unital_Rings_of_Order_Six|#]].%0a
host:1611322180=104.175.54.158
author:1611321886=
diff:1611321886:1611320814:=51,52d50%0a%3c %0a%3c Self dual codes for base-6 [[https://www.researchgate.net/publication/342464492_Quasi_Self-dual_Codes_over_Non-Unital_Rings_of_Order_Six|#]].%0a
host:1611321886=104.175.54.158
author:1611320814=
diff:1611320814:1611319413:=49,50d48%0a%3c %0a%3c To use reed solomon you would need a prime power alphabet so we would need to choose either base 4, 5, 7, or 8 instead of base-6 [[https://en.m.wikipedia.org/wiki/Reed–Solomon_error_correction|#]]. If we chose base 5 we would probably omit blue since it is similar to black.%0a
host:1611320814=104.175.54.158
author:1611319413=
diff:1611319413:1611318844:=48c48%0a%3c See non-binary error correction [[https://sites.bu.edu/mark/files/2018/12/CDT-2018-5008-FINAL.pdf|#]] [[http://www.mth.msu.edu/~jhall/classes/codenotes/Hamming.pdf|#]] [[https://math.stackexchange.com/questions/379672/non-binary-hamming-codes|#]].%0a---%0a> See non-binary error correction [[https://sites.bu.edu/mark/files/2018/12/CDT-2018-5008-FINAL.pdf|#]] [[http://www.mth.msu.edu/~jhall/classes/codenotes/Hamming.pdf|#]].%0a
host:1611319413=104.175.54.158
author:1611318844=
diff:1611318844:1611318581:=48c48%0a%3c See non-binary error correction [[https://sites.bu.edu/mark/files/2018/12/CDT-2018-5008-FINAL.pdf|#]] [[http://www.mth.msu.edu/~jhall/classes/codenotes/Hamming.pdf|#]].%0a---%0a> See non-binary error correction [[https://sites.bu.edu/mark/files/2018/12/CDT-2018-5008-FINAL.pdf|#]].%0a
host:1611318844=104.175.54.158
author:1611318581=
diff:1611318581:1611316692:=47,48d46%0a%3c %0a%3c See non-binary error correction [[https://sites.bu.edu/mark/files/2018/12/CDT-2018-5008-FINAL.pdf|#]].%0a
host:1611318581=104.175.54.158
author:1611316692=
diff:1611316692:1611294421:=44c44%0a%3c For 1 bit errors a minimum of 6 check bits are required for data + check bits between 31 and 63 (we have 48 data + check bits which puts us at dead center in that range) [[https://www.chegg.com/homework-help/many-check-bits-needed-hamming-error-correction-code-used-de-chapter-5-problem-13p-solution-9780134102061-exc|#]] [[https://computing.dcu.ie/~humphrys/Notes/Networks/data.hamming.html|#]].%0a---%0a> For 1 bit errors a minimum of 6 check bits are required for data + check bits between 31 and 63 (we have 48 data + check bits which puts us at dead center in that range) [[https://www.chegg.com/homework-help/many-check-bits-needed-hamming-error-correction-code-used-de-chapter-5-problem-13p-solution-9780134102061-exc|#]].%0a
host:1611316692=104.175.54.158
author:1611294421=
diff:1611294421:1611294371:=187c187%0a%3c The Chromaton system can be used for any purpose including data transmission (including cryptographic keys and/or signatures proving ownership) and/or storage that is both human and computer readable, making visual displays for any use or purpose, for doing computations, etc.  It was invented to be used in transferring private keys between users of [[digital collectible network]].%0a---%0a> The Chromaton system can be used for any purpose including data transmission (influding cryptographic keys and/or signatures proving ownership) and/or storage that is both human and computer readable, making visual displays for any use or purpose, for doing computations, etc.  It was invented to be used in transferring private keys between users of [[digital collectible network]].%0a
host:1611294421=104.175.54.158
author:1611294371=
diff:1611294371:1611293569:=187c187%0a%3c The Chromaton system can be used for any purpose including data transmission (influding cryptographic keys and/or signatures proving ownership) and/or storage that is both human and computer readable, making visual displays for any use or purpose, for doing computations, etc.  It was invented to be used in transferring private keys between users of [[digital collectible network]].%0a---%0a> The Chromaton system can be used for any purpose including data transmission and/or storage that is both human and computer readable, making visual displays for any use or purpose, for doing computations, etc.  It was invented to be used in transferring private keys between users of [[digital collectible network]].%0a
host:1611294371=104.175.54.158
author:1611293569=
diff:1611293569:1611293384:=9c9%0a%3c (:Also:[[Digital collectible network]]:)%0a---%0a> (:Also:none:)%0a
host:1611293569=104.175.54.158
author:1611293384=
diff:1611293384:1611293348:=187c187%0a%3c The Chromaton system can be used for any purpose including data transmission and/or storage that is both human and computer readable, making visual displays for any use or purpose, for doing computations, etc.  It was invented to be used in transferring private keys between users of [[digital collectible network]].%0a---%0a> The Chromaton system can be used for any purpose including data transmission and/or storage that is both human and computer readable, making visual displays for any use or purpose, for doing computations, etc.  It was invented tobe used in transferring private keys between users of [[digital collectible network]].%0a
host:1611293384=104.175.54.158
author:1611293348=
diff:1611293348:1611278792:=187c187%0a%3c The Chromaton system can be used for any purpose including data transmission and/or storage that is both human and computer readable, making visual displays for any use or purpose, for doing computations, etc.  It was invented tobe used in transferring private keys between users of [[digital collectible network]].%0a---%0a> The Chromaton system can be used for any purpose including data transmission and/or storage that is both human and computer readable, making visual displays for any use or purpose, for doing computations, etc.%0a
host:1611293348=104.175.54.158
author:1611278792=
diff:1611278792:1611271021:=19c19%0a%3c Colors determined from complementary and primary colors [[https://www.ecgprod.com/everything-you-know-about-color-is-probably-wrong/|#]].  Using colors introduces new potential for errors as seen here [[http://www.doiserbia.nb.rs/img/doi/1820-0214/2014/1820-02141400054Q.pdf|#]].%0a---%0a> Colors determined from complementary and primary colors [[https://www.ecgprod.com/everything-you-know-about-color-is-probably-wrong/|#]]%0a
host:1611278792=104.175.54.158
author:1611271021=
diff:1611271021:1611270549:=189,191c189%0a%3c Chromaton should absolutely never be used to identify people, should never be tied to an identity, and never used to verify people's identities or any mandatory or voluntary control or categorization of humans (including verifying compliance, which should never be done).  Chromaton use should never be tracked and should always be anonymous (not merely "anonymized").%0a%3c %0a%3c Keep Chromaton Free.%0a---%0a> Chromaton should absolutely not be used to identify people or verify people's identities or any mandatory or voluntary control or categorization of humans.  Chromaton use should not be tracked and should always be anonymous (not merely "anonymized").%0a
host:1611271021=79.141.162.81
author:1611270549=
diff:1611270549:1611270484:=189c189%0a%3c Chromaton should absolutely not be used to identify people or verify people's identities or any mandatory or voluntary control or categorization of humans.  Chromaton use should not be tracked and should always be anonymous (not merely "anonymized").%0a---%0a> Chromaton should absolutely not be used to identify people or verify people's identities or any mandatory or voluntary control or categorization of humans.  Chromaton use should always be anonymous.%0a
host:1611270549=79.141.162.81
author:1611270484=
diff:1611270484:1611269400:=189c189%0a%3c Chromaton should absolutely not be used to identify people or verify people's identities or any mandatory or voluntary control or categorization of humans.  Chromaton use should always be anonymous.%0a---%0a> Chromaton should absolutely not be used to identify people or verify people's identities or any mandatory or voluntary control or categorization of humans.%0a
host:1611270484=79.141.162.81
author:1611269400=
diff:1611269400:1611269320:=50c50%0a%3c For 2 bit error correction preferably bits 1-11 could be error correction and the 12th would be the first data hexagon.%0a---%0a> For 2 bit error correction preferably bits 2-21 could be error correction and the 13th would be the first data hexagon.%0a
host:1611269400=79.141.162.81
author:1611269320=
diff:1611269320:1611268719:=41,43d40%0a%3c %0a%3c Bit 13 is the Error Correction delineating bit.  If it has one of the 6 colors, then there is no error correction (and bit 13 is a data bit).  If it is white then there is 1 bit error correction, if it is black then there is 2 bit error correction.%0a%3c %0a
host:1611269320=79.141.162.81
author:1611268719=
diff:1611268719:1611267585:=47c47%0a%3c For 2 bit error correction preferably bits 2-21 could be error correction and the 13th would be the first data hexagon.%0a---%0a> For 2 bit error correction the first 11 hexagons could be error correction and the 12th would be the first data hexagon.%0a
host:1611268719=79.141.162.81
author:1611267585=
diff:1611267585:1611264130:=46,47d45%0a%3c %0a%3c For 2 bit error correction the first 11 hexagons could be error correction and the 12th would be the first data hexagon.%0a
host:1611267585=79.141.162.81
author:1611264130=
diff:1611264130:1611263589:=80c80%0a%3c Encryption would be done on the data before encoding into chromaton.  Therefore Chromaton can be encrypted and only decrypted by the intended recipient if desired.%0a---%0a> Encryption would be done on the data before encoding.  Therefore Chromaton can be encrypted and only decrypted by the intended recipient if desired.%0a
host:1611264130=79.141.162.81
author:1611263589=
diff:1611263589:1611263529:=183,184d182%0a%3c %0a%3c Chromaton should absolutely not be used to identify people or verify people's identities or any mandatory or voluntary control or categorization of humans.%0a
host:1611263589=79.141.162.81
author:1611263529=
diff:1611263529:1611263129:=78,80d77%0a%3c %0a%3c !!Encryption%0a%3c Encryption would be done on the data before encoding.  Therefore Chromaton can be encrypted and only decrypted by the intended recipient if desired.%0a
host:1611263529=79.141.162.81
author:1611263129=
diff:1611263129:1611263097:=179c179%0a%3c The Chromaton system can be used for any purpose including data transmission and/or storage that is both human and computer readable, making visual displays for any use or purpose, for doing computations, etc.%0a---%0a> The Chromaton system can be used for any purpose including data transmission that is both human and computer readable, making visual displays for any use or purpose, for doing computations, etc.%0a
host:1611263129=79.141.162.81
author:1611263097=
diff:1611263097:1611260299:=177,179d176%0a%3c %0a%3c !!Uses%0a%3c The Chromaton system can be used for any purpose including data transmission that is both human and computer readable, making visual displays for any use or purpose, for doing computations, etc.%0a
host:1611263097=79.141.162.81
author:1611260299=
diff:1611260299:1611260282:=64c64%0a%3c Here is an example chromaton that would be seen in the wild.  The data it encodes is:\\%0a---%0a> Here is an example chromaton that would be seen in the wild.  The data it encodes is:%0a
host:1611260299=79.141.162.81
author:1611260282=
diff:1611260282:1611260048:=65c65%0a%3c \\%0a---%0a> %0a67c67%0a%3c \\%0a---%0a> %0a69c69%0a%3c \\%0a---%0a> %0a71c71%0a%3c \\%0a---%0a> %0a73c73%0a%3c \\%0a---%0a> %0a75c75%0a%3c \\%0a---%0a> %0a
host:1611260282=79.141.162.81
author:1611260048=
diff:1611260048:1611260042:=76c76%0a%3c Base-26 (alpha):DDLJYTOUIKGDXJPGNHKYVJRSKRB (27 digits)\\%0a---%0a> Base-26 (alpha):DDLJYTOUIKGDXJPGNHKYVJRSKRB (27 digits)%0a
host:1611260048=79.141.162.81
author:1611260042=
diff:1611260042:1611259975:=68,76c68,76%0a%3c Base-2 (binary):1110100000011010010010111101001101100001100001101000010011011010010011111011101010111111101110110011000000100111110111100011 (124 digits)\\%0a%3c %0a%3c Base-10 (decimal):19282339541779226363068247068383542755 (38 digits)\\%0a%3c %0a%3c Base-16 (hex):E81A4BD3618684DA4FBABFBB3027DE3 (31 digits)\\%0a%3c %0a%3c Base-26:33B9OJEK8A63N9F6D7AOL9HIAH1 (27 digits)\\%0a%3c %0a%3c Base-26 (alpha):DDLJYTOUIKGDXJPGNHKYVJRSKRB (27 digits)%0a---%0a> Base-2 (binary):1110100000011010010010111101001101100001100001101000010011011010010011111011101010111111101110110011000000100111110111100011\\%0a> %0a> Base-10 (decimal):19282339541779226363068247068383542755\\%0a> %0a> Base-16 (hex):E81A4BD3618684DA4FBABFBB3027DE3\\%0a> %0a> Base-26:33B9OJEK8A63N9F6D7AOL9HIAH1\\%0a> %0a> Base-26 (alpha):DDLJYTOUIKGDXJPGNHKYVJRSKRB%0a
host:1611260042=79.141.162.81
author:1611259975=
diff:1611259975:1611259506:=66c66%0a%3c Native Base-6 (senary):505300514114023455100250211322031424243343234551 (48 digits)\\%0a---%0a> Native Base-6 (senary):505300514114023455100250211322031424243343234551\\%0a
host:1611259975=79.141.162.81
author:1611259506=
diff:1611259506:1611258972:=75,76d74%0a%3c %0a%3c Base-26 (alpha):DDLJYTOUIKGDXJPGNHKYVJRSKRB%0a
host:1611259506=79.141.162.81
author:1611258972=
diff:1611258972:1611258930:=67d66%0a%3c %0a69d67%0a%3c %0a71d68%0a%3c %0a73d69%0a%3c %0a75,76d70%0a%3c %0a%3c %0a
host:1611258972=79.141.162.81
author:1611258930=
diff:1611258930:1611258898:=53a54%0a> Attach:chromatoncolor.png%0a62,63d62%0a%3c Attach:chromatoncolor.png%0a%3c %0a66,70c65,69%0a%3c Native Base-6 (senary):505300514114023455100250211322031424243343234551\\%0a%3c Base-2 (binary):1110100000011010010010111101001101100001100001101000010011011010010011111011101010111111101110110011000000100111110111100011\\%0a%3c Base-10 (decimal):19282339541779226363068247068383542755\\%0a%3c Base-16 (hex):E81A4BD3618684DA4FBABFBB3027DE3\\%0a%3c Base-26:33B9OJEK8A63N9F6D7AOL9HIAH1\\%0a---%0a> Native Base-6 (senary):505300514114023455100250211322031424243343234551%0a> Base-2 (binary):1110100000011010010010111101001101100001100001101000010011011010010011111011101010111111101110110011000000100111110111100011%0a> Base-10 (decimal):19282339541779226363068247068383542755%0a> Base-16 (hex):E81A4BD3618684DA4FBABFBB3027DE3%0a> Base-26:33B9OJEK8A63N9F6D7AOL9HIAH1%0a
host:1611258930=79.141.162.81
author:1611258898=
diff:1611258898:1611258827:=55,62d54%0a%3c \\%0a%3c Red = 0\\%0a%3c Cyan = 1\\%0a%3c Yellow = 2\\%0a%3c Magenta = 3\\%0a%3c Green = 4\\%0a%3c Blue = 5\\%0a%3c \\%0a
host:1611258898=79.141.162.81
author:1611258827=
diff:1611258827:1611258796:=30a31,38%0a> \\%0a> Red = 1\\%0a> Cyan = 2\\%0a> Green = 3\\%0a> Magenta = 4\\%0a> Blue = 5\\%0a> Yellow = 6\\%0a> \\%0a
host:1611258827=79.141.162.81
author:1611258796=
diff:1611258796:1611257918:=63,69c63%0a%3c Here is an example chromaton that would be seen in the wild.  The data it encodes is:%0a%3c %0a%3c Native Base-6 (senary):505300514114023455100250211322031424243343234551%0a%3c Base-2 (binary):1110100000011010010010111101001101100001100001101000010011011010010011111011101010111111101110110011000000100111110111100011%0a%3c Base-10 (decimal):19282339541779226363068247068383542755%0a%3c Base-16 (hex):E81A4BD3618684DA4FBABFBB3027DE3%0a%3c Base-26:33B9OJEK8A63N9F6D7AOL9HIAH1%0a---%0a> Here is an example chromaton that would be seen in the wild.  The data it encodes is %0a
host:1611258796=79.141.162.81
author:1611257918=
diff:1611257918:1611257835:=10c10%0a%3c (:Archive:[[https://archive.is/q6wY1|Archive.is]], [[https://web.archive.org/web/20210121190825/http://www.naturewiki.org/wiki/pmwiki.php/NatureWiki/Chromaton|Archive.org]]:)%0a---%0a> (:Archive:[[https://archive.is/q6wY1|Archive.is]], [[https://web.archive.org/web/20210120025440/http://www.naturewiki.org/wiki/pmwiki.php/NatureWiki/Chromaton|Archive.org]]:)%0a
host:1611257918=79.141.162.81
author:1611257835=
diff:1611257835:1611257748:=63d62%0a%3c Here is an example chromaton that would be seen in the wild.  The data it encodes is %0a
host:1611257835=79.141.162.81
author:1611257748=
diff:1611257748:1611256367:=60,62d59%0a%3c %0a%3c !!!Chromaton example%0a%3c Attach:chromatoncolor.png%0a
host:1611257748=79.141.162.81
author:1611256367=
diff:1611256367:1611256080:=24c24%0a%3c The name chromaton was originally intended for a cryptocurrency but finds a better use in data storage (which can also service cryptovalue).  From the beginning the name meant the smallest unit of color.  Here that fits as the chromaton is the smallest repeating unit and it contains color.  Also it so happens the data storage in chromaton is similar to data storage in chromatin in DNA.  This was not intended, neither the similarity of the name nor the DNA-like storage in the chromaton unit.  The chromaton unit was simply designed as a hexagonal spiral with black and white to break up the data for easier processing.  Even the fact that it scales infinitely was not realized until halfway through the designing.%0a---%0a> Chromaton was originally intended for a cryptocurrency but finds a better use in data storage.  From the beginning the name meant the smallest unit of color.  Here that fits as the chromaton is the smallest repeating unit and it contains color.  Also it so happens the data storage in chromaton is similar to data storage in chromatin in DNA.  This was not intended, neither the similarity of the name nor the DNA-like storage in the chromaton unit.  The chromaton unit was simply designed as a hexagonal spiral with black and white to break up the data for easier processing.  Even the fact that it scales infinitely was not realized until halfway through the designing.%0a
host:1611256367=79.141.162.81
author:1611256080=
diff:1611256080:1611256007:=58,59d57%0a%3c %0a%3c Of course in kilo, mega, etc chromaton the error correction scales up so entire chromaton can be missing in kilochromaton for example and still be ok.%0a
host:1611256080=79.141.162.81
author:1611256007=
diff:1611256007:1611255670:=6c6%0a%3c (:Update:1/21/2021:)%0a---%0a> (:Update:1/19/2021:)%0a
host:1611256007=79.141.162.81
author:1611255670=
diff:1611255670:1611255648:=10c10%0a%3c (:Archive:[[https://archive.is/q6wY1|Archive.is]], [[https://web.archive.org/web/20210120025440/http://www.naturewiki.org/wiki/pmwiki.php/NatureWiki/Chromaton|Archive.org]]:)%0a---%0a> (:Archive:[https://archive.is/q6wY1|Archive.is]], [[https://web.archive.org/web/20210120025440/http://www.naturewiki.org/wiki/pmwiki.php/NatureWiki/Chromaton|Archive.org]]:)%0a
host:1611255670=79.141.162.81
author:1611255648=
diff:1611255648:1611255197:=10c10%0a%3c (:Archive:[https://archive.is/q6wY1|Archive.is]], [[https://web.archive.org/web/20210120025440/http://www.naturewiki.org/wiki/pmwiki.php/NatureWiki/Chromaton|Archive.org]]:)%0a---%0a> (:Archive:[[https://archive.is/BQ9or|Archive.is]], [[https://web.archive.org/web/20210120025440/http://www.naturewiki.org/wiki/pmwiki.php/NatureWiki/Chromaton|Archive.org]]:)%0a
host:1611255648=79.141.162.81
author:1611255197=
diff:1611255197:1611253040:=54,55d53%0a%3c %0a%3c Attach:chromatoncheckbits.png%0a
host:1611255197=79.141.162.81
author:1611253040=
diff:1611253040:1611252072:=54,55d53%0a%3c %0a%3c See also [[https://en.wikipedia.org/wiki/Error_correction_code|Error correction code]]%0a
host:1611253040=79.141.162.81
author:1611252072=
diff:1611252072:1611251474:=49c49%0a%3c For 1 bit errors a minimum of 6 check bits are required for data + check bits between 31 and 63 (we have 48 data + check bits which puts us at dead center in that range) [[https://www.chegg.com/homework-help/many-check-bits-needed-hamming-error-correction-code-used-de-chapter-5-problem-13p-solution-9780134102061-exc|#]].%0a---%0a> For 1 bit errors a minimum of 6 check bits are required for data + check bits between 31 and 63 (we have 48 data + check bits) [[https://www.chegg.com/homework-help/many-check-bits-needed-hamming-error-correction-code-used-de-chapter-5-problem-13p-solution-9780134102061-exc|#]].%0a
host:1611252072=79.141.162.81
author:1611251474=
diff:1611251474:1611250388:=49,53c49%0a%3c For 1 bit errors a minimum of 6 check bits are required for data + check bits between 31 and 63 (we have 48 data + check bits) [[https://www.chegg.com/homework-help/many-check-bits-needed-hamming-error-correction-code-used-de-chapter-5-problem-13p-solution-9780134102061-exc|#]].%0a%3c %0a%3c For 2 bit errors; 11 check bits would be required [[https://stackoverflow.com/questions/5631871/what-is-the-minimum-number-of-bits-needed-to-correct-all-2-bit-errors|#]].%0a%3c %0a%3c Prime candidates for check bits are 2, 4, 6, 8, 10, 12.  This is ideal because there is a check bit on every chunk of data and also it makes the data bits (non check bits) follow a nice pattern of 6 on the inner ring, 12 on the mid ring, and 24 on the outer ring.  It is also nice that the majority of our data is found in the outer ring, and all the check bits are in the inner ring.  So it is unlikely that both are compromised.%0a---%0a> A minimum of 6 check bits are required for data + check bits between 31 and 63 (we have 48 data + check bits) [[https://www.chegg.com/homework-help/many-check-bits-needed-hamming-error-correction-code-used-de-chapter-5-problem-13p-solution-9780134102061-exc|#]].  Prime candidates for check bits are 2, 4, 6, 8, 10, 12.  This is ideal because there is a check bit on every chunk of data and also it makes the data bits follow a nice pattern of 6 on the inner ring, 12, on the mid ring, and 24 on the outer ring.  It is also nice that the majority of our data is found in the outer ring, and all the check bits are in the inner ring.  So it is unlikely that both are compromised.%0a
host:1611251474=79.141.162.81
author:1611250388=
diff:1611250388:1611250213:=49c49%0a%3c A minimum of 6 check bits are required for data + check bits between 31 and 63 (we have 48 data + check bits) [[https://www.chegg.com/homework-help/many-check-bits-needed-hamming-error-correction-code-used-de-chapter-5-problem-13p-solution-9780134102061-exc|#]].  Prime candidates for check bits are 2, 4, 6, 8, 10, 12.  This is ideal because there is a check bit on every chunk of data and also it makes the data bits follow a nice pattern of 6 on the inner ring, 12, on the mid ring, and 24 on the outer ring.  It is also nice that the majority of our data is found in the outer ring, and all the check bits are in the inner ring.  So it is unlikely that both are compromised.%0a---%0a> A minimum of 6 check bits are required for data + check bits between 31 and 63 (we have 48 data + check bits) [[https://www.chegg.com/homework-help/many-check-bits-needed-hamming-error-correction-code-used-de-chapter-5-problem-13p-solution-9780134102061-exc|#]].  Prime candidates for check bits are 2, 4, 6, 8, 10, 12.  This is ideal because there is a check bit on every chunk of data and also it makes the data bits follow a nice pattern of 6 on the inner ring, 12, on the mid ring, and 24 on the outer ring.%0a
host:1611250388=79.141.162.81
author:1611250213=
diff:1611250213:1611249929:=49c49%0a%3c A minimum of 6 check bits are required for data + check bits between 31 and 63 (we have 48 data + check bits) [[https://www.chegg.com/homework-help/many-check-bits-needed-hamming-error-correction-code-used-de-chapter-5-problem-13p-solution-9780134102061-exc|#]].  Prime candidates for check bits are 2, 4, 6, 8, 10, 12.  This is ideal because there is a check bit on every chunk of data and also it makes the data bits follow a nice pattern of 6 on the inner ring, 12, on the mid ring, and 24 on the outer ring.%0a---%0a> Prime candidates for check bits are 2, 4, 6, 8, 10, 12.  This is ideal because there is a check bit on every chunk of data and also it makes the data bits follow a nice pattern of 6 on the inner ring, 12, on the mid ring, and 24 on the outer ring.%0a
host:1611250213=79.141.162.81
author:1611249929=
diff:1611249929:1611249873:=49c49%0a%3c Prime candidates for check bits are 2, 4, 6, 8, 10, 12.  This is ideal because there is a check bit on every chunk of data and also it makes the data bits follow a nice pattern of 6 on the inner ring, 12, on the mid ring, and 24 on the outer ring.%0a---%0a> Prime candidates for check bits are 12, 2, 4, 10, 8, 6.  This is ideal because there is a check bit on every chunk of data and also it makes the data bits follow a nice pattern of 6 on the inner ring, 12, on the mid ring, and 24 on the outer ring.%0a
host:1611249929=79.141.162.81
author:1611249873=
diff:1611249873:1611249801:=49c49%0a%3c Prime candidates for check bits are 12, 2, 4, 10, 8, 6.  This is ideal because there is a check bit on every chunk of data and also it makes the data bits follow a nice pattern of 6 on the inner ring, 12, on the mid ring, and 24 on the outer ring.%0a---%0a> Prime candidates for check bits are 12, 4, 10, %0a
host:1611249873=79.141.162.81
author:1611249801=
diff:1611249801:1611249782:=
host:1611249801=79.141.162.81
author:1611249782=
diff:1611249782:1611233728:=48,49d47%0a%3c !!!!Check bits%0a%3c Prime candidates for check bits are 12, 4, 10, %0a
host:1611249782=79.141.162.81
author:1611233728=
diff:1611233728:1611233578:=33c33%0a%3c Cyan = 2\\%0a---%0a> Light blue = 2\\%0a
host:1611233728=104.175.54.158
author:1611233578=
diff:1611233578:1611208241:=17c17%0a%3c Chromaton can be rotated any way desired, the processing marks will help the software to orient to count correctly.  Also chromaton can be stacked together with a forward bias, or backward bias when fitting them together like puzzle pieces.  Again this does not effect anything. In the following images a forward stacking bias is used.%0a---%0a> Chromaton can be rotated any way desired, the processing marks will help the software to orient to count correctly.  Also chromaton can be stacked together with a forward bias, or backward bias when fitting them together like puzzle pieces.  Again this does not effect anything.%0a
host:1611233578=104.175.54.158
author:1611208241=
diff:1611208241:1611208098:=144,145d143%0a%3c %0a%3c You may notice the center colors are ordered differently than chromaton and kilochromaton.  This is an improved color scheme and should be applied to all chromaton versions to improve contrast.%0a
host:1611208241=79.141.162.81
author:1611208098=
diff:1611208098:1611206880:=141d140%0a%3c Attach:megachromaton.png%0a
host:1611208098=79.141.162.81
author:1611206880=
diff:1611206880:1611206862:=137c137%0a%3c !!Megachromaton [[#mega]]%0a---%0a> !!Megachromaton%0a
host:1611206880=79.141.162.81
author:1611206862=
diff:1611206862:1611206768:=21c21%0a%3c Our color wheel at the center of chromaton is not perfect for best contrast.  A better version is found in [[#mega|megachromaton]] [[https://www.ecgprod.com/everything-you-know-about-color-is-probably-wrong/|#]].%0a---%0a> Our color wheel at the center of chromaton is not perfect.  A better version is found in [[#mega|megachromaton]] [[https://www.ecgprod.com/everything-you-know-about-color-is-probably-wrong/|#]].%0a
host:1611206862=79.141.162.81
author:1611206768=
diff:1611206768:1611206658:=21c21%0a%3c Our color wheel at the center of chromaton is not perfect.  A better version is found in [[#mega|megachromaton]] [[https://www.ecgprod.com/everything-you-know-about-color-is-probably-wrong/|#]].%0a---%0a> Our color wheel at the center of chromaton is not perfect.  A better version is found in [[#mega|megachromaton]].%0a
host:1611206768=79.141.162.81
author:1611206658=
diff:1611206658:1611201548:=18,21d17%0a%3c %0a%3c Colors determined from complementary and primary colors [[https://www.ecgprod.com/everything-you-know-about-color-is-probably-wrong/|#]]%0a%3c %0a%3c Our color wheel at the center of chromaton is not perfect.  A better version is found in [[#mega|megachromaton]].%0a
host:1611206658=79.141.162.81
author:1611201548=
diff:1611201548:1611201459:=106,108d105%0a%3c %0a%3c !!Kilopentachrome%0a%3c Attach:kilopentachrome.png%0a
host:1611201548=79.141.162.81
author:1611201459=
diff:1611201459:1611201424:=127,129d126%0a%3c %0a%3c !!Kilotrichroma%0a%3c Attach:kilotrichroma.png%0a
host:1611201459=79.141.162.81
author:1611201424=
diff:1611201424:1611201389:=104,105d103%0a%3c !!Kilotetrachrome%0a%3c Attach:kilotetrachrome.png%0a
host:1611201424=79.141.162.81
author:1611201389=
diff:1611201389:1611196271:=97,98d96%0a%3c !!Kilodichrome%0a%3c Attach:kilodichrome.png%0a
host:1611201389=79.141.162.81
author:1611196271=
diff:1611196271:1611196122:=92c92%0a%3c Kilochromaton contain 48 chromaton and thus contains 2,304 base-6 digits or 5,760 bits which is comparable to a version 18 QR code.  Kilochromaton contains 90x90 = 8,100 modules whereas the version 18 QR contains 89x89 or 7,921 modules.  Even though the data capacity per unit has now decreased from QR code, it is expected to be much more robust and faster reading than QR as there is much more empty space in chromaton compared to QR.%0a---%0a> Kilochromaton contain 48 chromaton and thus contains 2,304 base-6 digits or 5,904 bits which is comparable to a version 18 QR code.  Kilochromaton contains 90x90 = 8,100 modules whereas the version 18 QR contains 89x89 or 7,921 modules.  Even though the data capacity per unit has now decreased from QR code, it is expected to be much more robust and faster reading than QR as there is much more empty space in chromaton compared to QR.%0a
host:1611196271=104.175.54.158
author:1611196122=
diff:1611196122:1611195726:=88c88%0a%3c Trichroma contains 30 chromaton and thus contains 30x48 (1,440) base-6 or 30x120 (3,600) binary bits.  This is similar to a version 14 QR code.%0a---%0a> Trichroma contains 30 chromaton and thus contains 30x48 (1,440) base-6 or 30x123 (3,690) binary bits.  This is similar to a version 14 QR code.%0a
host:1611196122=104.175.54.158
author:1611195726=
diff:1611195726:1611195644:=84c84%0a%3c Dichroma contains 18 chromaton and thus contains  18x48 (864) base-6 or 18x120 (2,160) binary bits.  This is similar to a version 10 QR code.%0a---%0a> Dichroma contains 18 chromaton and thus contains  18x48 (864) base-6 or 18x123 (2,214) binary bits.  This is similar to a version 10 QR code.%0a
host:1611195726=104.175.54.158
author:1611195644=
diff:1611195644:1611195600:=80c80%0a%3c Monochroma contains 12 chromaton and thus contains 12x48 (576) base-6 or 12x120 (1,400) binary bits.  This is similar to a version 8 QR code.%0a---%0a> Monochroma contains 12 chromaton and thus contains 12x48 (576) base-6 or 12x123 (1,476) binary bits.  This is similar to a version 8 QR code.%0a
host:1611195644=104.175.54.158
author:1611195600=
diff:1611195600:1611195438:=76c76%0a%3c Nonachrome is nine chromaton and thus has 9x48 (432) base-6 digits or 9x120 (1,080) binary digits.  This is similar to a version 6 QR code.%0a---%0a> Nonachrome is nine chromaton and thus has 9x48 (432) base-6 digits or 9x123 (1,107) binary digits.  This is similar to a version 6 QR code.%0a
host:1611195600=104.175.54.158
author:1611195438=
diff:1611195438:1611195379:=54c54%0a%3c Trichrome can encode for a private key which is handy for transferring cryptocollectibles [[https://www.dummies.com/software/other-software/bitcoin-public-private-keys/|#]].  It appears that base-58 keys are 51 units long.  Base-6 keys should be 99 units.%0a---%0a> Trichrome can encode for a private key which is handy for transferring cryptocollectibles [[https://www.dummies.com/software/other-software/bitcoin-public-private-keys/|#]].  It appears that base-58 keys are 51 units long, which is 74 units in hexadecimal and 115 units in base-6.%0a
host:1611195438=104.175.54.158
author:1611195379=
diff:1611195379:1611194782:=70c70%0a%3c Chroma is 7 chromaton and thus contains 336 base-6 digits or 840 bits, roughly equivalent to a version 5 QR code.%0a---%0a> Chroma is 7 chromaton and thus contains 336 base-6 digits or 861 bits, roughly equivalent to a version 5 QR code.%0a
host:1611195379=104.175.54.158
author:1611194782=
diff:1611194782:1611194740:=65c65%0a%3c Hexachrome contains six chromaton and thus has 6x48 (288 digits) base-6 or 6x120 (720 digits) bits.  This is as bit more than a version 4 QR code.%0a---%0a> Hexachrome contains six chromaton and thus has 6x48 (288 digits) base-6 or 6x123 (738 digits) bits.  This is as bit more than a version 4 QR code.%0a
host:1611194782=104.175.54.158
author:1611194740=
diff:1611194740:1611194715:=61c61%0a%3c Pentachrome contains six chromaton and thus has 5x48 (240 digits) base-6 or 5x120 (600 digits) bits. This is a bit less than a version 4 QR code.%0a---%0a> Pentachrome contains six chromaton and thus has 5x48 (240 digits) base-6 or 5x123 (615 digits) bits. This is a bit less than a version 4 QR code.%0a
host:1611194740=104.175.54.158
author:1611194715=
diff:1611194715:1611194688:=57c57%0a%3c Tetrachrome contains four chromaton and thus has 4x48 (192 digits) base-6 or 4x120 (480 digits) bits. This is a bit more than a version 3 QR code.%0a---%0a> Tetrachrome contains four chromaton and thus has 4x48 (192 digits) base-6 or 4x123 (492 digits) bits. This is a bit more than a version 3 QR code.%0a
host:1611194715=104.175.54.158
author:1611194688=
diff:1611194688:1611194669:=50c50%0a%3c Trichrome contains 3 chromaton which is 144 base-6 digits or 360 binary digits (bits). This capacity is between version 2 and 3 QR code.%0a---%0a> Trichrome contains 3 chromaton which is 144 base-6 digits or 369 binary digits (bits). This capacity is between version 2 and 3 QR code.%0a
host:1611194688=104.175.54.158
author:1611194669=
diff:1611194669:1611194634:=45c45%0a%3c Dichrome contains 2 chromaton and thus has 2x48 (96 digits) base-6 or 2x120 (240 digits) bits. This is a bit less than a version 2 QR code.%0a---%0a> Dichrome contains 2 chromaton and thus has 2x48 (96 digits) base-6 or 2x123 (246 digits) bits. This is a bit less than a version 2 QR code.%0a
host:1611194669=104.175.54.158
author:1611194634=
diff:1611194634:1611193594:=23c23%0a%3c Chromaton contains 48 base-6 digits which is 120 bits.  This chromaton is the smallest repeating unit, and thus is like the "atom" of the chromaton code system.  Chromaton is only 11 units long and 90 total units, which is roughly half the size of the smallest QR code; version 1 which has 21x21 or 441 units.  In spite of this chromaton contains around 3/4 the data of a version 1 QR code while having only 20%25 of the units.[[https://www.qrcode.com/en/about/version.html|#]]%0a---%0a> Chromaton contains 48 base-6 digits which is 123 bits.  This chromaton is the smallest repeating unit, and thus is like the "atom" of the chromaton code system.  Chromaton is only 11 units long and 90 total units, which is roughly half the size of the smallest QR code; version 1 which has 21x21 or 441 units.  In spite of this chromaton contains around 3/4 the data of a version 1 QR code while having only 20%25 of the units.[[https://www.qrcode.com/en/about/version.html|#]]%0a
host:1611194634=104.175.54.158
author:1611193594=
diff:1611193594:1611191757:=54c54%0a%3c Trichrome can encode for a private key which is handy for transferring cryptocollectibles [[https://www.dummies.com/software/other-software/bitcoin-public-private-keys/|#]].  It appears that base-58 keys are 51 units long, which is 74 units in hexadecimal and 115 units in base-6.%0a---%0a> Trichrome can encode for a private key which is handy for transferring cryptocollectibles [[https://www.dummies.com/software/other-software/bitcoin-public-private-keys/|#]].%0a
host:1611193594=104.175.54.158
author:1611191757=
diff:1611191757:1611184497:=132,133d131%0a%3c %0a%3c Diceware uses dice to create random numbers in base-6 [[https://en.m.wikipedia.org/wiki/Diceware|#]]%0a\ No newline at end of file%0a
host:1611191757=104.175.54.158
author:1611184497=
diff:1611184497:1611184431:=127,128d126%0a%3c %0a%3c Megachromaton can encode up to 1,107 private keys!%0a
host:1611184497=79.141.162.81
author:1611184431=
diff:1611184431:1611184365:=122c122%0a%3c Kilodichroma can encode 415 private keys.%0a---%0a> %0a
host:1611184431=79.141.162.81
author:1611184365=
diff:1611184365:1611184283:=118c118%0a%3c Kilomonochroma can encode 276 private keys.%0a---%0a> %0a
host:1611184365=79.141.162.81
author:1611184283=
diff:1611184283:1611184256:=114c114%0a%3c Kilononachrome can encode 207 private keys.%0a---%0a> Kilononachroma can encode 207 private keys.%0a
host:1611184283=79.141.162.81
author:1611184256=
diff:1611184256:1611184166:=114c114%0a%3c Kilononachroma can encode 207 private keys.%0a---%0a> %0a
host:1611184256=79.141.162.81
author:1611184166=
diff:1611184166:1611184117:=110c110%0a%3c Kilochroma can encode 161 private keys.%0a---%0a> %0a
host:1611184166=79.141.162.81
author:1611184117=
diff:1611184117:1611184048:=105d104%0a%3c Kilohexachrome can encode up to 138 private keys.%0a
host:1611184117=79.141.162.81
author:1611184048=
diff:1611184048:1611183960:=100c100%0a%3c It is read starting at the top and going clockwise. Kilotrichrome encodes 69 private keys.%0a---%0a> It is read starting at the top and going clockwise.%0a
host:1611184048=79.141.162.81
author:1611183960=
diff:1611183960:1611183903:=95d94%0a%3c Kilochromaton can encode for 23 private keys.%0a
host:1611183960=79.141.162.81
author:1611183903=
diff:1611183903:1611183860:=90d89%0a%3c Trichroma can encode 14 private keys.%0a
host:1611183903=79.141.162.81
author:1611183860=
diff:1611183860:1611183800:=86c86%0a%3c Dichroma can encode for 8 private keys.%0a---%0a> %0a
host:1611183860=79.141.162.81
author:1611183800=
diff:1611183800:1611183738:=82c82%0a%3c Monochroma can encode for 5 private keys.%0a---%0a> %0a
host:1611183800=79.141.162.81
author:1611183738=
diff:1611183738:1611183704:=78c78%0a%3c Nonachrome can encode for 4 private keys.%0a---%0a> Nonachrome can ecode for two full cryptocollectibles including public and private keys.%0a
host:1611183738=79.141.162.81
author:1611183704=
diff:1611183704:1611183639:=74d73%0a%3c Chroma can encode for 3 private keys.%0a
host:1611183704=79.141.162.81
author:1611183639=
diff:1611183639:1611183593:=54c54%0a%3c Trichrome can encode for a private key which is handy for transferring cryptocollectibles [[https://www.dummies.com/software/other-software/bitcoin-public-private-keys/|#]].%0a---%0a> Trichrome can encode for a private key which is handy for transferring cryptocollectibles.%0a
host:1611183639=79.141.162.81
author:1611183593=
diff:1611183593:1611183465:=63d62%0a%3c Pentachrome can encode for 2 private keys.%0a
host:1611183593=79.141.162.81
author:1611183465=
diff:1611183465:1611183421:=66c66%0a%3c %0a---%0a> Since a public and private key pair is 512 bits [[https://www.dummies.com/software/other-software/bitcoin-public-private-keys/|#]], this or pentachrome would likely be the form of swapping crypto-collectibles.%0a
host:1611183465=79.141.162.81
author:1611183421=
diff:1611183421:1611183300:=53,54d52%0a%3c %0a%3c Trichrome can encode for a private key which is handy for transferring cryptocollectibles.%0a
host:1611183421=79.141.162.81
author:1611183300=
diff:1611183300:1611183184:=74c74%0a%3c Nonachrome can ecode for two full cryptocollectibles including public and private keys.%0a---%0a> %0a
host:1611183300=79.141.162.81
author:1611183184=
diff:1611183184:1611175878:=64c64%0a%3c Since a public and private key pair is 512 bits [[https://www.dummies.com/software/other-software/bitcoin-public-private-keys/|#]], this or pentachrome would likely be the form of swapping crypto-collectibles.%0a---%0a> Since a public and private key pair is 512 bits [[https://www.dummies.com/software/other-software/bitcoin-public-private-keys/|#]], this would likely be the form of swapping crypto-collectibles.%0a
host:1611183184=79.141.162.81
author:1611175878=
diff:1611175878:1611175857:=59c59%0a%3c Pentachrome contains six chromaton and thus has 5x48 (240 digits) base-6 or 5x123 (615 digits) bits. This is a bit less than a version 4 QR code.%0a---%0a> Hexachrome contains six chromaton and thus has 5x48 (240 digits) base-6 or 5x123 (615 digits) bits. This is a bit less than a version 4 QR code.%0a
host:1611175878=79.141.162.81
author:1611175857=
diff:1611175857:1611175840:=55c55%0a%3c Tetrachrome contains four chromaton and thus has 4x48 (192 digits) base-6 or 4x123 (492 digits) bits. This is a bit more than a version 3 QR code.%0a---%0a> Hexachrome contains four chromaton and thus has 4x48 (192 digits) base-6 or 4x123 (492 digits) bits. This is a bit more than a version 3 QR code.%0a
host:1611175857=79.141.162.81
author:1611175840=
diff:1611175840:1611175820:=45c45%0a%3c Dichrome contains 2 chromaton and thus has 2x48 (96 digits) base-6 or 2x123 (246 digits) bits. This is a bit less than a version 2 QR code.%0a---%0a> Hexachrome contains 2 chromaton and thus has 2x48 (96 digits) base-6 or 2x123 (246 digits) bits. This is a bit less than a version 2 QR code.%0a
host:1611175840=79.141.162.81
author:1611175820=
diff:1611175820:1611175801:=55c55%0a%3c Hexachrome contains four chromaton and thus has 4x48 (192 digits) base-6 or 4x123 (492 digits) bits. This is a bit more than a version 3 QR code.%0a---%0a> Hexachrome contains six chromaton and thus has 4x48 (192 digits) base-6 or 4x123 (492 digits) bits. This is a bit more than a version 3 QR code.%0a
host:1611175820=79.141.162.81
author:1611175801=
diff:1611175801:1611175727:=45d44%0a%3c Hexachrome contains 2 chromaton and thus has 2x48 (96 digits) base-6 or 2x123 (246 digits) bits. This is a bit less than a version 2 QR code.%0a
host:1611175801=79.141.162.81
author:1611175727=
diff:1611175727:1611175651:=54d53%0a%3c Hexachrome contains six chromaton and thus has 4x48 (192 digits) base-6 or 4x123 (492 digits) bits. This is a bit more than a version 3 QR code.%0a
host:1611175727=79.141.162.81
author:1611175651=
diff:1611175651:1611175604:=60c60%0a%3c Hexachrome contains six chromaton and thus has 6x48 (288 digits) base-6 or 6x123 (738 digits) bits.  This is as bit more than a version 4 QR code.%0a---%0a> Hexachrome contains six chromaton and thus has 6x48 (288 digits) base-6 or 6x123 (738 digits) bits.  This is similar to a version 4 QR code.%0a
host:1611175651=79.141.162.81
author:1611175604=
diff:1611175604:1611175508:=57d56%0a%3c Hexachrome contains six chromaton and thus has 5x48 (240 digits) base-6 or 5x123 (615 digits) bits. This is a bit less than a version 4 QR code.%0a
host:1611175604=79.141.162.81
author:1611175508=
diff:1611175508:1611175024:=81c81%0a%3c Trichroma contains 30 chromaton and thus contains 30x48 (1,440) base-6 or 30x123 (3,690) binary bits.  This is similar to a version 14 QR code.%0a---%0a> Trichroma contains 30 chromaton and thus contains 30x48 (1,440) base-6 or 30x123 (3,690) binary bits.%0a
host:1611175508=79.141.162.81
author:1611175024=
diff:1611175024:1611174966:=81c81%0a%3c Trichroma contains 30 chromaton and thus contains 30x48 (1,440) base-6 or 30x123 (3,690) binary bits.%0a---%0a> Trichroma contains 30 chromaton and thus contains 30x48 base-6 or 30x123 binary bits.%0a
host:1611175024=79.141.162.81
author:1611174966=
diff:1611174966:1611174814:=81d80%0a%3c Trichroma contains 30 chromaton and thus contains 30x48 base-6 or 30x123 binary bits.%0a
host:1611174966=79.141.162.81
author:1611174814=
diff:1611174814:1611173913:=80,81d79%0a%3c !!Trichroma%0a%3c Attach:trichroma.png%0a
host:1611174814=79.141.162.81
author:1611173913=
diff:1611173913:1611173397:=56,57d55%0a%3c !!Pentachrome%0a%3c Attach:pentachrome.png%0a
host:1611173913=79.141.162.81
author:1611173397=
diff:1611173397:1611173338:=47c47,48%0a%3c %0a---%0a> !!Tetrachrome%0a> Attach:tetrachrome.png%0a52,54d52%0a%3c %0a%3c !!Tetrachrome%0a%3c Attach:tetrachrome.png%0a
host:1611173397=79.141.162.81
author:1611173338=
diff:1611173338:1611169745:=44,48d43%0a%3c !!Dichrome%0a%3c Attach:dichrome.png%0a%3c %0a%3c !!Tetrachrome%0a%3c Attach:tetrachrome.png%0a
host:1611173338=79.141.162.81
author:1611169745=
diff:1611169745:1611168340:=52d51%0a%3c Since a public and private key pair is 512 bits [[https://www.dummies.com/software/other-software/bitcoin-public-private-keys/|#]], this would likely be the form of swapping crypto-collectibles.%0a
host:1611169745=104.175.54.158
author:1611168340=
diff:1611168340:1611167934:=10c10%0a%3c (:Archive:[[https://archive.is/BQ9or|Archive.is]], [[https://web.archive.org/web/20210120025440/http://www.naturewiki.org/wiki/pmwiki.php/NatureWiki/Chromaton|Archive.org]]:)%0a---%0a> (:Archive:[[https://archive.is/hQPLP|Archive.is]], [[https://web.archive.org/web/20210120025440/http://www.naturewiki.org/wiki/pmwiki.php/NatureWiki/Chromaton|Archive.org]]:)%0a
host:1611168340=104.175.54.158
author:1611167934=
diff:1611167934:1611167743:=
host:1611167934=104.175.54.158
author:1611167743=
diff:1611167743:1611167707:=52a53,56%0a> !!Nonachrome%0a> Nonachrome is nine chromaton and thus has 9x48 (432) base-6 digits or 9x123 (1,107) binary digits.  This is similar to a version 6 QR code.%0a> Attach:nonachrome.png%0a> %0a57,60d60%0a%3c %0a%3c !!Nonachrome%0a%3c Nonachrome is nine chromaton and thus has 9x48 (432) base-6 digits or 9x123 (1,107) binary digits.  This is similar to a version 6 QR code.%0a%3c Attach:nonachrome.png%0a
diff:1611167743:1611167743:=
host:1611167743=104.175.54.158
author:1611167707=
diff:1611167707:1611167485:=43a44,53%0a> !!Kilochromaton[[#kilochromaton]]%0a> Kilochromaton contain 48 chromaton and thus contains 2,304 base-6 digits or 5,904 bits which is comparable to a version 18 QR code.  Kilochromaton contains 90x90 = 8,100 modules whereas the version 18 QR contains 89x89 or 7,921 modules.  Even though the data capacity per unit has now decreased from QR code, it is expected to be much more robust and faster reading than QR as there is much more empty space in chromaton compared to QR.%0a> Attach:kilochromaton.png%0a> The segments are numbered in the same way as [[#chromatonlabel|chromaton]].%0a> %0a> !!Megachromaton%0a> Megachromaton contains 48 kilochromaton and thus contains 110,592 base-6 digits or 283,392 bits which is roughly 12x the data capacity of the largest QR code; version 40.  Also it is over 50%25 more storage than version 61 iQR code which stores 171,727 bits in 422x422 modules.%0a> %0a> Megachromaton contains 90x90x90 units (729,000) compared to iQR which contains 422x422 units (178,084).  Again the megachromaton holds 50%25 more data than the version 61 iQR code and likely would be read and processed even faster than the iQR.%0a> %0a48c58,62%0a%3c %0a---%0a> !!Kilotrichrome%0a> Kilotrichrome contains 3 [[#kilochromaton|kilochromaton]] which is 6,912 base-6 digits or 17,712 binary bits.  This is similar to a version 34 QR code.%0a> Attach:kilotrichrome.png%0a> It is read starting at the top and going clockwise.%0a> %0a52a67,70%0a> !!Kilohexachrome%0a> Kilohexachrome contains 6 kilochromaton.  This means it has 2304x6 (13,824) base-6 or 5904x6 (35,424) binary bits.  This is over 50%25 more data than the largest QR code, version 40.%0a> Attach:kilohexachrome.png%0a> %0a56a75,77%0a> !!Kilononachrome%0a> Kilononachrome is 9 kilochromaton and thus has 9x2304 (20,736) base-6 digits or 9x5904 (53,136) binary digits.  This is more than double the largest QR code, version 40.%0a> Attach:kilononachrome.png%0a61a83,86%0a> !!Kilochroma%0a> Kilochroma contains 7 [[#kilochromaton|kilochromaton]] and thus contains 16,128 base-6 digits or 41,328 binary digits which is nearly double the data of the largest QR code; version 40.%0a> Attach:kilochroma.png%0a> %0a65a91,94%0a> !!Kilomonochroma%0a> Kilomonochroma contains 12 kilochromaton and thus contains 12x2304 (27,648) base-6 or 12x5904 (70,848) binary bits.  This is roughly 3x more than the biggest QR code version 40.  Contains less than half the largest iQR code, version 61.%0a> Attach:kilomonochroma.png%0a> %0a70,95d98%0a%3c !!Kilochromaton[[#kilochromaton]]%0a%3c Kilochromaton contain 48 chromaton and thus contains 2,304 base-6 digits or 5,904 bits which is comparable to a version 18 QR code.  Kilochromaton contains 90x90 = 8,100 modules whereas the version 18 QR contains 89x89 or 7,921 modules.  Even though the data capacity per unit has now decreased from QR code, it is expected to be much more robust and faster reading than QR as there is much more empty space in chromaton compared to QR.%0a%3c Attach:kilochromaton.png%0a%3c The segments are numbered in the same way as [[#chromatonlabel|chromaton]].%0a%3c %0a%3c !!Kilotrichrome%0a%3c Kilotrichrome contains 3 [[#kilochromaton|kilochromaton]] which is 6,912 base-6 digits or 17,712 binary bits.  This is similar to a version 34 QR code.%0a%3c Attach:kilotrichrome.png%0a%3c It is read starting at the top and going clockwise.%0a%3c %0a%3c !!Kilohexachrome%0a%3c Kilohexachrome contains 6 kilochromaton.  This means it has 2304x6 (13,824) base-6 or 5904x6 (35,424) binary bits.  This is over 50%25 more data than the largest QR code, version 40.%0a%3c Attach:kilohexachrome.png%0a%3c %0a%3c !!Kilochroma%0a%3c Kilochroma contains 7 [[#kilochromaton|kilochromaton]] and thus contains 16,128 base-6 digits or 41,328 binary digits which is nearly double the data of the largest QR code; version 40.%0a%3c Attach:kilochroma.png%0a%3c %0a%3c !!Kilononachrome%0a%3c Kilononachrome is 9 kilochromaton and thus has 9x2304 (20,736) base-6 digits or 9x5904 (53,136) binary digits.  This is more than double the largest QR code, version 40.%0a%3c Attach:kilononachrome.png%0a%3c %0a%3c !!Kilomonochroma%0a%3c Kilomonochroma contains 12 kilochromaton and thus contains 12x2304 (27,648) base-6 or 12x5904 (70,848) binary bits.  This is roughly 3x more than the biggest QR code version 40.  Contains less than half the largest iQR code, version 61.%0a%3c Attach:kilomonochroma.png%0a%3c %0a99,103d101%0a%3c %0a%3c !!Megachromaton%0a%3c Megachromaton contains 48 kilochromaton and thus contains 110,592 base-6 digits or 283,392 bits which is roughly 12x the data capacity of the largest QR code; version 40.  Also it is over 50%25 more storage than version 61 iQR code which stores 171,727 bits in 422x422 modules.%0a%3c %0a%3c Megachromaton contains 90x90x90 units (729,000) compared to iQR which contains 422x422 units (178,084).  Again the megachromaton holds 50%25 more data than the version 61 iQR code and likely would be read and processed even faster than the iQR.%0a
host:1611167707=104.175.54.158
author:1611167485=
diff:1611167485:1611167423:=76c76%0a%3c Kilononachrome is 9 kilochromaton and thus has 9x2304 (20,736) base-6 digits or 9x5904 (53,136) binary digits.  This is more than double the largest QR code, version 40.%0a---%0a> Kilononachrome is 9 kilochromaton and thus has 9x2304 (20,736) base-6 digits or 9x5904 (53,136) binary digits.  This is similar to a version QR Code.%0a
host:1611167485=104.175.54.158
author:1611167423=
diff:1611167423:1611167360:=76c76%0a%3c Kilononachrome is 9 kilochromaton and thus has 9x2304 (20,736) base-6 digits or 9x5904 (53,136) binary digits.  This is similar to a version QR Code.%0a---%0a> Kilononachrome is 9 kilochromaton and thus has 9x (20,736) base-6 digits or 9x () binary digits.  This is similar to a version QR Code.%0a
host:1611167423=104.175.54.158
author:1611167360=
diff:1611167360:1611167293:=76c76%0a%3c Kilononachrome is 9 kilochromaton and thus has 9x (20,736) base-6 digits or 9x () binary digits.  This is similar to a version QR Code.%0a---%0a> Kilononachrome is 9 kilochromaton and thus has 9x () base-6 digits or 9x () binary digits.  This is similar to a version QR Code.%0a
host:1611167360=104.175.54.158
author:1611167293=
diff:1611167293:1611166309:=74,77d73%0a%3c %0a%3c !!Kilononachrome%0a%3c Kilononachrome is 9 kilochromaton and thus has 9x () base-6 digits or 9x () binary digits.  This is similar to a version QR Code.%0a%3c Attach:kilononachrome.png%0a
host:1611167293=104.175.54.158
author:1611166309=
diff:1611166309:1611166137:=72d71%0a%3c Nonachrome is nine chromaton and thus has 9x48 (432) base-6 digits or 9x123 (1,107) binary digits.  This is similar to a version 6 QR code.%0a
host:1611166309=104.175.54.158
author:1611166137=
diff:1611166137:1611165307:=70,72d69%0a%3c %0a%3c !!Nonachrome%0a%3c Attach:nonachrome.png%0a
host:1611166137=104.175.54.158
author:1611165307=
diff:1611165307:1611165250:=92c92%0a%3c Kilomonochroma contains 18 kilochromaton and thus contains 18x2304 (41,472) base-6 or 18x5904 (106,272) binary bits.  This is roughly 5x more data than a version 40 QR code, the largest.  Contains nearly 2/3 the data of a version 61 iQR code, the largest.%0a---%0a> Kilomonochroma contains 18 kilochromaton and thus contains 18x2304 (41,472) base-6 or 18x5904 (106,272) binary bits.  This is roughly 5x more data than a version 40 QR code, the largest.  %0a
host:1611165307=104.175.54.158
author:1611165250=
diff:1611165250:1611165145:=84c84%0a%3c Kilomonochroma contains 12 kilochromaton and thus contains 12x2304 (27,648) base-6 or 12x5904 (70,848) binary bits.  This is roughly 3x more than the biggest QR code version 40.  Contains less than half the largest iQR code, version 61.%0a---%0a> Kilomonochroma contains 12 kilochromaton and thus contains 12x2304 (27,648) base-6 or 12x5904 (70,848) binary bits.  This is roughly 3x more than the biggest QR code version 40.%0a
host:1611165250=104.175.54.158
author:1611165145=
diff:1611165145:1611165084:=92c92%0a%3c Kilomonochroma contains 18 kilochromaton and thus contains 18x2304 (41,472) base-6 or 18x5904 (106,272) binary bits.  This is roughly 5x more data than a version 40 QR code, the largest.  %0a---%0a> Kilomonochroma contains 18 kilochromaton and thus contains 18x2304 (41,472) base-6 or 18x5904 (106,272) binary bits.%0a
host:1611165145=104.175.54.158
author:1611165084=
diff:1611165084:1611165034:=23c23%0a%3c Chromaton contains 48 base-6 digits which is 123 bits.  This chromaton is the smallest repeating unit, and thus is like the "atom" of the chromaton code system.  Chromaton is only 11 units long and 90 total units, which is roughly half the size of the smallest QR code; version 1 which has 21x21 or 441 units.  In spite of this chromaton contains around 3/4 the data of a version 1 QR code while having only 20%25 of the units.[[https://www.qrcode.com/en/about/version.html|#]]%0a---%0a> Chromaton contains 48 base-6 digits which is 123 bits.  This chromaton is the smallest repeating unit, and thus is like the "atom" of the chromaton code system.  Chromaton is only 11 units long and 90 total units, which is roughly half the size of the smallest QR code; version 1 which has 21x21 or 441 units.  In spite of this chromaton contains around 3/4 the data of the QR code with only 20%25 of the units.[[https://www.qrcode.com/en/about/version.html|#]]%0a
host:1611165084=104.175.54.158
author:1611165034=
diff:1611165034:1611164994:=64c64%0a%3c Hexachrome contains six chromaton and thus has 6x48 (288 digits) base-6 or 6x123 (738 digits) bits.  This is similar to a version 4 QR code.%0a---%0a> Hexachrome contains six chromaton and thus has 6x48 (288 digits) base-6 or 6x123 (738 digits) bits%0a
host:1611165034=104.175.54.158
author:1611164994=
diff:1611164994:1611164937:=68c68%0a%3c Kilohexachrome contains 6 kilochromaton.  This means it has 2304x6 (13,824) base-6 or 5904x6 (35,424) binary bits.  This is over 50%25 more data than the largest QR code, version 40.%0a---%0a> Kilohexachrome contains 6 kilochromaton.  This means it has 2304x6 (13,824) base-6 or 5904x6 (35,424) binary bits.%0a
host:1611164994=104.175.54.158
author:1611164937=
diff:1611164937:1611164902:=80c80%0a%3c Monochroma contains 12 chromaton and thus contains 12x48 (576) base-6 or 12x123 (1,476) binary bits.  This is similar to a version 8 QR code.%0a---%0a> Monochroma contains 12 chromaton and thus contains 12x48 (576) base-6 or 12x123 (1,476) binary bits.%0a
host:1611164937=104.175.54.158
author:1611164902=
diff:1611164902:1611164854:=84c84%0a%3c Kilomonochroma contains 12 kilochromaton and thus contains 12x2304 (27,648) base-6 or 12x5904 (70,848) binary bits.  This is roughly 3x more than the biggest QR code version 40.%0a---%0a> Kilomonochroma contains 12 kilochromaton and thus contains 12x2304 (27,648) base-6 or 12x5904 (70,848) binary bits.%0a
host:1611164902=104.175.54.158
author:1611164854=
diff:1611164854:1611164720:=88c88%0a%3c Dichroma contains 18 chromaton and thus contains  18x48 (864) base-6 or 18x123 (2,214) binary bits.  This is similar to a version 10 QR code.%0a---%0a> Dichroma contains 18 chromaton and thus contains  18x48 (864) base-6 or 18x123 (2,214) binary bits.%0a
host:1611164854=104.175.54.158
author:1611164720=
diff:1611164720:1611164585:=92d91%0a%3c Kilomonochroma contains 18 kilochromaton and thus contains 18x2304 (41,472) base-6 or 18x5904 (106,272) binary bits.%0a94d92%0a%3c %0a
host:1611164720=104.175.54.158
author:1611164585=
diff:1611164585:1611164583:=
host:1611164585=104.175.54.158
author:1611164583=
diff:1611164583:1611164367:=84d83%0a%3c Kilomonochroma contains 12 kilochromaton and thus contains 12x2304 (27,648) base-6 or 12x5904 (70,848) binary bits.%0a88d86%0a%3c Dichroma contains 18 chromaton and thus contains  18x48 (864) base-6 or 18x123 (2,214) binary bits.%0a
host:1611164583=104.175.54.158
author:1611164367=
diff:1611164367:1611164056:=43d42%0a%3c %0a68d66%0a%3c Kilohexachrome contains 6 kilochromaton.  This means it has 2304x6 (13,824) base-6 or 5904x6 (35,424) binary bits.%0a80d77%0a%3c Monochroma contains 12 chromaton and thus contains 12x48 (576) base-6 or 12x123 (1,476) binary bits.%0a
host:1611164367=104.175.54.158
author:1611164056=
diff:1611164056:1611163428:=63d62%0a%3c Hexachrome contains six chromaton and thus has 6x48 (288 digits) base-6 or 6x123 (738 digits) bits%0a
host:1611164056=104.175.54.158
author:1611163428=
diff:1611163428:1611163213:=51c51%0a%3c Megachromaton contains 90x90x90 units (729,000) compared to iQR which contains 422x422 units (178,084).  Again the megachromaton holds 50%25 more data than the version 61 iQR code and likely would be read and processed even faster than the iQR.%0a---%0a> Megachromaton contains 90x90x90 units (729,000) compared to iQR which contains 178,084 units.  Again the megachromaton holds 50%25 more data than the version 61 iQR code and likely would be read and processed even faster than the iQR.%0a
host:1611163428=104.175.54.158
author:1611163213=
diff:1611163213:1611162064:=61,66d60%0a%3c %0a%3c !!Hexachrome%0a%3c Attach:hexachrome.png%0a%3c %0a%3c !!Kilohexachrome%0a%3c Attach:kilohexachrome.png%0a
host:1611163213=104.175.54.158
author:1611162064=
diff:1611162064:1611159851:=70,80d69%0a%3c !!Monochroma%0a%3c Attach:monochroma.png%0a%3c %0a%3c !!Kilomonochroma%0a%3c Attach:kilomonochroma.png%0a%3c %0a%3c !!Dichroma%0a%3c Attach:dichroma.png%0a%3c %0a%3c !!Kilodichroma%0a%3c Attach:kilodichroma.png%0a
host:1611162064=104.175.54.158
author:1611159851=
diff:1611159851:1611159629:=50,51d49%0a%3c %0a%3c Megachromaton contains 90x90x90 units (729,000) compared to iQR which contains 178,084 units.  Again the megachromaton holds 50%25 more data than the version 61 iQR code and likely would be read and processed even faster than the iQR.%0a
host:1611159851=104.175.54.158
author:1611159629=
diff:1611159629:1611159563:=44c44%0a%3c Kilochromaton contain 48 chromaton and thus contains 2,304 base-6 digits or 5,904 bits which is comparable to a version 18 QR code.  Kilochromaton contains 90x90 = 8,100 modules whereas the version 18 QR contains 89x89 or 7,921 modules.  Even though the data capacity per unit has now decreased from QR code, it is expected to be much more robust and faster reading than QR as there is much more empty space in chromaton compared to QR.%0a---%0a> Kilochromaton contain 48 chromaton and thus contains 2,304 base-6 digits or 5,904 bits which is comparable to a version 18 QR code.  Kilochromaton contains 90x90 = 8,100 modules whereas the version 18 QR contains 89x89 or 7,921 modules.%0a
host:1611159629=104.175.54.158
author:1611159563=
diff:1611159563:1611159537:=44c44%0a%3c Kilochromaton contain 48 chromaton and thus contains 2,304 base-6 digits or 5,904 bits which is comparable to a version 18 QR code.  Kilochromaton contains 90x90 = 8,100 modules whereas the version 18 QR contains 89x89 or 7,921 modules.%0a---%0a> Kilochromaton contain 48 chromaton and thus contains 2,304 base-6 digits or 5,904 bits which is comparable to a version 18 QR code.  Kilochromaton contains 90x90 = 8,100 modules whereas the version 18 QR contains 89x89 or 7921 modules.%0a
host:1611159563=104.175.54.158
author:1611159537=
diff:1611159537:1611159382:=23c23%0a%3c Chromaton contains 48 base-6 digits which is 123 bits.  This chromaton is the smallest repeating unit, and thus is like the "atom" of the chromaton code system.  Chromaton is only 11 units long and 90 total units, which is roughly half the size of the smallest QR code; version 1 which has 21x21 or 441 units.  In spite of this chromaton contains around 3/4 the data of the QR code with only 20%25 of the units.[[https://www.qrcode.com/en/about/version.html|#]]%0a---%0a> Chromaton contains 48 base-6 digits which is 123 bits.  This chromaton is the smallest repeating unit, and thus is like the "atom" of the chromaton code system.  Chromaton is only 11 units long, which is roughly half the size of the smallest QR code; version 1 however it contains around 3/4 the data of the QR code [[https://www.qrcode.com/en/about/version.html|#]]%0a
host:1611159537=104.175.54.158
author:1611159382=
diff:1611159382:1611159114:=44c44%0a%3c Kilochromaton contain 48 chromaton and thus contains 2,304 base-6 digits or 5,904 bits which is comparable to a version 18 QR code.  Kilochromaton contains 90x90 = 8,100 modules whereas the version 18 QR contains 89x89 or 7921 modules.%0a---%0a> Kilochromaton contain 48 chromaton and thus contains 2,304 base-6 digits or 5,904 bits which is comparable to a version 18 QR code.%0a
host:1611159382=104.175.54.158
author:1611159114=
diff:1611159114:1611158440:=49c49%0a%3c Megachromaton contains 48 kilochromaton and thus contains 110,592 base-6 digits or 283,392 bits which is roughly 12x the data capacity of the largest QR code; version 40.  Also it is over 50%25 more storage than version 61 iQR code which stores 171,727 bits in 422x422 modules.%0a---%0a> Megachromaton contains 48 kilochromaton and thus contains 110,592 base-6 digits or 283,392 bits which is roughly 12x the data capacity of the largest QR code; version 40.%0a
host:1611159114=104.175.54.158
author:1611158440=
diff:1611158440:1611158351:=54c54%0a%3c It is read starting at the top and going clockwise.%0a---%0a> %0a
host:1611158440=104.175.54.158
author:1611158351=
diff:1611158351:1611158333:=39c39%0a%3c The data is read in a spiral starting towards the center and working outwards clockwise.  This makes it easily human decodable/readable which is imperative and is not accomplished with any other QR like code.%0a---%0a> The data is read in a spiral starting towards the center and working outwards clockwise.  This makes it human decodable/readable which is imperative and is not accomplished with any other QR like code.%0a
host:1611158351=104.175.54.158
author:1611158333=
diff:1611158333:1611158190:=39c39%0a%3c The data is read in a spiral starting towards the center and working outwards clockwise.  This makes it human decodable/readable which is imperative and is not accomplished with any other QR like code.%0a---%0a> The data is read in a spiral starting towards the center and working outwards clockwise.%0a
host:1611158333=104.175.54.158
author:1611158190=
diff:1611158190:1611157369:=18,20d17%0a%3c %0a%3c !!!Name%0a%3c Chromaton was originally intended for a cryptocurrency but finds a better use in data storage.  From the beginning the name meant the smallest unit of color.  Here that fits as the chromaton is the smallest repeating unit and it contains color.  Also it so happens the data storage in chromaton is similar to data storage in chromatin in DNA.  This was not intended, neither the similarity of the name nor the DNA-like storage in the chromaton unit.  The chromaton unit was simply designed as a hexagonal spiral with black and white to break up the data for easier processing.  Even the fact that it scales infinitely was not realized until halfway through the designing.%0a
host:1611158190=104.175.54.158
author:1611157369=
diff:1611157369:1611157303:=59c59%0a%3c It is read starting at the top and going clockwise, with the center the last.%0a---%0a> It is read starting at the top and going clockwise.%0a
host:1611157369=104.175.54.158
author:1611157303=
diff:1611157303:1611157273:=59d58%0a%3c It is read starting at the top and going clockwise.%0a
host:1611157303=104.175.54.158
author:1611157273=
diff:1611157273:1611157230:=55c55%0a%3c It is read starting at the top and going clockwise.%0a---%0a> %0a
host:1611157273=104.175.54.158
author:1611157230=
diff:1611157230:1611157214:=43c43%0a%3c The segments are numbered in the same way as [[#chromatonlabel|chromaton]].%0a---%0a> The segments are numbered in the same way as [[#chromaton|chromaton]].%0a
host:1611157230=104.175.54.158
author:1611157214=
diff:1611157214:1611157182:=19c19%0a%3c !!Chromaton[[#chromaton]]%0a---%0a> !!Chromaton%0a34c34%0a%3c !!!Chromaton reading[[#chromatonlabel]]%0a---%0a> !!!Chromaton reading%0a
host:1611157214=104.175.54.158
author:1611157182=
diff:1611157182:1611157150:=43d42%0a%3c The segments are numbered in the same way as [[#chromaton|chromaton]].%0a
host:1611157182=104.175.54.158
author:1611157150=
diff:1611157150:1611157036:=39c39%0a%3c It helps that the data in any one region is a sampling of data from across the message, so that if one area is damaged then you don't have a total loss of say the beginning of the message.  Also the center of the chromaton contains no data, so it is difficult to damage the chromaton in a way that destroys most of the data, basically the outer edges would need to be destroyed all the way around the chromaton.%0a---%0a> It helps that the data in any one region is a sampling of data from across the message, so that if one area is damaged then you don't have a total loss of say the beginning of the message.%0a
host:1611157150=104.175.54.158
author:1611157036=
diff:1611157036:1611156912:=38,39d37%0a%3c %0a%3c It helps that the data in any one region is a sampling of data from across the message, so that if one area is damaged then you don't have a total loss of say the beginning of the message.%0a
host:1611157036=104.175.54.158
author:1611156912=
diff:1611156912:1611156630:=31a32,33%0a> %0a> The data is read in a spiral starting towards the center and working outwards clockwise.%0a34,36d35%0a%3c !!!Chromaton reading%0a%3c %0a%3c The data is read in a spiral starting towards the center and working outwards clockwise.%0a
host:1611156912=104.175.54.158
author:1611156630=
diff:1611156630:1611156583:=36c36%0a%3c Attach:chromatonlabel.png%0a---%0a> Attach:file.ext%0a
host:1611156630=104.175.54.158
author:1611156583=
diff:1611156583:1611112552:=36d35%0a%3c Attach:file.ext%0a
host:1611156583=104.175.54.158
author:1611112552=
diff:1611112552:1611112495:=20c20%0a%3c Chromaton contains 48 base-6 digits which is 123 bits.  This chromaton is the smallest repeating unit, and thus is like the "atom" of the chromaton code system.  Chromaton is only 11 units long, which is roughly half the size of the smallest QR code; version 1 however it contains around 3/4 the data of the QR code [[https://www.qrcode.com/en/about/version.html|#]]%0a---%0a> Chromaton contains 48 base-6 digits which is 123 bits.  This chromaton is the smallest possible unit, and thus is like the "atom" of the chromaton code system.  Chromaton is only 11 units long, which is roughly half the size of the smallest QR code; version 1 however it contains around 3/4 the data of the QR code [[https://www.qrcode.com/en/about/version.html|#]]%0a
host:1611112552=104.175.54.158
author:1611112495=
diff:1611112495:1611112139:=20c20%0a%3c Chromaton contains 48 base-6 digits which is 123 bits.  This chromaton is the smallest possible unit, and thus is like the "atom" of the chromaton code system.  Chromaton is only 11 units long, which is roughly half the size of the smallest QR code; version 1 however it contains around 3/4 the data of the QR code [[https://www.qrcode.com/en/about/version.html|#]]%0a---%0a> Chromaton contains 48 base-6 digits which is 123 bits.  This chromaton is the smallest possible unit of the chromaton code system.  Chromaton is only 11 units long, which is roughly half the size of the smallest QR code; version 1 however it contains around 3/4 the data of the QR code [[https://www.qrcode.com/en/about/version.html|#]]%0a
host:1611112495=104.175.54.158
author:1611112139=
diff:1611112139:1611111379:=22c22%0a%3c The purple hexagons are the data containing units.  Each purple hexagon can be one of the six colors seen in the center (the center colors used for color correction) thus giving base-6 encoding.%0a---%0a> The purple hexagons are the data containing units.  Each one can be one of the six colors seen in the center (the center colors used for color correction) thus giving base-6 encoding.%0a
host:1611112139=104.175.54.158
author:1611111379=
diff:1611111379:1611111296:=13a14,16%0a> %0a> Hexagonal spiral scalable [[https://tex.stackexchange.com/questions/275490/is-there-an-easy-way-to-number-a-hexagonal-spiral|#]]%0a> %0a58,60d60%0a%3c %0a%3c !!Links%0a%3c Hexagonal spiral numbering scalable [[https://tex.stackexchange.com/questions/275490/is-there-an-easy-way-to-number-a-hexagonal-spiral|#]]%0a
host:1611111379=104.175.54.158
author:1611111296=
diff:1611111296:1611111127:=0a1%0a> (:nogroupheader:)%0a2,3c3,4%0a%3c (:Summary:A QR Code alternative that is infinitely scale-able, open source, human readable, and compact:)%0a%3c (:Published:1/19/2021:)%0a---%0a> (:Summary:A Next Generation Scalable Crypto-Collectible Network:)%0a> (:Published:1/6/2021:)%0a5,6c6,7%0a%3c (:License:[[https://en.m.wikipedia.org/wiki/Res_communis|Site License]]:)%0a%3c (:Update:1/19/2021:)%0a---%0a> (:License:[[https://en.m.wikipedia.org/wiki/Res_communis|Site Licence]]:)%0a> (:Update:1/14/2021:)%0a10c11%0a%3c (:Archive:[[https://archive.is/hQPLP|Archive.is]], [[https://web.archive.org/web/20210120025440/http://www.naturewiki.org/wiki/pmwiki.php/NatureWiki/Chromaton|Archive.org]]:)%0a---%0a> (:Archive:[[https://archive.is/1UeCR|Archive.is]], [[https://web.archive.org/web/20210115020355/http://www.naturewiki.org/wiki/pmwiki.php/NatureWiki/DigitalCollectibleNetwork|Archive.org]]:)%0a13c14%0a%3c %0a---%0a> https://archive.is/hQPLP%0a
host:1611111296=104.175.54.158
author:1611111127=
diff:1611111127:1611111037:=1,13d0%0a%3c (:nogroupheader:)%0a%3c (:include SkinsHeader:)%0a%3c (:Summary:A Next Generation Scalable Crypto-Collectible Network:)%0a%3c (:Published:1/6/2021:)%0a%3c (:Author:[[~NatureHacker]]:)%0a%3c (:License:[[https://en.m.wikipedia.org/wiki/Res_communis|Site Licence]]:)%0a%3c (:Update:1/14/2021:)%0a%3c (:Maintainer:[[~NatureHacker]]:)%0a%3c (:Categories:[[!Cryptics]]:)%0a%3c (:Also:none:)%0a%3c (:Archive:[[https://archive.is/1UeCR|Archive.is]], [[https://web.archive.org/web/20210115020355/http://www.naturewiki.org/wiki/pmwiki.php/NatureWiki/DigitalCollectibleNetwork|Archive.org]]:)%0a%3c (:Download:[[{$FullName}?action=print|URL]],[[https://www.web2pdfconvert.com/|PDF from URL]]:)%0a%3c %0a
host:1611111127=104.175.54.158
author:1611111037=
diff:1611111037:1611110845:=1,2d0%0a%3c https://archive.is/hQPLP%0a%3c %0a
host:1611111037=104.175.54.158
author:1611110845=
diff:1611110845:1611110438:=9c9%0a%3c Chromaton contains 48 base-6 digits which is 123 bits.  This chromaton is the smallest possible unit of the chromaton code system.  Chromaton is only 11 units long, which is roughly half the size of the smallest QR code; version 1 however it contains around 3/4 the data of the QR code [[https://www.qrcode.com/en/about/version.html|#]]%0a---%0a> Chromaton contains 48 base-6 digits which is 123 bits.  This chromaton is the smallest possible unit of the chromaton code system.  Chromaton is only 11 units long, which is roughly half the size of the smallest QR code; version 1 however it contains around 3/4 the data of the QR code.%0a
host:1611110845=104.175.54.158
author:1611110438=
diff:1611110438:1611110376:=9c9%0a%3c Chromaton contains 48 base-6 digits which is 123 bits.  This chromaton is the smallest possible unit of the chromaton code system.  Chromaton is only 11 units long, which is roughly half the size of the smallest QR code; version 1 however it contains around 3/4 the data of the QR code.%0a---%0a> Chromaton contains 48 base-6 digits which is 123 bits.  This chromaton is the smallest possible unit of the chromaton code system.  Chromaton is only 11 units long, which is roughly half the size of the smallest QR code; version 1.%0a
host:1611110438=104.175.54.158
author:1611110376=
diff:1611110376:1611110101:=33d32%0a%3c Trichrome contains 3 chromaton which is 144 base-6 digits or 369 binary digits (bits). This capacity is between version 2 and 3 QR code.%0a37d35%0a%3c Kilotrichrome contains 3 [[#kilochromaton|kilochromaton]] which is 6,912 base-6 digits or 17,712 binary bits.  This is similar to a version 34 QR code.%0a
host:1611110376=104.175.54.158
author:1611110101=
diff:1611110101:1611109991:=25,31d24%0a%3c !!Kilochromaton[[#kilochromaton]]%0a%3c Kilochromaton contain 48 chromaton and thus contains 2,304 base-6 digits or 5,904 bits which is comparable to a version 18 QR code.%0a%3c Attach:kilochromaton.png%0a%3c %0a%3c !!Megachromaton%0a%3c Megachromaton contains 48 kilochromaton and thus contains 110,592 base-6 digits or 283,392 bits which is roughly 12x the data capacity of the largest QR code; version 40.%0a%3c %0a44a38,43%0a> !!Kilochromaton[[#kilochromaton]]%0a> Kilochromaton contain 48 chromaton and thus contains 2,304 base-6 digits or 5,904 bits which is comparable to a version 18 QR code.%0a> Attach:kilochromaton.png%0a> %0a> !!Megachromaton%0a> Megachromaton contains 48 kilochromaton and thus contains 110,592 base-6 digits or 283,392 bits which is roughly 12x the data capacity of the largest QR code; version 40.%0a\ No newline at end of file%0a
host:1611110101=104.175.54.158
author:1611109991=
diff:1611109991:1611109601:=5,6d4%0a%3c %0a%3c Chromaton can be rotated any way desired, the processing marks will help the software to orient to count correctly.  Also chromaton can be stacked together with a forward bias, or backward bias when fitting them together like puzzle pieces.  Again this does not effect anything.%0a
host:1611109991=104.175.54.158
author:1611109601=
diff:1611109601:1611109561:=27c27%0a%3c Attach:kilotrichrome.png%0a---%0a> Attach:file.ext%0a
host:1611109601=104.175.54.158
author:1611109561=
diff:1611109561:1611109476:=25,27d24%0a%3c %0a%3c !!Kilotrichrome%0a%3c Attach:file.ext%0a
host:1611109561=104.175.54.158
author:1611109476=
diff:1611109476:1611109342:=24c24%0a%3c Attach:trichrome.png%0a---%0a> Attach:file.ext%0a
host:1611109476=104.175.54.158
author:1611109342=
diff:1611109342:1611109259:=24d23%0a%3c Attach:file.ext%0a
host:1611109342=104.175.54.158
author:1611109259=
diff:1611109259:1611108686:=31d30%0a%3c Attach:kilochroma.png%0a
host:1611109259=104.175.54.158
author:1611108686=
diff:1611108686:1611107912:=22,23d21%0a%3c %0a%3c !!Trichrome%0a
host:1611108686=104.175.54.158
author:1611107912=
diff:1611107912:1611107893:=4c4%0a%3c Chromaton is a free and open source visual code system similar to the patented QR (Quick Response) code.  Chromaton was natively designed to use six colors and is human readable.  Black and white are used for processing and do not constitute data.  The chromaton system is infinitely scalable in a fractal way.  Kilochromaton, Megachromaton, Gigachromaton, Terachromaton and more are all possible, the only limitation is the fidelity of the camera.%0a---%0a> Chromaton is a visual code system similar to QR (Quick Response) code.  Chromaton was natively designed to use six colors and is human readable.  Black and white are used for processing and do not constitute data.  The chromaton system is infinitely scalable in a fractal way.  Kilochromaton, Megachromaton, Gigachromaton, Terachromaton and more are all possible, the only limitation is the fidelity of the camera.%0a
host:1611107912=104.175.54.158
author:1611107893=
diff:1611107893:1611107796:=4c4%0a%3c Chromaton is a visual code system similar to QR (Quick Response) code.  Chromaton was natively designed to use six colors and is human readable.  Black and white are used for processing and do not constitute data.  The chromaton system is infinitely scalable in a fractal way.  Kilochromaton, Megachromaton, Gigachromaton, Terachromaton and more are all possible, the only limitation is the fidelity of the camera.%0a---%0a> Chromaton is a visual code system similar to (Quick Response) QR code.  Chromaton was natively designed to use six colors and is human readable.  Black and white are used for processing and do not constitute data.  The chromaton system is infinitely scalable in a fractal way.  Kilochromaton, Megachromaton, Gigachromaton, Terachromaton and more are all possible, the only limitation is the fidelity of the camera.%0a
host:1611107893=104.175.54.158
author:1611107796=
diff:1611107796:1611107706:=28c28%0a%3c Kilochroma contains 7 [[#kilochromaton|kilochromaton]] and thus contains 16,128 base-6 digits or 41,328 binary digits which is nearly double the data of the largest QR code; version 40.%0a---%0a> Kilochroma contains 7 [[#kilochromaton|kilochromaton]] and thus contains 16,128 base-6 digits or %0a
host:1611107796=104.175.54.158
author:1611107706=
diff:1611107706:1611107668:=28c28%0a%3c Kilochroma contains 7 [[#kilochromaton|kilochromaton]] and thus contains 16,128 base-6 digits or %0a---%0a> Kilochroma contains 7 [[#kilochromaton|kilochromaton]] and thus contains%0a
host:1611107706=104.175.54.158
author:1611107668=
diff:1611107668:1611107637:=29c29%0a%3c !!Kilochromaton[[#kilochromaton]]%0a---%0a> !!Kilochromaton%0a
host:1611107668=104.175.54.158
author:1611107637=
diff:1611107637:1611107570:=19,20d18%0a%3c %0a%3c The data is read in a spiral starting towards the center and working outwards clockwise.%0a
host:1611107637=104.175.54.158
author:1611107570=
diff:1611107570:1611107561:=10d9%0a%3c %0a
host:1611107570=104.175.54.158
author:1611107561=
diff:1611107561:1611107535:=10,17c10,17%0a%3c \\%0a%3c Red = 1\\%0a%3c Light blue = 2\\%0a%3c Green = 3\\%0a%3c Magenta = 4\\%0a%3c Blue = 5\\%0a%3c Yellow = 6\\%0a%3c \\%0a---%0a> %0a> Red = 1/%0a> Light blue = 2/%0a> Green = 3/%0a> Magenta = 4/%0a> Blue = 5/%0a> Yellow = 6/%0a> %0a
host:1611107561=104.175.54.158
author:1611107535=
diff:1611107535:1611107523:=11,16c11,16%0a%3c Red = 1/%0a%3c Light blue = 2/%0a%3c Green = 3/%0a%3c Magenta = 4/%0a%3c Blue = 5/%0a%3c Yellow = 6/%0a---%0a> Red = 1%0a> Light blue = 2%0a> Green = 3%0a> Magenta = 4%0a> Blue = 5%0a> Yellow = 6%0a
host:1611107535=104.175.54.158
author:1611107523=
diff:1611107523:1611107385:=8,17d7%0a%3c %0a%3c The purple hexagons are the data containing units.  Each one can be one of the six colors seen in the center (the center colors used for color correction) thus giving base-6 encoding.%0a%3c %0a%3c Red = 1%0a%3c Light blue = 2%0a%3c Green = 3%0a%3c Magenta = 4%0a%3c Blue = 5%0a%3c Yellow = 6%0a%3c %0a
host:1611107523=104.175.54.158
author:1611107385=
diff:1611107385:1611107357:=7c7%0a%3c Chromaton contains 48 base-6 digits which is 123 bits.  This chromaton is the smallest possible unit of the chromaton code system.  Chromaton is only 11 units long, which is roughly half the size of the smallest QR code; version 1.%0a---%0a> Chromaton contains 48 base-6 digits which is 123 bits.  This chromaton is the smallest possible unit of the chromaton code system.  Chromaton is only 11 units long, which is less than half the size of the smallest QR code; version 1.%0a
host:1611107385=104.175.54.158
author:1611107357=
diff:1611107357:1611107271:=7c7%0a%3c Chromaton contains 48 base-6 digits which is 123 bits.  This chromaton is the smallest possible unit of the chromaton code system.  Chromaton is only 11 units long, which is less than half the size of the smallest QR code; version 1.%0a---%0a> Chromaton contains 48 base-6 digits which is 123 bits.  This chromaton is the smallest possible unit of the chromaton code system.%0a
host:1611107357=104.175.54.158
author:1611107271=
diff:1611107271:1611107220:=4c4%0a%3c Chromaton is a visual code system similar to (Quick Response) QR code.  Chromaton was natively designed to use six colors and is human readable.  Black and white are used for processing and do not constitute data.  The chromaton system is infinitely scalable in a fractal way.  Kilochromaton, Megachromaton, Gigachromaton, Terachromaton and more are all possible, the only limitation is the fidelity of the camera.%0a---%0a> Chromaton is a visual code system similar to (Quick Response) QR code.  Chromaton was natively designed to use six colors.  Black and white are used for processing and do not constitute data.  The chromaton system is infinitely scalable in a fractal way.  Kilochromaton, Megachromaton, Gigachromaton, Terachromaton and more are all possible, the only limitation is the fidelity of the camera.%0a
host:1611107271=104.175.54.158
author:1611107220=
diff:1611107220:1611107132:=14,15d13%0a%3c !!Kilochroma%0a%3c Kilochroma contains 7 [[#kilochromaton|kilochromaton]] and thus contains%0a
host:1611107220=104.175.54.158
author:1611107132=
diff:1611107132:1611106541:=3,5d2%0a%3c !!Overview%0a%3c Chromaton is a visual code system similar to (Quick Response) QR code.  Chromaton was natively designed to use six colors.  Black and white are used for processing and do not constitute data.  The chromaton system is infinitely scalable in a fractal way.  Kilochromaton, Megachromaton, Gigachromaton, Terachromaton and more are all possible, the only limitation is the fidelity of the camera.%0a%3c %0a11c8%0a%3c Chroma is 7 chromaton and thus contains 336 base-6 digits or 861 bits, roughly equivalent to a version 5 QR code.%0a---%0a> Chroma is 7 chromaton and thus contains 336 base-6 digits or 861 bits.%0a15,19c12%0a%3c Kilochromaton contain 48 chromaton and thus contains 2,304 base-6 digits or 5,904 bits which is comparable to a version 18 QR code.%0a%3c Attach:kilochromaton.png%0a%3c %0a%3c !!Megachromaton%0a%3c Megachromaton contains 48 kilochromaton and thus contains 110,592 base-6 digits or 283,392 bits which is roughly 12x the data capacity of the largest QR code; version 40.%0a\ No newline at end of file%0a---%0a> Attach:kilochromaton.png%0a\ No newline at end of file%0a
host:1611107132=104.175.54.158
author:1611106541=
diff:1611106541:1611106475:=8d7%0a%3c Chroma is 7 chromaton and thus contains 336 base-6 digits or 861 bits.%0a
host:1611106541=104.175.54.158
author:1611106475=
diff:1611106475:1611106443:=4c4%0a%3c Chromaton contains 48 base-6 digits which is 123 bits.  This chromaton is the smallest possible unit of the chromaton code system.%0a---%0a> Chromaton contains 48 base-6 digits which is 123 bits.%0a
host:1611106475=104.175.54.158
author:1611106443=
diff:1611106443:1611105737:=4d3%0a%3c Chromaton contains 48 base-6 digits which is 123 bits.%0a
host:1611106443=104.175.54.158
author:1611105737=
diff:1611105737:1611105737:=1,10d0%0a%3c Hexagonal spiral scalable [[https://tex.stackexchange.com/questions/275490/is-there-an-easy-way-to-number-a-hexagonal-spiral|#]]%0a%3c %0a%3c !!Chromaton%0a%3c Attach:chromaton.png%0a%3c %0a%3c !!Chroma%0a%3c Attach:chroma.png%0a%3c %0a%3c !!Kilochromaton%0a%3c Attach:kilochromaton.png%0a\ No newline at end of file%0a
host:1611105737=104.175.54.158
